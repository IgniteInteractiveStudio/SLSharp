<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICSharpCode.NRefactory</name>
    </assembly>
    <members>
        <member name="T:ICSharpCode.NRefactory.CSharp.Accessor">
            <summary>
            get/set/add/remove
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.INode">
            <summary>
            AST node that supports pattern matching.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.GetChildByRole``1(ICSharpCode.NRefactory.Role{``0})">
            <summary>
            Gets the first child with the specified role.
            Returns the role's null object if the child is not found.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.AddChildUnsafe(ICSharpCode.NRefactory.CSharp.AstNode,ICSharpCode.NRefactory.Role)">
            <summary>
            Adds a child without performing any safety checks.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.Remove">
            <summary>
            Removes this node from its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.ReplaceWith(ICSharpCode.NRefactory.CSharp.AstNode)">
            <summary>
            Replaces this node with the new node.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.Clone">
            <summary>
            Clones the whole subtree starting at this AST node.
            </summary>
            <remarks>Annotations are copied over to the new nodes; and any annotations implementing ICloneable will be cloned.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.Ancestors">
            <summary>
            Gets the ancestors of this node (excluding this node itself)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.Descendants">
            <summary>
            Gets all descendants of this node (excluding this node itself).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.DescendantsAndSelf">
            <summary>
            Gets all descendants of this node (including this node itself).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.Annotations">
            <summary>
            Gets all annotations stored on this AstNode.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AstNode.Roles.Root">
            <summary>
            Root of an abstract syntax tree.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.DirectionExpression">
            <summary>
            ref Expression
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Expression">
            <summary>
            Base class for expressions.
            </summary>
            <remarks>
            This class is useful even though it doesn't provide any additional functionality:
            It can be used to communicate more information in APIs, e.g. "this subnode will always be an expression"
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Member(System.String)">
            <summary>
            Builds an member reference expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Indexer(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
            <summary>
            Builds an indexer expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Indexer(ICSharpCode.NRefactory.CSharp.Expression[])">
            <summary>
            Builds an indexer expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
            <summary>
            Builds an invocation expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.String,ICSharpCode.NRefactory.CSharp.Expression[])">
            <summary>
            Builds an invocation expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.AstType},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
            <summary>
            Builds an invocation expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
            <summary>
            Builds an invocation expression using this expression as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(ICSharpCode.NRefactory.CSharp.Expression[])">
            <summary>
            Builds an invocation expression using this expression as target.
            </summary>
        </member>
        <member name="T:Mono.CSharp.MemberCore">
            <summary>
              Base representation for members.  This is used to keep track
              of Name, Location and Modifier flags, and handling Attributes.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Attributable">
            <summary>
              Base class for objects that can have Attributes applied to them.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attributable.ApplyAttributeBuilder(Mono.CSharp.Attribute,Mono.CSharp.MethodSpec,System.Byte[],Mono.CSharp.PredefinedAttributes)">
            <summary>
            Use member-specific procedure to apply attribute @a in @cb to the entity being built in @builder
            </summary>
        </member>
        <member name="P:Mono.CSharp.Attributable.AttributeTargets">
            <summary>
            Returns one AttributeTarget for this element.
            </summary>
        </member>
        <member name="P:Mono.CSharp.Attributable.ValidAttributeTargets">
            <summary>
            Gets list of valid attribute targets for explicit target declaration.
            The first array item is default target. Don't break this rule.
            </summary>
        </member>
        <member name="F:Mono.CSharp.MemberCore.cached_name">
            <summary>
              Public name
            </summary>
        </member>
        <member name="F:Mono.CSharp.MemberCore.mod_flags">
            <summary>
              Modifier flags that the user specified in the source code
            </summary>
        </member>
        <member name="F:Mono.CSharp.MemberCore.comment">
            <summary>
              XML documentation comment
            </summary>
        </member>
        <member name="F:Mono.CSharp.MemberCore.caching_flags">
            <summary>
              MemberCore flags at first detected then cached
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.Emit">
            <summary>
            Base Emit method. This is also entry point for CLS-Compliant verification.
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.GetAttributeObsolete">
            <summary>
            Returns instance of ObsoleteAttribute for this MemberCore
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.CheckObsoleteness(Mono.CSharp.Location)">
            <summary>
            Checks for ObsoleteAttribute presence. It's used for testing of all non-types elements
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.IsClsComplianceRequired">
            <summary>
            Analyze whether CLS-Compliant verification must be execute for this MemberCore.
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.IsExposedFromAssembly">
            <summary>
            Returns true when MemberCore is exposed from assembly.
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.EnableOverloadChecks(Mono.CSharp.MemberCore)">
            <summary>
            Returns true when a member supports multiple overloads (methods, indexers, etc)
            </summary>
        </member>
        <member name="M:Mono.CSharp.MemberCore.VerifyClsCompliance">
            <summary>
            The main virtual method for CLS-Compliant verifications.
            The method returns true if member is CLS-Compliant and false if member is not
            CLS-Compliant which means that CLS-Compliant tests are not necessary. A descendants override it
            and add their extra verifications.
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberCore.Location">
            <summary>
              Location where this declaration happens
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberCore.DocCommentHeader">
            <summary>
              Represents header string for documentation comment 
              for each member types.
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberCore.CLSAttributeValue">
            <summary>
            Goes through class hierarchy and gets value of first found CLSCompliantAttribute.
            If no is attribute exists then assembly CLSCompliantAttribute is returned.
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberCore.HasClsCompliantAttribute">
            <summary>
            Returns true if MemberCore is explicitly marked with CLSCompliantAttribute
            </summary>
        </member>
        <member name="M:Mono.CSharp.InterfaceMemberBase.FindBaseMember(Mono.CSharp.MemberSpec@,System.Boolean@)">
            <summary>
            Gets base method and its return type
            </summary>
        </member>
        <member name="T:Mono.CSharp.IMethodData">
            <summary>
            Interface for MethodData class. Holds links to parent members to avoid member duplication.
            </summary>
        </member>
        <member name="M:Mono.CSharp.MethodOrOperator.ConditionalConditions">
            <summary>
            Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
            </summary>
        </member>
        <member name="T:Mono.CSharp.ExpressionStatement">
            <summary>
              This is just a base class for expressions that can
              appear on statements (invocations, object creation,
              assignments, post/pre increment and decrement).  The idea
              being that they would support an extra Emition interface that
              does not leave a result on the stack.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Expression">
            <remarks>
              Base class for expressions
            </remarks>
        </member>
        <member name="M:Mono.CSharp.Expression.DoResolve(Mono.CSharp.ResolveContext)">
             <summary>
               Performs semantic analysis on the Expression
             </summary>
            
             <remarks>
               The Resolve method is invoked to perform the semantic analysis
               on the node.
            
               The return value is an expression (it can be the
               same expression in some cases) or a new
               expression that better represents this node.
               
               For example, optimizations of Unary (LiteralInt)
               would return a new LiteralInt with a negated
               value.
               
               If there is an error during semantic analysis,
               then an error should be reported (using Report)
               and a null value should be returned.
               
               There are two side effects expected from calling
               Resolve(): the the field variable "eclass" should
               be set to any value of the enumeration
               `ExprClass' and the type variable should be set
               to a valid type (this is the type of the
               expression).
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Expression.Resolve(Mono.CSharp.ResolveContext,Mono.CSharp.ResolveFlags)">
             <summary>
               Resolves an expression and performs semantic analysis on it.
             </summary>
            
             <remarks>
               Currently Resolve wraps DoResolve to perform sanity
               checking and assertion checking on what we expect from Resolve.
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Expression.Resolve(Mono.CSharp.ResolveContext)">
            <summary>
              Resolves an expression and performs semantic analysis on it.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Expression.ResolveLValue(Mono.CSharp.ResolveContext,Mono.CSharp.Expression)">
             <summary>
               Resolves an expression for LValue assignment
             </summary>
            
             <remarks>
               Currently ResolveLValue wraps DoResolveLValue to perform sanity
               checking and assertion checking on what we expect from Resolve
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Expression.Emit(Mono.CSharp.EmitContext)">
             <summary>
               Emits the code for the expression
             </summary>
            
             <remarks>
               The Emit method is invoked to generate the code
               for the expression.  
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Expression.#ctor">
            <summary>
              Protected constructor.  Only derivate types should
              be able to be created
            </summary>
        </member>
        <member name="M:Mono.CSharp.Expression.ExprClassFromMemberInfo(Mono.CSharp.MemberSpec,Mono.CSharp.Location)">
            <summary>
              Returns a fully formed expression after a MemberLookup
            </summary>
            
        </member>
        <member name="M:Mono.CSharp.Expression.GetOperatorTrue(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.Location)">
            <summary>
              Returns an expression that can be used to invoke operator true
              on the expression if it exists.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Expression.GetOperatorFalse(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.Location)">
            <summary>
              Returns an expression that can be used to invoke operator false
              on the expression if it exists.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Expression.Error_UnexpectedKind(Mono.CSharp.Report,Mono.CSharp.MemberCore,System.String,Mono.CSharp.Location)">
            <summary>
              Reports that we were expecting `expr' to be of class `expected'
            </summary>
        </member>
        <member name="M:Mono.CSharp.ExpressionStatement.EmitStatement(Mono.CSharp.EmitContext)">
            <summary>
              Requests the expression to be emitted in a `statement'
              context.  This means that no new value is left on the
              stack after invoking this method (constrasted with
              Emit that will always leave a value on the stack).
            </summary>
        </member>
        <member name="M:Mono.CSharp.MethodData.DefineMethodBuilder(Mono.CSharp.TypeContainer,System.String,Mono.CSharp.ParametersCompiled)">
            <summary>
            Create the MethodBuilder for the method 
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeReference">
            <summary>
            Represents a reference to a type.
            Must be resolved before it can be used as type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this type reference.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.FullName">
            <summary>
            Gets the fully qualified name of the class the return type is pointing to.
            </summary>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Collections.Generic.List" for List&lt;string&gt;
            "System.Environment.SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Name">
            <summary>
            Gets the short name of the class the return type is pointing to.
            </summary>
            <returns>
            "Int32[]" for int[]<br/>
            "List" for List&lt;string&gt;
            "SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Namespace">
            <summary>
            Gets the namespace of the class the return type is pointing to.
            </summary>
            <returns>
            "System" for int[]<br/>
            "System.Collections.Generic" for List&lt;string&gt;
            "System" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.ReflectionName">
            <summary>
            Gets the full reflection name of the element.
            </summary>
            <remarks>
            For types, the reflection name can be parsed back into a ITypeReference by using
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String,ICSharpCode.NRefactory.TypeSystem.IEntity)"/>.
            </remarks>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Int32[][,]" for C# int[,][]<br/>
            "System.Collections.Generic.List`1[[System.String]]" for List&lt;string&gt;
            "System.Environment+SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetDefinition">
            <summary>
            Gets the underlying type definition.
            Can return null for types which do not have a type definition (for example arrays, pointers, type parameters)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.AcceptVisitor(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for this type.
            </summary>
            <returns>The return value of the ITypeVisitor.Visit call</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.VisitChildren(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based
            on the return values of the visit calls.
            </summary>
            <returns>A copy of this type, with all children replaced by the return value of the corresponding visitor call.
            If the visitor returned the original types for all children (or if there are no children), returns <c>this</c>.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetBaseTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets the direct base types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition})">
            <summary>
            Gets inner classes (including inherited inner classes).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IMethod})">
            <summary>
            Gets all methods that can be called on this return type.
            </summary>
            <remarks>The list does not include constructors.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetConstructors(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IMethod})">
            <summary>
            Gets all instance constructors for this type.
            </summary>
            <remarks>This list does not include constructors in base classes or static constructors.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetProperties(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IProperty})">
            <summary>
            Gets all properties that can be called on this return type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetFields(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IField})">
            <summary>
            Gets all fields that can be called on this return type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetEvents(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IEvent})">
            <summary>
            Gets all events that can be called on this return type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.IsReferenceType">
            <summary>
            Gets whether the type is a reference type or value type.
            </summary>
            <returns>
            true, if the type is a reference type.
            false, if the type is a value type.
            null, if the type is not known (e.g. unconstrained generic type parameter or type not found)
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.DeclaringType">
            <summary>
            Gets the parent type, if this is a nested type.
            Returns null for top-level types.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.TypeParameterCount">
            <summary>
            Gets the number of type parameters.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty">
            <summary>
            Represents a specialized IProperty (e.g. after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultProperty">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IProperty"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractMember">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMember"/> implementations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IMember">
            <summary>
            Method/field/entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Region">
            <summary>
            Gets the complete entity region (including header+body)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.BodyRegion">
            <summary>
            Gets the entity body region.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition">
            <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Accessibility">
            <summary>
            Gets the accessibility of this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsStatic">
            <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsAbstract">
            <summary>
            Returns whether this entity is abstract.
            </summary>
            <remarks>Static classes also count as abstract classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSealed">
            <summary>
            Returns whether this entity is sealed.
            </summary>
            <remarks>Static classes also count as sealed classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsShadowing">
            <summary>
            Gets whether this member is declared to be shadowing another member with the same name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSynthetic">
            <summary>
            Gets whether this member is generated by a macro/compiler feature.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.ProjectContent">
            <summary>
            The assembly in which this entity is defined.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property never returns null -- for top-level members, it returns SharedTypes.UnknownType.
            If this is not a specialized member, the value returned is equal to <see cref="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.MemberDefinition">
            <summary>
            Gets the original member definition for this member.
            Returns <c>this</c> if this is not a specialized member.
            Specialized members are the result of overload resolution with type substitution.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.ReturnType">
            <summary>
            Gets the return type of this member.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.InterfaceImplementations">
            <summary>
            Gets the list of interfaces this member is implementing explicitly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsVirtual">
            <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are already overriding a method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsOverridable">
            <summary>
            Gets if the member can be overridden. Returns true when the member is "virtual" or "override" but not "sealed".
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractMember.#ctor(ICSharpCode.NRefactory.TypeSystem.IMember)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IProperty">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IParameterizedMember">
            <summary>
            Represents a method or property.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty.SubstituteTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Performs type substitution in parameter types and in the return type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IInterningProvider">
            <summary>
            Provider used for interning.
            </summary>
            <remarks>
            A simple IInterningProvider implementation could use 3 dictionaries:
             1. using value equality comparer (for certain types known to implement value equality, e.g. string and IType)
             2. using comparer that calls into ISupportsInterning (for types implementing ISupportsInterning)
             3. list comparer (for InternList method)
            
            On the first Intern()-call, the provider tells the object to prepare for interning (ISupportsInterning.PrepareForInterning)
            and stores it into a dictionary. On further Intern() calls, the original object is returned for all equal objects.
            This allows reducing the memory usage by using a single object instance where possible.
            
            Interning provider implementations could also use the interning logic for different purposes:
            for example, it could be used to determine which objects are used jointly between multiple type definitions
            and which are used only within a single type definition. Then a persistent file format could be organized so
            that shared objects are loaded only once, yet non-shared objects get loaded lazily together with the class.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IInterningProvider.Intern``1(``0)">
            <summary>
            Interns the specified object.
            The object must implement <see cref="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning"/>, or must be of one of the types
            known to the interning provider to use value equality,
            otherwise it will be returned without being interned.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.LocalResolveResult">
            <summary>
            Represents a local variable.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult">
            <summary>
            Represents the result of resolving an expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberResolveResult">
            <summary>
            Represents the result of a member invocation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ByReferenceResolveResult">
            <summary>
            Represents the resolve result of an 'ref x' or 'out x' expression.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.DestructorDeclaration.Name">
            <summary>
            Gets/Sets the name of the class containing the destructor.
            This property can be used to inform the output visitor about the class name when writing a destructor declaration
            without writing the complete type declaration. It is ignored when the destructor has a type declaration as parent.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TryCatchStatement">
            <summary>
            try TryBlock CatchClauses finally FinallyBlock
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Statement">
            <summary>
            Base class for statements.
            </summary>
            <remarks>
            This class is useful even though it doesn't provide any additional functionality:
            It can be used to communicate more information in APIs, e.g. "this subnode will always be a statement"
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.CatchClause">
            <summary>
            catch (Type VariableName) { Body }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.CheckedStatement">
            <summary>
            checked BodyBlock
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.PrimitiveExpression">
            <summary>
            Represents a literal value.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AnonymousMethodExpression">
            <summary>
            delegate(Parameters) {Body}
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ArrayInitializerExpression">
            <summary>
            { Elements }
            </summary>
        </member>
        <member name="T:Mono.CSharp.SeekableStreamReader">
             <summary>
               This is an arbitrarily seekable StreamReader wrapper.
            
               It uses a self-tuning buffer to cache the seekable data,
               but if the seek is too far, it may read the underly
               stream all over from the beginning.
             </summary>
        </member>
        <member name="P:Mono.CSharp.SeekableStreamReader.Position">
            <remarks>
              This value corresponds to the current position in a stream of characters.
              The StreamReader hides its manipulation of the underlying byte stream and all
              character set/decoding issues.  Thus, we cannot use this position to guess at
              the corresponding position in the underlying byte stream even though there is
              a correlation between them.
            </remarks>
        </member>
        <member name="T:Mono.CSharp.CompletionResult">
            <summary>
              An exception used to terminate the compiler resolution phase and provide completions
            </summary>
            <remarks>
              This is thrown when we want to return the completions or
              terminate the completion process by AST nodes used in
              the completion process.
            </remarks>
        </member>
        <member name="T:Mono.CSharp.Tokenizer">
            <summary>
               Tokenizer for C# source code. 
            </summary>
        </member>
        <member name="T:Mono.CSharp.yyParser.yyInput">
            must be implemented by a scanner object to supply input to the parser.
        </member>
        <member name="M:Mono.CSharp.yyParser.yyInput.advance">
            move on to next token.
                    @return false if positioned beyond tokens.
                    @throws IOException on input error.
        </member>
        <member name="M:Mono.CSharp.yyParser.yyInput.token">
            classifies current token.
                    Should not be called if advance() returned false.
                    @return current %token or single character.
        </member>
        <member name="M:Mono.CSharp.yyParser.yyInput.value">
            associated with current token.
                    Should not be called if advance() returned false.
                    @return value for token().
        </member>
        <member name="M:Mono.CSharp.Tokenizer.ParsePragmaDirective(System.String)">
            <summary>
            Handles #pragma directive
            </summary>
        </member>
        <member name="T:Mono.CSharp.TypeContainer">
            <summary>
              This is the base class for structs and classes.  
            </summary>
        </member>
        <member name="F:Mono.CSharp.DeclSpace.TypeBuilder">
            <summary>
              This points to the actual definition that is being
              created with System.Reflection.Emit
            </summary>
        </member>
        <member name="M:Mono.CSharp.DeclSpace.AddToContainer(Mono.CSharp.MemberCore,System.String)">
            <summary>
            Adds the member to defined_names table. It tests for duplications and enclosing name conflicts
            </summary>
        </member>
        <member name="M:Mono.CSharp.DeclSpace.GetDefinition(System.String)">
            <summary>
              Returns the MemberCore associated with a given name in the declaration
              space. It doesn't return method based symbols !!
            </summary>
            
        </member>
        <member name="M:Mono.CSharp.DeclSpace.DefineType">
            <remarks>
             Should be overriten by the appropriate declaration space
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Mono.CSharp.TypeContainer.pending" -->
        <member name="M:Mono.CSharp.TypeContainer.AddIndexer(Mono.CSharp.Indexer)">
            <summary>
            Indexer has special handling in constrast to other AddXXX because the name can be driven by IndexerNameAttribute
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeContainer.ResolveBaseTypes(Mono.CSharp.FullNamedExpression@)">
            <summary>
              This function computes the Base class and also the
              list of interfaces that the class or struct @c implements.
              
              The return value is an array (might be null) of
              interfaces implemented (as Types).
              
              The @base_class argument is set to the base object or null
              if this is `System.Object'. 
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeContainer.Define">
            <summary>
              Populates our TypeBuilder with fields and methods
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeContainer.EmitType">
            <summary>
              Emits the code, this step is performed after all
              the types, enumerations, constructors
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeContainer.VerifyImplements(Mono.CSharp.InterfaceMemberBase)">
            <summary>
              Performs checks for an explicit interface implementation.  First it
              checks whether the `interface_type' is a base inteface implementation.
              Then it checks whether `name' exists in the interface type.
            </summary>
        </member>
        <member name="P:Mono.CSharp.TypeContainer.HasEquals">
            <summary>
            Method container contains Equals method
            </summary>
        </member>
        <member name="P:Mono.CSharp.TypeContainer.HasGetHashCode">
            <summary>
            Method container contains GetHashCode method
            </summary>
        </member>
        <member name="M:Mono.CSharp.ClassOrStruct.DefineDefaultConstructor(System.Boolean)">
            <summary>
            Defines the default constructors 
            </summary>
        </member>
        <member name="M:Mono.CSharp.Class.ConditionalConditions">
            Search for at least one defined condition in ConditionalAttribute of attribute class
            Valid only for attribute classes.
        </member>
        <member name="T:Mono.CSharp.Interface">
            <summary>
              Interfaces
            </summary>
        </member>
        <member name="F:Mono.CSharp.Interface.AllowedModifiers">
            <summary>
              Modifiers allowed in a class declaration
            </summary>
        </member>
        <member name="T:Mono.CSharp.CSharpParser">
            <summary>
               The C# Parser
            </summary>
        </member>
        <member name="F:Mono.CSharp.CSharpParser.yyFinal">
            debugging support, requires the package jay.yydebug.
                  Set to null to suppress debugging messages.
        </member>
        <member name="F:Mono.CSharp.CSharpParser.current_block">
            <summary>
              Current block is used to add statements as we find
              them.  
            </summary>
        </member>
        <member name="F:Mono.CSharp.CSharpParser.current_local_parameters">
            <summary>
              This is used by the unary_expression code to resolve
              a name against a parameter.  
            </summary>
        </member>
        <member name="F:Mono.CSharp.CSharpParser.oob_stack">
            
             An out-of-band stack.
            
        </member>
        <member name="F:Mono.CSharp.CSharpParser.yacc_verbose_flag">
            
             Controls the verbosity of the errors produced by the parser
            
        </member>
        <member name="F:Mono.CSharp.CSharpParser.UnexpectedEOF">
             
             Used by the interactive shell, flags whether EOF was reached
             and an error was produced
            
        </member>
        <member name="F:Mono.CSharp.CSharpParser.file">
            
             The current file.
            
        </member>
        <member name="F:Mono.CSharp.CSharpParser.tmpComment">
            
             Temporary Xml documentation cache.
             For enum types, we need one more temporary store.
            
        </member>
        <member name="F:Mono.CSharp.CSharpParser.current_attr_target">
            Current attribute target
        </member>
        <member name="F:Mono.CSharp.CSharpParser.InteractiveResult">
            When using the interactive parser, this holds the
            resulting expression
        </member>
        <member name="F:Mono.CSharp.CSharpParser.ErrorOutput">
            error output stream.
                  It should be changeable.
        </member>
        <member name="M:Mono.CSharp.CSharpParser.yyerror(System.String)">
            simplified error message.
                  @see <a href="#yyerror(java.lang.String, java.lang.String[])">yyerror</a>
        </member>
        <member name="M:Mono.CSharp.CSharpParser.yyerror(System.String,System.String[])">
            (syntax) error message.
                  Can be overwritten to control message format.
                  @param message text to be displayed.
                  @param expected vector of acceptable tokens, if available.
        </member>
        <member name="F:Mono.CSharp.CSharpParser.yyExpectingState">
            index-checked interface to yyNames[].
                  @param token single character or %token value.
                  @return token name or [illegal] or [unknown].
        </member>
        <member name="M:Mono.CSharp.CSharpParser.yyExpectingTokens(System.Int32)">
            computes list of expected tokens on error by tracing the tables.
                  @param state for which to compute the list.
                  @return list of token names.
        </member>
        <member name="M:Mono.CSharp.CSharpParser.yyparse(Mono.CSharp.yyParser.yyInput,System.Object)">
            the generated parser, with debugging messages.
                  Maintains a state and a value stack, currently with fixed maximum size.
                  @param yyLex scanner.
                  @param yydebug debug message writer implementing yyDebug, or null.
                  @return result of the last reduction, if any.
                  @throws yyException on irrecoverable parse error.
        </member>
        <member name="F:Mono.CSharp.CSharpParser.yyMax">
            initial size and increment of the state/value stack [default 256].
                  This is not final so that it can be overwritten outside of invocations
                  of yyparse().
        </member>
        <member name="M:Mono.CSharp.CSharpParser.yyDefault(System.Object)">
            executed at the beginning of a reduce action.
                  Used as $$ = yyDefault($1), prior to the user-specified action, if any.
                  Can be overwritten to provide deep copy, etc.
                  @param first value for $1, or null.
                  @return first.
        </member>
        <member name="M:Mono.CSharp.CSharpParser.yyparse(Mono.CSharp.yyParser.yyInput)">
            the generated parser.
                  Maintains a state and a value stack, currently with fixed maximum size.
                  @param yyLex scanner.
                  @return result of the last reduction, if any.
                  @throws yyException on irrecoverable parse error.
        </member>
        <member name="T:Mono.CSharp.yyParser.yyException">
            thrown for irrecoverable syntax errors and stack overflow.
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultEvent">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IEvent"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultEvent.#ctor(ICSharpCode.NRefactory.TypeSystem.IEvent)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IConversions">
            <summary>
            Interface used to check whether types are convertible.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods">
            <summary>
            Contains extension methods for the type system.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllBaseTypes(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets all base types.
            </summary>
            <remarks>This is the reflexive and transitive closure of <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetBaseTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)"/>.
            Note that this method does not return all supertypes - doing so is impossible due to contravariance
            (and undesirable for covariance as the list could become very large).
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllBaseTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets all base type definitions.
            </summary>
            <remarks>
            This is equivalent to type.GetAllBaseTypes().Select(t => t.GetDefinition()).Where(d => d != null).Distinct().
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsDerivedFrom(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets whether this type definition is derived from the base type defintiion.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsOpen(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is an open type (contains type parameters).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsUnbound(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is unbound.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsEnum(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is an enumeration type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetEnumUnderlyingType(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets the underlying type for this enum type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsDelegate(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is an delegate type.
            </summary>
            <remarks>This method returns <c>false</c> for System.Delegate itself</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetDelegateInvokeMethod(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the invoke method for a delegate type.
            </summary>
            <remarks>
            Returns null if the type is not a delegate type; or if the invoke method could not be found.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.InternalsVisibleTo(ICSharpCode.NRefactory.TypeSystem.IProjectContent,ICSharpCode.NRefactory.TypeSystem.IProjectContent,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets whether the internals of this project are visible to the other project
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllClasses(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets all classes, including nested classes.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeVisitor">
            <summary>
            Base class for the visitor pattern on <see cref="T:ICSharpCode.NRefactory.TypeSystem.IType"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberTypeOrNamespaceReference">
            <summary>
            Reference to a qualified type or namespace name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ITypeOrNamespaceReference">
            <summary>
            Represents a reference which could point to a type or namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ITypeOrNamespaceReference.DoResolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the reference and returns the ResolveResult.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ITypeOrNamespaceReference.ResolveNamespace(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Returns the namespace that is referenced; or null if no such namespace is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberTypeOrNamespaceReference.AddSuffix(System.String)">
            <summary>
            Adds a suffix to the identifier.
            Does not modify the existing type reference, but returns a new one.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.SwitchStatement">
            <summary>
            switch (Expression) { SwitchSections }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Pattern">
            <summary>
            Base class for all patterns.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TypeOfExpression">
            <summary>
            typeof(Type)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ObjectCreateExpression">
            <summary>
            new Type(Arguments) { Initializer }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AstType">
            <summary>
            A type reference in the C# AST.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.MakePointerType">
            <summary>
            Creates a pointer type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.CSharp.ComposedType"/>.
            If this type already is a pointer type, this method just increases the PointerRank of the existing pointer type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.MakeArrayType(System.Int32)">
            <summary>
            Creates an array type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.CSharp.ComposedType"/>.
            If this type already is an array type, the additional rank is prepended to the existing array specifier list.
            Thus, <c>new SimpleType("T").MakeArrayType(1).MakeArrayType(2)</c> will result in "T[,][]".
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.MakeNullableType">
            <summary>
            Creates a nullable type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.CSharp.ComposedType"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Member(System.String)">
            <summary>
            Builds an expression that can be used to access a static member on this type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
            <summary>
            Builds an invocation expression using this type as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Invoke(System.String,ICSharpCode.NRefactory.CSharp.Expression[])">
            <summary>
            Builds an invocation expression using this type as target.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.AstType},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
            <summary>
            Builds an invocation expression using this type as target.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AstNodeCollection`1">
            <summary>
            Represents the children of an AstNode that have a specific role.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ICSharpCode.NRefactory.CSharp.ExternAliasDeclaration" -->
        <member name="T:ICSharpCode.NRefactory.CSharp.DoWhileStatement">
            <summary>
            "do EmbeddedStatement while(Condition);"
            </summary>
        </member>
        <member name="F:Mono.CSharp.PendingImplementation.container">
            <summary>
              The container for this PendingImplementation
            </summary>
        </member>
        <member name="F:Mono.CSharp.PendingImplementation.pending_implementations">
            <summary>
              This is the array of TypeAndMethods that describes the pending implementations
              (both interfaces and abstract methods in base class)
            </summary>
        </member>
        <member name="M:Mono.CSharp.PendingImplementation.IsInterfaceMethod(Mono.CSharp.MemberName,Mono.CSharp.TypeSpec,Mono.CSharp.MethodData,Mono.CSharp.MethodSpec@)">
            <summary>
              Whether the specified method is an interface method implementation
            </summary>
        </member>
        <member name="M:Mono.CSharp.PendingImplementation.InterfaceMethod(Mono.CSharp.MemberName,Mono.CSharp.TypeSpec,Mono.CSharp.MethodData,Mono.CSharp.PendingImplementation.Operation,Mono.CSharp.MethodSpec@)">
             <remarks>
               If a method in Type `t' (or null to look in all interfaces
               and the base abstract class) with name `Name', return type `ret_type' and
               arguments `args' implements an interface, this method will
               return the MethodInfo that this method implements.
            
               If `name' is null, we operate solely on the method's signature.  This is for
               instance used when implementing indexers.
            
               The `Operation op' controls whether to lookup, clear the pending bit, or clear
               all the methods with the given signature.
            
               The `MethodInfo need_proxy' is used when we're implementing an interface's
               indexer in a class.  If the new indexer's IndexerName does not match the one
               that was used in the interface, then we always need to create a proxy for it.
            
             </remarks>
        </member>
        <member name="M:Mono.CSharp.PendingImplementation.DefineProxy(Mono.CSharp.TypeSpec,Mono.CSharp.MethodSpec,Mono.CSharp.MethodSpec)">
             <summary>
               C# allows this kind of scenarios:
               interface I { void M (); }
               class X { public void M (); }
               class Y : X, I { }
            
               For that case, we create an explicit implementation function
               I.M in Y.
             </summary>
        </member>
        <member name="M:Mono.CSharp.PendingImplementation.BaseImplements(Mono.CSharp.TypeSpec,Mono.CSharp.MethodSpec,Mono.CSharp.MethodSpec@)">
            <summary>
              This function tells whether one of our base classes implements
              the given method (which turns out, it is valid to have an interface
              implementation in a base
            </summary>
        </member>
        <member name="M:Mono.CSharp.PendingImplementation.VerifyPendingMethods">
            <summary>
              Verifies that any pending abstract methods or interface methods
              were implemented.
            </summary>
        </member>
        <member name="T:Mono.CSharp.TypeExpr">
            <summary>
              Expression that evaluates to a type
            </summary>
        </member>
        <member name="T:Mono.CSharp.FullNamedExpression">
            <summary>
              Represents a namespace or a type.  The name of the class was inspired by
              section 10.8.1 (Fully Qualified Names).
            </summary>
        </member>
        <member name="T:Mono.CSharp.IAssignMethod">
             <summary>
               This interface is implemented by expressions that can be assigned to.
             </summary>
             <remarks>
               This interface is implemented by Expressions whose values can not
               store the result on the top of the stack.
            
               Expressions implementing this (Properties, Indexers and Arrays) would
               perform an assignment of the Expression "source" into its final
               location.
            
               No values on the top of the stack are expected to be left by
               invoking this method.
             </remarks>
        </member>
        <member name="T:Mono.CSharp.IMemoryLocation">
            <summary>
              This interface is implemented by variables
            </summary>
        </member>
        <member name="M:Mono.CSharp.IMemoryLocation.AddressOf(Mono.CSharp.EmitContext,Mono.CSharp.AddressOp)">
             <summary>
               The AddressOf method should generate code that loads
               the address of the object and leaves it on the stack.
            
               The `mode' argument is used to notify the expression
               of whether this will be used to read from the address or
               write to the address.
            
               This is just a hint that can be used to provide good error
               reporting, and should have no other side effects. 
             </summary>
        </member>
        <member name="T:Mono.CSharp.EnumConstant">
            <summary>
             This class is used to wrap literals which belong inside Enums
            </summary>
        </member>
        <member name="T:Mono.CSharp.Constant">
            <summary>
              Base class for constants and literals.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Constant.GetValue">
            <summary>
             This is used to obtain the actual value of the literal
             cast into an object.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Constant.ConvertExplicitly(System.Boolean,Mono.CSharp.TypeSpec)">
            <summary>
            Maybe ConvertTo name is better. It tries to convert `this' constant to target_type.
            It throws OverflowException 
            </summary>
        </member>
        <member name="M:Mono.CSharp.Constant.TryReduce(Mono.CSharp.ResolveContext,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Attempts to do a compile-time folding of a constant cast.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Constant.IsDefaultInitializer(Mono.CSharp.TypeSpec)">
            <summary>
            Need to pass type as the constant can require a boxing
            and in such case no optimization is possible
            </summary>
        </member>
        <member name="M:Mono.CSharp.Namespace.#ctor(Mono.CSharp.Namespace,System.String)">
            <summary>
              Constructor Takes the current namespace and the
              name.  This is bootstrapped with parent == null
              and name = ""
            </summary>
        </member>
        <member name="M:Mono.CSharp.Namespace.LookupExtensionMethod(Mono.CSharp.IMemberContext,Mono.CSharp.TypeSpec,System.String,System.Int32)">
            
            Looks for extension method in this namespace
            
        </member>
        <member name="P:Mono.CSharp.Namespace.Name">
            <summary>
              The qualified name of the current namespace
            </summary>
        </member>
        <member name="P:Mono.CSharp.Namespace.Parent">
            <summary>
              The parent of this namespace, used by the parser to "Pop"
              the current namespace declaration
            </summary>
        </member>
        <member name="M:Mono.CSharp.NamespaceContainer.AddUsing(Mono.CSharp.MemberName,Mono.CSharp.Location)">
            <summary>
              Records a new namespace for resolving name references
            </summary>
        </member>
        <member name="M:Mono.CSharp.NamespaceContainer.Resolve">
            <summary>
              Used to validate that all the using clauses are correct
              after we are finished parsing all the files.  
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext">
            <summary>
            Proxy that forwards calls to another TypeResolveContext.
            Useful as base class for decorators.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext">
            <summary>
            Context representing the set of assemblies in which a type is being searched.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
            <summary>
            Retrieves a class.
            </summary>
            <param name="nameSpace">Namespace that contains the class</param>
            <param name="name">Name of the class</param>
            <param name="typeParameterCount">Number of type parameters</param>
            <param name="nameComparer">Language-specific rules for how class names are compared</param>
            <returns>The type definition for the class; or null if no such class exists.</returns>
            <remarks>This method never returns inner classes; it can be used only with top-level classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetClasses">
            <summary>
            Retrieves all top-level classes.
            </summary>
            <remarks>
            If this method is called within <c>using (pc.Synchronize())</c>, then the returned enumerable is valid
            only until the end of the synchronize block.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetClasses(System.String,System.StringComparer)">
            <summary>
            Retrieves all classes in the specified namespace.
            </summary>
            <param name="nameSpace">Namespace in which classes are being retrieved. Use <c>string.Empty</c> for the root namespace.</param>
            <param name="nameComparer">Language-specific rules for how namespace names are compared</param>
            <returns>List of classes within that namespace.</returns>
            <remarks>
            If this method is called within <c>using (var spc = pc.Synchronize())</c>, then the returned enumerable is valid
            only until the end of the synchronize block.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetNamespaces">
            <summary>
            Retrieves all namespaces.
            </summary>
            <remarks>
            If this method is called within <c>using (var spc = pc.Synchronize())</c>, then the returned enumerable is valid
            only until the end of the synchronize block.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetNamespace(System.String,System.StringComparer)">
            <summary>
            Gets a namespace.
            </summary>
            <param name="nameSpace">The full name of the namespace.</param>
            <param name="nameComparer">The comparer to use.</param>
            <returns>The full name of the namespace, if it exists; or null if the namespace does not exist.</returns>
            <remarks>
            For StringComparer.Ordinal, the return value is either null or the input namespace.
            For other name comparers, this method returns the declared name of the namespace.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.Synchronize">
            <summary>
            Returns a <see cref="T:ICSharpCode.NRefactory.TypeSystem.ISynchronizedTypeResolveContext"/> that
            represents the same context as this instance, but cannot be modified
            by other threads.
            The ISynchronizedTypeResolveContext must be disposed from the same thread
            that called this method when it is no longer used.
            </summary>
            <remarks>
            A simple implementation might enter a ReaderWriterLock when the synchronized context
            is created, and releases the lock when Dispose() is called.
            However, implementations based on immutable data structures are also possible.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CacheManager">
            <summary>
            Returns the cache manager associated with this resolve context,
            or null if caching is not allowed.
            Whenever the resolve context changes in some way, this property must return a new object to
            ensure that old caches are cleared.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a new ProxyTypeResolveContext.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetClasses">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetClasses(System.String,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetNamespaces">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetNamespace(System.String,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.Synchronize">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.CacheManager">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IAttribute">
            <summary>
            Represents an attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAttribute.GetPositionalArguments(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets the positional arguments passed to the attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAttribute.GetNamedArguments(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets the named arguments passed to the attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAttribute.ResolveConstructor(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the constructor method used for this attribute invocation.
            Returns null if the constructor cannot be found.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.Region">
            <summary>
            Gets the code region of this attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.AttributeType">
            <summary>
            Gets the type of the attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider">
            <summary>
            Provides documentation from an .xml file (as generated by the Microsoft C# compiler).
            </summary>
            <remarks>
            This class first creates an in-memory index of the .xml file, and then uses that to read only the requested members.
            This way, we avoid keeping all the documentation in memory.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IDocumentationProvider">
            <summary>
            Provides XML documentation for members.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.#ctor(System.String)">
            <summary>
            Creates a new XmlDocumentationProvider.
            </summary>
            <param name="fileName">Name of the .xml file.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.SaveIndex(System.IO.BinaryWriter)">
            <summary>
            Saves the index into a binary file.
            Use <see cref="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LoadFromIndex(System.IO.BinaryReader)"/> to load the saved file.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LoadFromIndex(System.IO.BinaryReader)">
            <summary>
            Restores XmlDocumentationProvider from the index file (created by <see cref="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.SaveIndex(System.IO.BinaryWriter)"/>).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(System.String)">
            <summary>
            Get the documentation for the member with the specified documentation key.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.HashCode">
            <summary>
            Hash code of the documentation tag
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.PositionInFile">
            <summary>
            Position in the .xml file where the documentation starts
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.ConstructorDeclaration.Name">
            <summary>
            Gets/Sets the name of the class containing the constructor.
            This property can be used to inform the output visitor about the class name when writing a constructor declaration
            without writing the complete type declaration. It is ignored when the constructor has a type declaration as parent.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.YieldStatement">
            <summary>
            yield return Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UncheckedStatement">
            <summary>
            unchecked BodyBlock
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ContinueStatement">
            <summary>
            continue;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AttributeSection">
            <summary>
            [AttributeTarget: Attributes]
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.PatternMatching.PatternExtensions.Match(ICSharpCode.NRefactory.PatternMatching.INode,ICSharpCode.NRefactory.PatternMatching.INode)">
            <summary>
            Performs a pattern matching operation.
            <c>this</c> is the pattern, <paramref name="other"/> is the AST that is being matched.
            </summary>
            <returns>
            A match object. Check <see cref="!:Match.Success"/> to see whether the match was successful.
            </returns>
            <remarks>
            Patterns are ASTs that contain special pattern nodes (from the PatternMatching namespace).
            However, it is also possible to match two ASTs without any pattern nodes -
            doing so will produce a successful match if the two ASTs are structurally identical.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TypeParameterDeclaration">
            <summary>
            [in|out] Name
            
            Represents a type parameter.
            Note: mirroring the C# syntax, constraints are not part of the type parameter declaration, but belong
            to the parent type or method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ThisReferenceExpression">
            <summary>
            this
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.InvocationExpression">
            <summary>
            Target(Arguments)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Mono.CSharp.Statement.Resolve(Mono.CSharp.BlockContext)" -->
        <member name="M:Mono.CSharp.Statement.ResolveUnreachable(Mono.CSharp.BlockContext,System.Boolean)">
            <summary>
              We already know that the statement is unreachable, but we still
              need to resolve it to catch errors.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Statement.DoEmit(Mono.CSharp.EmitContext)">
            <summary>
              Return value indicates whether all code paths emitted return.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Return">
            <summary>
              Implements the return statement
            </summary>
        </member>
        <member name="T:Mono.CSharp.GotoDefault">
            <summary>
              `goto default' statement
            </summary>
        </member>
        <member name="T:Mono.CSharp.GotoCase">
            <summary>
              `goto case' statement
            </summary>
        </member>
        <member name="T:Mono.CSharp.Block">
             <summary>
               Block represents a C# block.
             </summary>
            
             <remarks>
               This class is used in a number of places: either to represent
               explicit blocks that the programmer places or implicit blocks.
            
               Implicit blocks are used as labels or to introduce variable
               declarations.
            
               Top-level blocks derive from Block, and they are called ToplevelBlock
               they contain extra information that is not necessary on normal blocks.
             </remarks>
        </member>
        <member name="F:Mono.CSharp.Switch.SwitchType">
            <summary>
              The governing switch type
            </summary>
        </member>
        <member name="T:Mono.CSharp.Foreach">
            <summary>
              Implementation of the foreach C# statement
            </summary>
        </member>
        <member name="M:Mono.CSharp.OverloadResolver.BetterFunction(Mono.CSharp.ResolveContext,Mono.CSharp.Arguments,Mono.CSharp.MemberSpec,Mono.CSharp.AParametersCollection,System.Boolean,Mono.CSharp.MemberSpec,Mono.CSharp.AParametersCollection,System.Boolean)">
            <summary>
              Determines "Better function" between candidate
              and the current best match
            </summary>
            <remarks>
               Returns a boolean indicating :
                false if candidate ain't better
                true  if candidate is better than the current best match
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference">
            <summary>
            Contains well-known type references.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Void">
            <summary>
            Gets a type reference pointing to the <c>void</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Object">
            <summary>
            Gets a type reference pointing to the <c>object</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Boolean">
            <summary>
            Gets a type reference pointing to the <c>bool</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.SByte">
            <summary>
            Gets a type reference pointing to the <c>sbyte</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Byte">
            <summary>
            Gets a type reference pointing to the <c>byte</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int16">
            <summary>
            Gets a type reference pointing to the <c>short</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt16">
            <summary>
            Gets a type reference pointing to the <c>ushort</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int32">
            <summary>
            Gets a type reference pointing to the <c>int</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt32">
            <summary>
            Gets a type reference pointing to the <c>uint</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int64">
            <summary>
            Gets a type reference pointing to the <c>long</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt64">
            <summary>
            Gets a type reference pointing to the <c>ulong</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.String">
            <summary>
            Gets a type reference pointing to the <c>string</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Char">
            <summary>
            Gets a type reference pointing to the <c>char</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Single">
            <summary>
            Gets a type reference pointing to the <c>float</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Double">
            <summary>
            Gets a type reference pointing to the <c>double</c> type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.AllKnownTypeReferences">
            <summary>
            Gets all known type references.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.AmbiguousTypeResolveResult">
            <summary>
            Represents an ambiguous type resolve result.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.TypeResolveResult">
            <summary>
            The resolved expression refers to a type name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TextWriterOutputFormatter">
            <summary>
            Writes C# code into a TextWriter.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.IOutputFormatter">
            <summary>
            Output formatter for the Output visitor.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.IOutputFormatter.WriteIdentifier(System.String)">
            <summary>
            Writes an identifier.
            If the identifier conflicts with a keyword, the output visitor will
            call <c>WriteToken("@")</c> before calling WriteIdentifier().
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.IOutputFormatter.WriteKeyword(System.String)">
            <summary>
            Writes a keyword to the output.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.IOutputFormatter.WriteToken(System.String)">
            <summary>
            Writes a token to the output.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.BlockStatement">
            <summary>
            { Statements }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Attribute">
            <summary>
            Attribute(Arguments)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.NamedNode">
            <summary>
            Represents a named node within a pattern.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.IAstVisitor`2">
            <summary>
            AST visitor.
            </summary>
        </member>
        <member name="T:Mono.CSharp.LocalTemporary">
             <summary>
               An Expression to hold a temporary value.
             </summary>
             <remarks>
               The LocalTemporary class is used to hold temporary values of a given
               type to "simulate" the expression semantics. The local variable is
               never captured.
            
               The local temporary is used to alter the normal flow of code generation
               basically it creates a local variable, and its emit instruction generates
               code to access this value, return its address or save its value.
            
               If `is_address' is true, then the value that we store is the address to the
               real value, and not the value itself.
            
               This is needed for a value type, because otherwise you just end up making a
               copy of the value on the stack and modifying it. You really need a pointer
               to the origional value so that you can modify it in that location. This
               Does not happen with a class because a class is a pointer -- so you always
               get the indirection.
            
             </remarks>
        </member>
        <member name="T:Mono.CSharp.Assign">
            <summary>
              The Assign node takes care of assigning the value of source into
              the expression represented by target.
            </summary>
        </member>
        <member name="F:Mono.CSharp.ResolveContext.Switch">
            <summary>
              If this is non-null, points to the current switch statement
            </summary>
        </member>
        <member name="F:Mono.CSharp.ResolveContext.Options.CheckedScope">
             <summary>
               This flag tracks the `checked' state of the compilation,
               it controls whether we should generate code that does overflow
               checking, or if we generate code that ignores overflows.
            
               The default setting comes from the command line option to generate
               checked or unchecked code plus any source code changes using the
               checked/unchecked statements or expressions.   Contrast this with
               the ConstantCheckState flag.
             </summary>
        </member>
        <member name="F:Mono.CSharp.ResolveContext.Options.ConstantCheckState">
            <summary>
              The constant check state is always set to `true' and cant be changed
              from the command line.  The source code can change this setting with
              the `checked' and `unchecked' statements and expressions. 
            </summary>
        </member>
        <member name="F:Mono.CSharp.ResolveContext.Options.DoFlowAnalysis">
            <summary>
              Whether control flow analysis is enabled
            </summary>
        </member>
        <member name="F:Mono.CSharp.ResolveContext.Options.OmitStructFlowAnalysis">
            <summary>
              Whether control flow analysis is disabled on structs
              (only meaningful when DoFlowAnalysis is set)
            </summary>
        </member>
        <member name="F:Mono.CSharp.ResolveContext.Options.ProbingMode">
            
             Indicates the current context is in probing mode, no errors are reported. 
            
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType">
            <summary>
            ParameterizedType represents an instance of a generic type.
            Example: List&lt;string&gt;
            </summary>
            <remarks>
            When getting the members, this type modifies the lists so that
            type parameters in the signatures of the members are replaced with
            the type arguments.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.Immutable">
            <summary>
            Base class for immutable objects. Provides implementation for IFreezable that reports the
            object as always-frozen.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.IType[])">
            <summary>
            Fast internal version of the constructor. (no safety checks)
            Keeps the array that was passed and assumes it won't be modified.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.SubstituteInType(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Substitutes the class type parameters in the <paramref name="type"/> with the
            type arguments of this parameterized type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedTypeReference">
            <summary>
            ParameterizedTypeReference is a reference to generic class that specifies the type parameters.
            Example: List&lt;string&gt;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning">
            <summary>
            Interface for TypeSystem objects that support interning.
            See <see cref="T:ICSharpCode.NRefactory.TypeSystem.IInterningProvider"/> for more information.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.PrepareForInterning(ICSharpCode.NRefactory.TypeSystem.IInterningProvider)">
            <summary>
            Interns child objects and strings.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.GetHashCodeForInterning">
            <summary>
            Gets a hash code for interning.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.EqualsForInterning(ICSharpCode.NRefactory.TypeSystem.ISupportsInterning)">
            <summary>
            Equality test for interning.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField">
            <summary>
            Represents a specialized IField (e.g. after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultField">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IField"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IField">
            <summary>
            Represents a field or constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IVariable">
            <summary>
            Represents a variable (name/return type pair).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Type">
            <summary>
            Gets the type of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.IsConst">
            <summary>
            Gets whether this field is a constant (C#-like const).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.ConstantValue">
            <summary>
            If this field is a constant, retrieves the value.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.Name">
            <summary>
            Gets the name of the field.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsReadOnly">
            <summary>
            Gets whether this field is readonly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsVolatile">
            <summary>
            Gets whether this field is volatile.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IExplicitInterfaceImplementation">
            <summary>
            Represents an explicit interface implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IExplicitInterfaceImplementation.InterfaceType">
            <summary>
            Gets the type of the interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IExplicitInterfaceImplementation.MemberName">
            <summary>
            Gets the member name.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DomRegion.IsInside(System.Int32,System.Int32)">
            <remarks>
            Returns true, if the given coordinates (line, column) are in the region.
            This method assumes that for an unknown end the end line is == -1
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndLine">
            <value>
            if the end line is == -1 the end column is -1 too
            this stands for an unknwon end
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndColumn">
            <value>
            if the end column is == -1 the end line is -1 too
            this stands for an unknown end
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor">
            <summary>
            Traverses the DOM and resolves expressions.
            </summary>
            <remarks>
            The ResolveVisitor does two jobs at the same time: it tracks the resolve context (properties on CSharpResolver)
            and it resolves the expressions visited.
            To allow using the context tracking without having to resolve every expression in the file (e.g. when you want to resolve
            only a single node deep within the DOM), you can use the <see cref="T:ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator"/> interface.
            The navigator allows you to switch the between scanning mode and resolving mode.
            In scanning mode, the context is tracked (local variables registered etc.), but nodes are not resolved.
            While scanning, the navigator will get asked about every node that the resolve visitor is about to enter.
            This allows the navigator whether to keep scanning, whether switch to resolving mode, or whether to completely skip the
            subtree rooted at that node.
            
            In resolving mode, the context is tracked and nodes will be resolved.
            The resolve visitor may decide that it needs to resolve other nodes as well in order to resolve the current node.
            In this case, those nodes will be resolved automatically, without asking the navigator interface.
            For child nodes that are not essential to resolving, the resolve visitor will switch back to scanning mode (and thus will
            ask the navigator for further instructions).
            
            Moreover, there is the <c>ResolveAll</c> mode - it works similar to resolving mode, but will not switch back to scanning mode.
            The whole subtree will be resolved without notifying the navigator.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.DepthFirstAstVisitor`2">
            <summary>
            AST visitor with a default implementation that visits all node depth-first.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.#ctor(ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver,ICSharpCode.NRefactory.CSharp.ParsedFile,ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator)">
            <summary>
            Creates a new ResolveVisitor instance.
            </summary>
            <param name="resolver">
            The CSharpResolver, describing the initial resolve context.
            If you visit a whole CompilationUnit with the resolve visitor, you can simply pass
            <c>new CSharpResolver(typeResolveContext)</c> without setting up the context.
            If you only visit a subtree, you need to pass a CSharpResolver initialized to the context for that subtree.
            </param>
            <param name="parsedFile">
            Result of the <see cref="T:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor"/> for the file being passed. This is used for setting up the context on the resolver.
            You may pass <c>null</c> if you are only visiting a part of a method body and have already set up the context in the <paramref name="resolver"/>.
            </param>
            <param name="navigator">
            The navigator, which controls where the resolve visitor will switch between scanning mode and resolving mode.
            If you pass <c>null</c>, then <c>ResolveAll</c> mode will be used.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.GetResolveResult(ICSharpCode.NRefactory.CSharp.AstNode)">
            <summary>
            Gets the cached resolve result for the specified node.
            Returns <c>null</c> if no cached result was found (e.g. if the node was not visited; or if it was visited in scanning mode).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.MakeTypeReference(ICSharpCode.NRefactory.CSharp.AstType,ICSharpCode.NRefactory.CSharp.AstNode,System.Boolean)">
            <summary>
            Creates a type reference for the specified type node.
            If the type node is 'var', performs type inference on the initializer expression.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.TypeResolveContext">
            <summary>
            Gets the TypeResolveContext used by this ResolveVisitor.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.CancellationToken">
            <summary>
            Gets the CancellationToken used by this ResolveVisitor.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.MemberDeclaration.PrivateImplementationType">
            <summary>
            Only supported on members that can be declared in an interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ForStatement">
            <summary>
            for (Initializers; Condition; Iterators) EmbeddedStatement
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.ForStatement.Initializers">
            <summary>
            Gets the list of initializer statements.
            Note: this contains multiple statements for "for (a = 2, b = 1; a > b; a--)", but contains
            only a single statement for "for (int a = 2, b = 1; a > b; a--)" (a single VariableDeclarationStatement with two variables)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.NamespaceDeclaration">
            <summary>
            namespace Name { Members }
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.NamespaceDeclaration.FullName">
            <summary>
            Gets the full namespace name (including any parent namespaces)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Constraint">
            <summary>
            where TypeParameter : BaseTypes
            </summary>
            <remarks>
            new(), struct and class constraints are represented using a PrimitiveType "new", "struct" or "class"
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UndocumentedExpression">
            <summary>
            Represents undocumented expressions.
            </summary>
        </member>
        <member name="T:Mono.CSharp.FixedField">
            <summary>
            Fixed buffer implementation
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor">
            <summary>
            Produces type and member definitions from the DOM.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor.#ctor(ICSharpCode.NRefactory.TypeSystem.IProjectContent,System.String)">
            <summary>
            Creates a new TypeSystemConvertVisitor.
            </summary>
            <param name="pc">The parent project content (used as owner for the types being created).</param>
            <param name="fileName">The file name (used for DomRegions).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor.#ctor(ICSharpCode.NRefactory.CSharp.ParsedFile,ICSharpCode.NRefactory.CSharp.Resolver.UsingScope,ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition)">
            <summary>
            Creates a new TypeSystemConvertVisitor and initializes it with a given context.
            </summary>
            <param name="parsedFile">The parsed file to which members should be added.</param>
            <param name="currentUsingScope">The current using scope.</param>
            <param name="currentTypeDefinition">The current type definition.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor.AddDefaultMethodsToDelegate(ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IParameter})">
            <summary>
            Adds the 'Invoke', 'BeginInvoke', 'EndInvoke' methods, and a constructor, to the <paramref name="delegateType"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.IPatternAstVisitor`2">
            <summary>
            AST visitor that works for patterns.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Backreference">
            <summary>
            Matches the last entry in the specified named group.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.IdentifierExpressionBackreference">
            <summary>
            Matches identifier expressions that have the same identifier as the referenced variable/type definition/method definition.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UncheckedExpression">
            <summary>
            unchecked(Expression)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.PointerReferenceExpression">
            <summary>
            Target->MemberName
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.DefaultValueExpression">
            <summary>
            default(Type)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.MinimalResolveContext">
            <summary>
            Resolve context represents the minimal mscorlib required for evaluating constants.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IProjectContent">
            <summary>
            Mutable container of all classes in an assembly.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISynchronizedTypeResolveContext">
            <summary>
            Context representing the set of assemblies in which a type is being searched.
            Guarantees that the list of types available in the context is not changed until Dispose() is called.
            The Dispose() method must be called from the same thread that create the
            <c>ISynchronizedTypeResolveContext</c>.
            </summary>
            <remarks>
            A simple implementation might enter a ReaderWriterLock when the synchronized context
            is created, and releases the lock when Dispose() is called.
            However, implementations based on immutable data structures are also possible.
            
            Calling Synchronize() on an already synchronized context is possible, but has no effect.
            Only disposing the outermost ISynchronizedTypeResolveContext releases the lock.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.YieldBreakStatement">
            <summary>
            yield break;
            </summary>
        </member>
        <member name="M:Mono.CSharp.Const.Define">
            <summary>
              Defines the constant in the @parent
            </summary>
        </member>
        <member name="M:Mono.CSharp.Const.Emit">
            <summary>
             Emits the field value by evaluating the expression
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeSpecComparer.Unify.MayBecomeEqualGenericTypes(Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
            <summary>
              Check whether `a' and `b' may become equal generic types.
              The algorithm to do that is a little bit complicated.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Evaluator">
             <summary>
               Evaluator: provides an API to evaluate C# statements and
               expressions dynamically.
             </summary>
             <remarks>
               This class exposes static methods to evaluate expressions in the
               current program.
            
               To initialize the evaluator with a number of compiler
               options call the Init(string[]args) method with a set of
               command line options that the compiler recognizes.
            
               To interrupt execution of a statement, you can invoke the
               Evaluator.Interrupt method.
             </remarks>
        </member>
        <member name="F:Mono.CSharp.Evaluator.DescribeTypeExpressions">
            <summary>
              If true, turns type expressions into valid expressions
              and calls the describe method on it
            </summary>
        </member>
        <member name="M:Mono.CSharp.Evaluator.Interrupt">
            <summary>
              Interrupts the evaluation of an expression executing in Evaluate.
            </summary>
            <remarks>
              Use this method to interrupt long-running invocations.
            </remarks>
        </member>
        <member name="M:Mono.CSharp.Evaluator.Compile(System.String,Mono.CSharp.CompiledMethod@)">
             <summary>
               Compiles the input string and returns a delegate that represents the compiled code.
             </summary>
             <remarks>
            
               Compiles the input string as a C# expression or
               statement, unlike the Evaluate method, the
               resulting delegate can be invoked multiple times
               without incurring in the compilation overhead.
            
               If the return value of this function is null,
               this indicates that the parsing was complete.
               If the return value is a string it indicates
               that the input string was partial and that the
               invoking code should provide more code before
               the code can be successfully compiled.
            
               If you know that you will always get full expressions or
               statements and do not care about partial input, you can use
               the other Compile overload. 
            
               On success, in addition to returning null, the
               compiled parameter will be set to the delegate
               that can be invoked to execute the code.
            
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Evaluator.Compile(System.String)">
             <summary>
               Compiles the input string and returns a delegate that represents the compiled code.
             </summary>
             <remarks>
            
               Compiles the input string as a C# expression or
               statement, unlike the Evaluate method, the
               resulting delegate can be invoked multiple times
               without incurring in the compilation overhead.
            
               This method can only deal with fully formed input
               strings and does not provide a completion mechanism.
               If you must deal with partial input (for example for
               interactive use) use the other overload. 
            
               On success, a delegate is returned that can be used
               to invoke the method.
            
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Evaluator.Evaluate(System.String,System.Object@,System.Boolean@)">
             <summary>
               Evaluates and expression or statement and returns any result values.
             </summary>
             <remarks>
               Evaluates the input string as a C# expression or
               statement.  If the input string is an expression
               the result will be stored in the result variable
               and the result_set variable will be set to true.
            
               It is necessary to use the result/result_set
               pair to identify when a result was set (for
               example, execution of user-provided input can be
               an expression, a statement or others, and
               result_set would only be set if the input was an
               expression.
            
               If the return value of this function is null,
               this indicates that the parsing was complete.
               If the return value is a string, it indicates
               that the input is partial and that the user
               should provide an updated string.
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Evaluator.Run(System.String)">
            <summary>
              Executes the given expression or statement.
            </summary>
            <remarks>
               Executes the provided statement, returns true
               on success, false on parsing errors.  Exceptions
               might be thrown by the called code.
            </remarks>
        </member>
        <member name="M:Mono.CSharp.Evaluator.Evaluate(System.String)">
             <summary>
               Evaluates and expression or statement and returns the result.
             </summary>
             <remarks>
               Evaluates the input string as a C# expression or
               statement and returns the value.   
            
               This method will throw an exception if there is a syntax error,
               of if the provided input is not an expression but a statement.
             </remarks>
        </member>
        <member name="M:Mono.CSharp.Evaluator.LoadAssembly(System.String)">
            <summary>
               Loads the given assembly and exposes the API to the user.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Evaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
               Exposes the API of the given assembly to the Evaluator
            </summary>
        </member>
        <member name="P:Mono.CSharp.Evaluator.InteractiveBaseClass">
             <summary>
               The base class for the classes that host the user generated code
             </summary>
             <remarks>
            
               This is the base class that will host the code
               executed by the Evaluator.  By default
               this is the Mono.CSharp.InteractiveBase class
               which is useful for interactive use.
            
               By changing this property you can control the
               base class and the static members that are
               available to your evaluated code.
             </remarks>
        </member>
        <member name="T:Mono.CSharp.Evaluator.QuitValue">
            <summary>
              A sentinel value used to indicate that no value was
              was set by the compiled function.   This is used to
              differentiate between a function not returning a
              value and null.
            </summary>
        </member>
        <member name="T:Mono.CSharp.CompiledMethod">
            <summary>
              A delegate that can be used to invoke the
              compiled expression or statement.
            </summary>
            <remarks>
              Since the Compile methods will compile
              statements and expressions into the same
              delegate, you can tell if a value was returned
              by checking whether the returned value is of type
              NoValueSet.   
            </remarks>
        </member>
        <member name="T:Mono.CSharp.InteractiveBase">
            <summary>
              The default base class for every interaction line
            </summary>
            <remarks>
              The expressions and statements behave as if they were
              a static method of this class.   The InteractiveBase class
              contains a number of useful methods, but can be overwritten
              by setting the InteractiveBaseType property in the Evaluator
            </remarks>
        </member>
        <member name="F:Mono.CSharp.InteractiveBase.Output">
            <summary>
              Determines where the standard output of methods in this class will go. 
            </summary>
        </member>
        <member name="F:Mono.CSharp.InteractiveBase.Error">
            <summary>
              Determines where the standard error of methods in this class will go. 
            </summary>
        </member>
        <member name="F:Mono.CSharp.InteractiveBase.Prompt">
            <summary>
              The primary prompt used for interactive use.
            </summary>
        </member>
        <member name="F:Mono.CSharp.InteractiveBase.ContinuationPrompt">
            <summary>
              The secondary prompt used for interactive use (used when
              an expression is incomplete).
            </summary>
        </member>
        <member name="F:Mono.CSharp.InteractiveBase.QuitRequested">
            <summary>
              Used to signal that the user has invoked the  `quit' statement.
            </summary>
        </member>
        <member name="M:Mono.CSharp.InteractiveBase.ShowVars">
            <summary>
              Shows all the variables defined so far.
            </summary>
        </member>
        <member name="M:Mono.CSharp.InteractiveBase.ShowUsing">
            <summary>
              Displays the using statements in effect at this point. 
            </summary>
        </member>
        <member name="M:Mono.CSharp.InteractiveBase.Time(System.Action)">
            <summary>
              Times the execution of the given delegate
            </summary>
        </member>
        <member name="M:Mono.CSharp.InteractiveBase.LoadPackage(System.String)">
            <summary>
              Loads the assemblies from a package
            </summary>
            <remarks>
              Loads the assemblies from a package.   This is equivalent
              to passing the -pkg: command line flag to the C# compiler
              on the command line. 
            </remarks>
        </member>
        <member name="M:Mono.CSharp.InteractiveBase.LoadAssembly(System.String)">
            <summary>
              Loads the assembly
            </summary>
            <remarks>
              Loads the specified assembly and makes its types
              available to the evaluator.  This is equivalent
              to passing the -pkg: command line flag to the C#
              compiler on the command line.
            </remarks>
        </member>
        <member name="M:Mono.CSharp.InteractiveBase.Describe(System.Object)">
            <summary>
              Describes an object or a type.
            </summary>
            <remarks>
              This method will show a textual representation
              of the object's type.  If the object is a
              System.Type it renders the type directly,
              otherwise it renders the type returned by
              invoking GetType on the object.
            </remarks>
        </member>
        <member name="P:Mono.CSharp.InteractiveBase.help">
            <summary>
              Returns a list of available static methods. 
            </summary>
        </member>
        <member name="P:Mono.CSharp.InteractiveBase.quit">
            <summary>
              Indicates to the read-eval-print-loop that the interaction should be finished. 
            </summary>
        </member>
        <member name="T:Mono.CSharp.OptionalAssign">
             <summary>
                A class used to assign values if the source expression is not void
            
                Used by the interactive shell to allow it to call this code to set
                the return value for an invocation.
             </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.Error_AttributeEmitError(System.String)">
            <summary>
            This is rather hack. We report many emit attribute error with same error to be compatible with
            csc. But because csc has to report them this way because error came from ilasm we needn't.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.ResolveAttributeType">
            <summary>
              Tries to resolve the type of the attribute. Flags an error if it can't, and complain is true.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.GetValidTargets">
            <summary>
              Get a string containing a list of valid targets for the attribute 'attr'
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.GetIndexerAttributeValue">
            <summary>
            Returns custom name of indexer
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.GetConditionalAttributeValue">
            <summary>
            Returns condition of ConditionalAttribute
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.GetObsoleteAttribute">
            <summary>
            Creates the instance of ObsoleteAttribute from this attribute instance
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.GetClsCompliantAttributeValue">
            <summary>
            Returns value of CLSCompliantAttribute contructor parameter but because the method can be called
            before ApplyAttribute. We need to resolve the arguments.
            This situation occurs when class deps is differs from Emit order.  
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.IsSecurityActionValid">
            <summary>
            Tests permitted SecurityAction for assembly or other types
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attribute.ExtractSecurityPermissionSet(Mono.CSharp.MethodSpec,System.Collections.Generic.Dictionary{System.Security.Permissions.SecurityAction,System.Security.PermissionSet}@)">
            <summary>
            Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Mono.CSharp.Attribute.Emit(System.Collections.Generic.Dictionary{Mono.CSharp.Attribute,System.Collections.Generic.List{Mono.CSharp.Attribute}})">
            <summary>
            Emit attribute for Attributable symbol
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attributes.CheckTargets">
            <summary>
            Checks whether attribute target is valid for the current element
            </summary>
        </member>
        <member name="M:Mono.CSharp.Attributes.SearchMulti(Mono.CSharp.PredefinedAttribute)">
            <summary>
            Returns all attributes of type 't'. Use it when attribute is AllowMultiple = true
            </summary>
        </member>
        <member name="T:Mono.CSharp.AttributeTester">
            <summary>
            Helper class for attribute verification routine.
            </summary>
        </member>
        <member name="M:Mono.CSharp.AttributeTester.AreOverloadedMethodParamsClsCompliant(Mono.CSharp.AParametersCollection,Mono.CSharp.AParametersCollection)">
            <summary>
            Returns true if parameters of two compared methods are CLS-Compliant.
            It tests differing only in ref or out, or in array rank.
            </summary>
        </member>
        <member name="M:Mono.CSharp.AttributeTester.Report_ObsoleteMessage(System.ObsoleteAttribute,System.String,Mono.CSharp.Location,Mono.CSharp.Report)">
            <summary>
            Common method for Obsolete error/warning reporting.
            </summary>
        </member>
        <member name="T:Mono.CSharp.ExprClass">
            <remarks>
              The ExprClass class contains the is used to pass the 
              classification of an expression (value, variable, namespace,
              type, method group, property access, event access, indexer access,
              nothing).
            </remarks>
        </member>
        <member name="T:Mono.CSharp.ResolveFlags">
            <remarks>
              This is used to tell Resolve in which types of expressions we're
              interested.
            </remarks>
        </member>
        <member name="T:Mono.CSharp.TypeCast">
             <summary>
               This kind of cast is used to encapsulate the child
               whose type is child.Type into an expression that is
               reported to return "return_type".  This is used to encapsulate
               expressions which have compatible types, but need to be dealt
               at higher levels with.
            
               For example, a "byte" expression could be encapsulated in one
               of these as an "unsigned int".  The type for the expression
               would be "unsigned int".
            
             </summary>
        </member>
        <member name="T:Mono.CSharp.BoxedCast">
             <summary>
               This kind of cast is used to encapsulate Value Types in objects.
            
               The effect of it is to box the value type emitted by the previous
               operation.
             </summary>
        </member>
        <member name="T:Mono.CSharp.ConvCast">
             <summary>
               This is used to perform explicit numeric conversions.
            
               Explicit numeric conversions might trigger exceptions in a checked
               context, so they should generate the conv.ovf opcodes instead of
               conv opcodes.
             </summary>
        </member>
        <member name="T:Mono.CSharp.ClassCast">
            <summary>
              This kind of cast is used to encapsulate a child and cast it
              to the class requested
            </summary>
        </member>
        <member name="T:Mono.CSharp.SimpleName">
            <summary>
              SimpleName expressions are formed of a single word and only happen at the beginning 
              of a dotted-name.
            </summary>
        </member>
        <member name="T:Mono.CSharp.TypeExpression">
            <summary>
              Fully resolved Expression that already evaluated to a type
            </summary>
        </member>
        <member name="T:Mono.CSharp.MemberExpr">
            <summary>
              This class denotes an expression which evaluates to a member
              of a struct or a class.
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberExpr.Name">
            <summary>
              The name of this member.
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberExpr.IsInstance">
            <summary>
              Whether this is an instance member.
            </summary>
        </member>
        <member name="P:Mono.CSharp.MemberExpr.IsStatic">
            <summary>
              Whether this is a static member.
            </summary>
        </member>
        <member name="T:Mono.CSharp.MethodGroupExpr">
            <summary>
              MethodGroupExpr represents a group of method candidates which
              can be resolved to the best method overload
            </summary>
        </member>
        <member name="M:Mono.CSharp.MethodGroupExpr.OverloadResolve(Mono.CSharp.ResolveContext,Mono.CSharp.Arguments@,Mono.CSharp.OverloadResolver.IErrorHandler,Mono.CSharp.OverloadResolver.Restrictions)">
             <summary>
               Find the Applicable Function Members (7.4.2.1)
            
               me: Method Group expression with the members to select.
                   it might contain constructors or methods (or anything
                   that maps to a method).
            
               Arguments: ArrayList containing resolved Argument objects.
            
               loc: The location if we want an error to be reported, or a Null
                    location for "probing" purposes.
            
               Returns: The MethodBase (either a ConstructorInfo or a MethodInfo)
                        that is the best match of me on Arguments.
            
             </summary>
        </member>
        <member name="T:Mono.CSharp.FieldExpr">
            <summary>
              Fully resolved expression that evaluates to a Field
            </summary>
        </member>
        <member name="T:Mono.CSharp.PropertyExpr">
             <summary>
               Expression that evaluates to a Property.  The Assign class
               might set the `Value' expression if we are in an assignment.
            
               This is not an LValue because we need to re-write the expression, we
               can not take data from the stack and store it.  
             </summary>
        </member>
        <member name="T:Mono.CSharp.EventExpr">
            <summary>
              Fully resolved expression that evaluates to an Event
            </summary>
        </member>
        <member name="T:Mono.CSharp.VarExpr">
            
            Handles `var' contextual keyword; var becomes a keyword only
            if no type called var exists in a variable scope
            
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper">
            <summary>
            Static helper methods for reflection names.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.GetClass(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Type)">
            <summary>
            Retrieves a class.
            </summary>
            <returns>Returns the class; or null if it is not found.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.Type,ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="type">The type to be converted.</param>
            <param name="entity">The parent entity, used to fetch the ITypeParameter for generic types.</param>
            <returns>Returns the type reference.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String,System.Int32@)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.TypeCode)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="typeCode">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.GetTypeCode(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the type code for the specified type, or TypeCode.Empty if none of the other type codes matches.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String,ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Parses a reflection name into a type reference.
            </summary>
            <param name="reflectionTypeName">The reflection name of the type.</param>
            <param name="parentEntity">Parent entity, used to find the type parameters for open types.
            If no entity is provided, type parameters are converted to <see cref="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.UnknownType"/>.</param>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the reflection type name is invalid</exception>
            <returns>A type reference that represents the reflection name.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Null">
            <summary>
            A reflection class used to represent <c>null</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Dynamic">
            <summary>
            A reflection class used to represent <c>dynamic</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">
            <summary>
            Represents an error while parsing a reflection name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.Attributes">
            <summary>
            Gets the list of attributes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.DefaultValue">
            <summary>
            Gets the default value of optional parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.Region">
            <summary>
            Gets the code region where the parameter is defined.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsRef">
            <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOut">
            <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsParams">
            <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOptional">
            <summary>
            Gets whether this parameter is optional.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractType">
            <summary>
            Default implementation for IType interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleInterningProvider">
            <summary>
            Simple interning provider.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.TooManyPositionalArguments">
            <summary>
            Too many positional arguments (some could not be mapped to any parameter).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.NoParameterFoundForNamedArgument">
            <summary>
            A named argument could not be mapped to any parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.TypeInferenceFailed">
            <summary>
            Type inference failed for a generic method.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.WrongNumberOfTypeArguments">
            <summary>
            Type arguments were explicitly specified, but did not match the number of type parameters.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.ConstructedTypeDoesNotSatisfyConstraint">
            <summary>
            After substituting type parameters with the inferred types; a constructed type within the formal parameters
            does not satisfy its constraint.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.MissingArgumentForRequiredParameter">
            <summary>
            No argument was mapped to a non-optional parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.MultipleArgumentsForSingleParameter">
            <summary>
            Several arguments were mapped to a single (non-params-array) parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.ParameterPassingModeMismatch">
            <summary>
            'ref'/'out' passing mode doesn't match for at least 1 parameter
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.ArgumentTypeMismatch">
            <summary>
            Argument type cannot be converted to parameter type
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.AmbiguousMatch">
            <summary>
            There is no unique best overload
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.CSharpParser.ParseSnippet(System.IO.TextReader)">
            <summary>
            Parses a file snippet; guessing what the code snippet represents (compilation unit, type members, block, type reference, expression).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor">
            <summary>
            Inserts the parentheses into the AST that are needed to ensure the AST can be printed correctly.
            For example, if the AST contains
            BinaryOperatorExpresson(2, Mul, BinaryOperatorExpression(1, Add, 1))); printing that AST
            would incorrectly result in "2 * 1 + 1". By running InsertParenthesesVisitor, the necessary
            parentheses are inserted: "2 * (1 + 1)".
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor.GetPrecedence(ICSharpCode.NRefactory.CSharp.Expression)">
            <summary>
            Gets the row number in the C# 4.0 spec operator precedence table.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor.ParenthesizeIfRequired(ICSharpCode.NRefactory.CSharp.Expression,System.Int32)">
            <summary>
            Parenthesizes the expression if it does not have the minimum required precedence.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor.InsertParenthesesForReadability">
            <summary>
            Gets/Sets whether the visitor should insert parentheses to make the code better looking.
            If this property is false, it will insert parentheses only where strictly required by the language spec.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.FixedStatement">
            <summary>
            fixed (Type Variables) EmbeddedStatement
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Identifier.IsVerbatim">
            <summary>
            True if this is a verbatim identifier (starting with '@')
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.CheckedExpression">
            <summary>
            checked(Expression)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.CastExpression">
            <summary>
            (CastTo)Expression
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TypeReferenceExpression">
            <summary>
            Represents an AstType as an expression.
            This is used when calling a method on a primitive type: "int.Parse()"
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MethodGroupResolveResult">
            <summary>
            Represents a group of methods.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.MethodGroupResolveResult.ExtensionMethods">
            <summary>
            List of extension methods, used to avoid re-calculating it in ResolveInvocation() when it was already
            calculated by ResolveMemberAccess().
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver">
            <summary>
            Contains the main resolver logic.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.PushBlock">
            <summary>
            Opens a new scope for local variables.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.PopBlock">
            <summary>
            Closes the current scope for local variables; removing all variables in that scope.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.AddVariable(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,ICSharpCode.NRefactory.TypeSystem.IConstantValue)">
            <summary>
            Adds a new variable to the current block.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.Clone">
            <summary>
            Creates a copy of this CSharp resolver.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.HandleEnumComparison(ICSharpCode.NRefactory.CSharp.BinaryOperatorType,ICSharpCode.NRefactory.TypeSystem.IType,System.Boolean,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult)">
            <summary>
            Handle the case where an enum value is compared with another enum value
            bool operator op(E x, E y);
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.HandleEnumSubtraction(System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult)">
            <summary>
            Handle the case where an enum value is subtracted from another enum value
            U operator (E x, E y);
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.HandleEnumAdditionOrSubtraction(System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.CSharp.BinaryOperatorType,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult)">
            <summary>
            Handle the case where an integral value is added to or subtracted from an enum value,
            or when two enum values of the same type are combined using a bitwise operator.
            E operator +(E x, U y);
            E operator (E x, U y);
            E operator &amp;(E x, E y);
            E operator |(E x, E y);
            E operator ^(E x, E y);
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveAlias(System.String)">
            <summary>
            Looks up an alias (identifier in front of :: operator)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.GetExtensionMethods(ICSharpCode.NRefactory.TypeSystem.IType,System.String,System.Int32)">
            <summary>
            Gets the extension methods that are called 'name', and can be called with 'typeArgumentCount' explicit type arguments;
            and are applicable with a first argument type of 'targetType'.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveSizeOf(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Resolves 'sizeof(type)'.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveThisReference">
            <summary>
            Resolves 'this'.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveBaseReference">
            <summary>
            Resolves 'base'.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.Context">
            <summary>
            Gets the type resolve context used by the resolver.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.CheckForOverflow">
            <summary>
            Gets/Sets whether the current context is <c>checked</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.CurrentMember">
            <summary>
            Gets/Sets the current member definition that is used to look up identifiers as parameters
            or type parameters.
            </summary>
            <remarks>Don't forget to also set CurrentTypeDefinition when setting CurrentMember;
            setting one of the properties does not automatically set the other.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.CurrentTypeDefinition">
            <summary>
            Gets/Sets the current type definition that is used to look up identifiers as simple members.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.UsingScope">
            <summary>
            Gets/Sets the current using scope that is used to look up identifiers as class names.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.LocalVariables">
            <summary>
            Gets all currently visible local variables.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.ILiftedOperator">
            <summary>
            Implement this interface to give overload resolution a hint that the member represents a lifted operator,
            which is used in the tie-breaking rules.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution">
            <summary>
            C# overload resolution (C# 4.0 spec: 7.5).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.CalculateCandidate(ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate)">
            <summary>
            Calculates applicability etc. for the candidate.
            </summary>
            <returns>True if the calculation was successful, false if the candidate should be removed without reporting an error</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.BetterFunctionMember(ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate,ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate)">
            <summary>
            Returns 1 if c1 is better than c2; 2 if c2 is better than c1; or 0 if neither is better.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate.IsExpandedForm">
            <summary>
            Returns the normal form candidate, if this is an expanded candidate.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate.ArgumentToParameterMap">
            <summary>
            argument index -> parameter index; -1 for arguments that could not be mapped
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MethodTypeParameterSubstitution">
            <summary>
            Substitutes method type parameters with type arguments. Does not modify class type parameters.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.ILiftedOperator">
            <summary>
            Implement this interface to give overload resolution a hint that the member represents a lifted operator,
            which is used in the tie-breaking rules.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.Conversions">
            <summary>
            Contains logic that determines whether an implicit conversion exists between two types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.IdentityConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether there is an identity conversion from <paramref name="fromType"/> to <paramref name="toType"/>
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.BetterConversion(ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the better conversion (C# 4.0 spec, 7.5.3.3)
            </summary>
            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.BetterConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the better conversion (C# 4.0 spec, 7.5.3.4)
            </summary>
            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.BetterConversionTarget(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the better conversion target (C# 4.0 spec, 7.5.3.5)
            </summary>
            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OperatorDeclaration.GetOperatorType(System.String)">
            <summary>
            Gets the operator type from the method name, or null, if the method does not represent one of the known operator types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OperatorDeclaration.GetName(ICSharpCode.NRefactory.CSharp.OperatorType)">
            <summary>
            Gets the method name for the operator type. ("op_Addition", "op_Implicit", etc.)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OperatorDeclaration.GetToken(ICSharpCode.NRefactory.CSharp.OperatorType)">
            <summary>
            Gets the token for the operator type ("+", "implicit", etc.)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ThrowStatement">
            <summary>
            throw Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.LabelStatement">
            <summary>
            Label:
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.EmptyStatement">
            <summary>
            ;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.DelegateDeclaration">
            <summary>
            delegate ReturnType Name&lt;TypeParameters&gt;(Parameters) where Constraints;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UnaryOperatorExpression">
            <summary>
            Operator Expression
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Not">
            <summary>Logical not (!a)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.BitNot">
            <summary>Bitwise not (~a)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Minus">
            <summary>Unary minus (-a)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Plus">
            <summary>Unary plus (+a)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Increment">
            <summary>Pre increment (++a)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Decrement">
            <summary>Pre decrement (--a)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.PostIncrement">
            <summary>Post increment (a++)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.PostDecrement">
            <summary>Post decrement (a--)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Dereference">
            <summary>Dereferencing (*a)</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.AddressOf" -->
        <member name="T:ICSharpCode.NRefactory.CSharp.FixedVariableInitializer">
            <summary>
            Name [ CountExpression ]
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeManager.CSharpName(Mono.CSharp.TypeSpec)">
            <summary>
              Returns the C# name of a type if possible, or the full type name otherwise
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeManager.HasElementType(Mono.CSharp.TypeSpec)">
            <summary>
            This method is not implemented by MS runtime for dynamic types
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeManager.VerifyUnmanaged(Mono.CSharp.ModuleContainer,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Utility function that can be used to probe whether a type
              is managed or not.  
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeManager.IsInstantiationOfSameGenericType(Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
            <summary>
              Check whether `type' and `parent' are both instantiations of the same
              generic type.  Note that we do not check the type parameters here.
            </summary>
        </member>
        <member name="M:Mono.CSharp.ConstantFold.BinaryFold(Mono.CSharp.ResolveContext,Mono.CSharp.Binary.Operator,Mono.CSharp.Constant,Mono.CSharp.Constant,Mono.CSharp.Location)">
             <summary>
               Constant expression folder for binary operations.
            
               Returns null if the expression can not be folded.
             </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType">
            <summary>
            Represents the intersection of several types.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.NodeListResolveVisitorNavigator">
            <summary>
            <see cref="T:ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator"/> implementation that resolves a list of nodes.
            We will skip all nodes which are not the target nodes or ancestors of the target nodes.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator">
            <summary>
            Allows controlling which nodes are resolved by the resolve visitor.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.NodeListResolveVisitorNavigator.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.AstNode})">
            <summary>
            Creates a new NodeListResolveVisitorNavigator that resolves the specified nodes.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.NodeListResolveVisitorNavigator.Scan(ICSharpCode.NRefactory.CSharp.AstNode)">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UnsafeStatement">
            <summary>
            unsafe { Body }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UsingAliasDeclaration">
            <summary>
            using Alias = Import;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Match">
            <summary>
            Represents the result of a pattern matching operation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AssignmentExpression">
            <summary>
            Left Operator= Right
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Assign">
            <summary>left = right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Add">
            <summary>left += right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Subtract">
            <summary>left -= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Multiply">
            <summary>left *= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Divide">
            <summary>left /= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Modulus">
            <summary>left %= right</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.ShiftLeft" -->
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.ShiftRight">
            <summary>left >>= right</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.BitwiseAnd" -->
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.BitwiseOr">
            <summary>left |= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.ExclusiveOr">
            <summary>left ^= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Any">
            <summary>Any operator (for pattern matching)</summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus">
            <summary>
            Represents the definite assignment status of a variable at a specific location.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.PotentiallyAssigned">
            <summary>
            The variable might be assigned or unassigned.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.DefinitelyAssigned">
            <summary>
            The variable is definitely assigned.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.AssignedAfterTrueExpression">
            <summary>
            The variable is definitely assigned iff the expression results in the value 'true'.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.AssignedAfterFalseExpression">
            <summary>
            The variable is definitely assigned iff the expression results in the value 'false'.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.CodeUnreachable">
            <summary>
            The code is unreachable.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis">
            <summary>
            Implements the C# definite assignment analysis (C# 4.0 Spec: 5.3 Definite assignment)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.SetAnalyzedRange(ICSharpCode.NRefactory.CSharp.Statement,ICSharpCode.NRefactory.CSharp.Statement)">
            <summary>
            Sets the range of statements to be analyzed.
            This method can be used to restrict the analysis to only a part of the method.
            Only the control flow paths that are fully contained within the selected part will be analyzed.
            </summary>
            <remarks>Both 'start' and 'end' are inclusive.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.ExportGraph">
            <summary>
            Exports the CFG. This method is intended to help debugging issues related to definite assignment.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.EvaluateConstant(ICSharpCode.NRefactory.CSharp.Expression)">
            <summary>
            Evaluates an expression.
            </summary>
            <returns>The constant value of the expression; or null if the expression is not a constant.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.EvaluateCondition(ICSharpCode.NRefactory.CSharp.Expression)">
            <summary>
            Evaluates an expression.
            </summary>
            <returns>The value of the constant boolean expression; or null if the value is not a constant boolean expression.</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.UnassignedVariableUses">
            <summary>
            Gets the unassigned usages of the previously analyzed variable.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNode">
            <summary>
            Represents a node in the control flow graph of a C# method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder">
            <summary>
            Constructs the control flow graph for C# statements.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.EvaluateConstant(ICSharpCode.NRefactory.CSharp.Expression)">
            <summary>
            Evaluates an expression.
            </summary>
            <returns>The constant value of the expression; or null if the expression is not a constant.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.EvaluateCondition(ICSharpCode.NRefactory.CSharp.Expression)">
            <summary>
            Evaluates an expression.
            </summary>
            <returns>The value of the constant boolean expression; or null if the value is not a constant boolean expression.</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.EvaluateOnlyPrimitiveConstants">
            <summary>
            Gets/Sets whether to handle only primitive expressions as constants (no complex expressions like "a + b").
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.NodeCreationVisitor.CreateConnectedEndNode(ICSharpCode.NRefactory.CSharp.Statement,ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNode)">
            <summary>
            Creates an end node for <c>stmt</c> and connects <c>from</c> with the new node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AnonymousTypeCreateExpression">
            <summary>
            new { [ExpressionList] }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ArrayCreateExpression">
            <summary>
            new Type[Dimensions]
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.ArrayCreateExpression.AdditionalArraySpecifiers">
            <summary>
            Gets additional array ranks (those without size info).
            Empty for "new int[5,1]"; will contain a single element for "new int[5][]".
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ArraySpecifier">
            <summary>
            [,,,]
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition">
            <summary>
            Represents a class, enum, interface, struct, delegate or VB module.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.GetCompoundClass">
            <summary>
            If this is a partial class, gets the compound class containing information from all parts.
            If this is not a partial class, a reference to this class is returned.
            
            This method will always retrieve the latest version of the class, which might not contain this class as a part.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.GetParts">
            <summary>
            If this is a compound class (combination of class parts), this method retrieves all individual class parts.
            Otherwise, a list containing <c>this</c> is returned.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.Members">
            <summary>
            Gets all members declared in this class. This is the union of Fields,Properties,Methods and Events.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.HasExtensionMethods">
            <summary>
            Gets whether this type contains extension methods.
            </summary>
            <remarks>This property is used to speed up the search for extension methods.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleProjectContent">
            <summary>
            Simple <see cref="T:ICSharpCode.NRefactory.TypeSystem.IProjectContent"/> implementation that stores the list of classes/namespaces.
            Synchronization is implemented using a <see cref="T:System.Threading.ReaderWriterLockSlim"/>.
            </summary>
            <remarks>
            Compared with <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage"/>, this class adds support for the IProjectContent interface,
            for partial classes, and for multi-threading.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleProjectContent.UpdateProjectContent(System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.IAttribute},System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.IAttribute})">
            <summary>
            Removes oldTypes from the project, adds newTypes.
            Removes oldAssemblyAttributes, adds newAssemblyAttributes.
            </summary>
            <remarks>
            The update is done inside a write lock; when other threads access this project content
            from within a <c>using (Synchronize())</c> block, they will not see intermediate (inconsistent) state.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleProjectContent.AssemblyAttributes">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleConstantValue">
            <summary>
            A simple constant value that is independent of the resolve context.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IConstantValue.GetValueType(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets the type of the constant value.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IConstantValue.GetValue(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets the .NET value of the constant value.
            Possible return values are:
            - null
            - primitive integers
            - float/double
            - bool
            - string
            - IType (for typeof-expressions)
            and arrays of these values. Enum values are returned using the underlying primitive integer.
            
            TODO: how do we represent errors (value not available?)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/> interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IMethod">
            <summary>
            Represents a method, constructor, destructor or operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.ReturnTypeAttributes">
            <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMethod.#ctor(ICSharpCode.NRefactory.TypeSystem.IMethod)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.TypeInferenceAlgorithm.CSharp4">
            <summary>
            C# 4.0 type inference.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.TypeInferenceAlgorithm.Improved">
            <summary>
            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.TypeInferenceAlgorithm.ImprovedReturnAllResults">
            <summary>
            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing;
            uses <see cref="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType"/> to report all results (in case of ambiguities).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference">
            <summary>
            Implements C# 4.0 Type Inference (7.5.2).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.InferTypeArgumentsFromBounds(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.ITypeParameter},ICSharpCode.NRefactory.TypeSystem.IType,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean@)">
            <summary>
            Infers type arguments for the <paramref name="typeParameters"/> occurring in the <paramref name="targetType"/>
            so that the resulting type (after substition) satisfies the given bounds.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.MakeExactInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Make exact inference from U to V.
            C# 4.0 spec: 7.5.2.8 Exact inferences
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.MakeLowerBoundInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Make lower bound inference from U to V.
            C# 4.0 spec: 7.5.2.9 Lower-bound inferences
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.MakeUpperBoundInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Make upper bound inference from U to V.
            C# 4.0 spec: 7.5.2.10 Upper-bound inferences
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.GetBestCommonType(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult},System.Boolean@)">
            <summary>
            Gets the best common type (C# 4.0 spec: 7.5.2.14) of a set of expressions.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.FindTypeInBounds(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
            <summary>
            Finds a type that satisfies the given lower and upper bounds.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.Algorithm">
            <summary>
            Gets/Sets the type inference algorithm used.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter">
            <summary>
            Type parameter of a generic class/method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.OwnerType">
            <summary>
            Get the type of this type parameter's owner.
            </summary>
            <returns>EntityType.TypeDefinition or EntityType.Method</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Index">
            <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Attributes">
            <summary>
            Gets the list of attributes declared on this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Constraints">
            <summary>
            Gets the constraints of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint">
            <summary>
            Gets if the type parameter has the 'new()' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasReferenceTypeConstraint">
            <summary>
            Gets if the type parameter has the 'class' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasValueTypeConstraint">
            <summary>
            Gets if the type parameter has the 'struct' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Variance">
            <summary>
            Gets the variance of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.BoundTo">
            <summary>
            Gets the type that was used to bind this type parameter.
            This property returns null for generic methods/classes, it
            is non-null only for constructed versions of generic methods.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.UnboundTypeParameter">
            <summary>
            If this type parameter was bound, returns the unbound version of it.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Region">
            <summary>
            Gets the region where the type parameter is defined.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode">
            <summary>
            Represents the operation mode of the resolve visitor.
            </summary>
            <seealso cref="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.Scan">
            <summary>
            Scan into the children of the current node, without resolving the current node.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.Skip">
            <summary>
            Skip the current node - do not scan into it; do not resolve it.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.Resolve">
            <summary>
            Resolve the current node; but only scan subnodes which are not required for resolving the current node.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.ResolveAll">
            <summary>
            Resolves all nodes in the current subtree.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ReturnStatement">
            <summary>
            return Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.IsExpression">
            <summary>
            Expression is Type
            </summary>
        </member>
        <member name="T:Mono.CSharp.SourceFile">
            <summary>
              This is one single source file.
            </summary>
            <remarks>
              This is intentionally a class and not a struct since we need
              to pass this by reference.
            </remarks>
        </member>
        <member name="T:Mono.CSharp.Location">
             <summary>
               Keeps track of the location in the program
             </summary>
            
             <remarks>
               This uses a compact representation and a couple of auxiliary
               structures to keep track of tokens to (file,line and column) 
               mappings. The usage of the bits is:
               
                 - 16 bits for "checkpoint" which is a mixed concept of
                   file and "line segment"
                 - 8 bits for line delta (offset) from the line segment
                 - 8 bits for column number.
            
               http://lists.ximian.com/pipermail/mono-devel-list/2004-December/009508.html
             </remarks>
        </member>
        <member name="P:Mono.CSharp.Location.IsNull">
            <summary>
              Whether the Location is Null
            </summary>
        </member>
        <member name="F:Mono.CSharp.Report.WarningsAreErrors">
            <summary>  
              Whether warnings should be considered errors
            </summary>
        </member>
        <member name="F:Mono.CSharp.Report.extra_information">
            <summary>
            List of symbols related to reported error/warning. You have to fill it before error/warning is reported.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Report.SymbolRelatedToPreviousError(Mono.CSharp.Location,System.String)">
            <summary>
            In most error cases is very useful to have information about symbol that caused the error.
            Call this method before you call Report.Error when it makes sense.
            </summary>
        </member>
        <member name="T:Mono.CSharp.WarningRegions">
            <summary>
            Handles #pragma warning
            </summary>
        </member>
        <member name="T:Mono.CSharp.ParameterBase">
            <summary>
              Abstract Base class for parameters of a method.
            </summary>
        </member>
        <member name="T:Mono.CSharp.ReturnParameter">
            <summary>
            Class for applying custom attributes on the return type
            </summary>
        </member>
        <member name="P:Mono.CSharp.ReturnParameter.ValidAttributeTargets">
            <summary>
            Is never called
            </summary>
        </member>
        <member name="T:Mono.CSharp.ParametersCompiled">
            <summary>
              Represents the methods parameters
            </summary>
        </member>
        <member name="T:Mono.CSharp.EventProperty">
            <summary>
            For case when event is declared like property (with add and remove accessors).
            </summary>
        </member>
        <member name="T:Mono.CSharp.EventField">
            <summary>
            Event is declared like field.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent">
            <summary>
            Represents a specialized IEvent (e.g. after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference">
            <summary>
            Type Reference used when the fully qualified type name is known.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UnknownMemberResolveResult">
            <summary>
            Represents an unknown member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.UnknownMemberResolveResult.TargetType">
            <summary>
            The type on which the method is being called.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UnknownMethodResolveResult">
            <summary>
            Represents an unknown method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UnknownIdentifierResolveResult">
            <summary>
            Represents an unknown identifier.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.SimpleTypeOrNamespaceReference">
            <summary>
            Represents a simple C# name. (a single non-qualified identifier with an optional list of type arguments)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.SimpleTypeOrNamespaceReference.AddSuffix(System.String)">
            <summary>
            Adds a suffix to the identifier.
            Does not modify the existing type reference, but returns a new one.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ExpressionStatement">
            <summary>
            Expression;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.BreakStatement">
            <summary>
            break;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.TypeDeclaration">
            <summary>
            class Name&lt;TypeParameters&gt; : BaseTypes where Constraints;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.StackAllocExpression">
            <summary>
            stackalloc Type[Count]
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.AsExpression">
            <summary>
            Expression as TypeReference
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.ExtensionMethods">
            <summary>
            Contains extension methods for use within NRefactory.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod">
            <summary>
            Represents a specialized IMethod (e.g. after type substitution).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod.SubstituteTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Performs type substitution in parameter types and in the return type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultExplicitInterfaceImplementation">
            <summary>
            Default implementation for IExplicitInterfaceImplementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAttribute">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IAttribute"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ArrayType">
            <summary>
            Represents an array type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup">
            <summary>
            Implementation of member lookup (C# 4.0 spec, 7.4).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup.IsInvocable(ICSharpCode.NRefactory.TypeSystem.IMember,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Gets whether the member is considered to be invocable.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup.IsAccessible(ICSharpCode.NRefactory.TypeSystem.IEntity,System.Boolean)">
            <summary>
            Gets whether <paramref name="entity"/> is accessible in the current class.
            </summary>
            <param name="entity">The entity to test</param>
            <param name="allowProtectedAccess">Whether protected access is allowed.
            True if the type of the reference is derived from the current class.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup.Lookup(ICSharpCode.NRefactory.TypeSystem.IType,System.String,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean)">
            <summary>
            Performs a member lookup.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.IfElseStatement">
            <summary>
            if (Condition) TrueStatement else FalseStatement
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ForeachStatement">
            <summary>
            foreach (Type VariableName in InExpression) EmbeddedStatement
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ParenthesizedExpression">
            <summary>
            ( Expression )
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ConditionalExpression">
            <summary>
            Condition ? TrueExpression : FalseExpression
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.BinaryOperatorExpression">
            <summary>
            Left Operator Right
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.BitwiseAnd">
            <summary>left &amp; right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.BitwiseOr">
            <summary>left | right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ConditionalAnd">
            <summary>left &amp;&amp; right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ConditionalOr">
            <summary>left || right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ExclusiveOr">
            <summary>left ^ right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.GreaterThan">
            <summary>left &gt; right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.GreaterThanOrEqual">
            <summary>left &gt;= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Equality">
            <summary>left == right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.InEquality">
            <summary>left != right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.LessThan">
            <summary>left &lt; right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.LessThanOrEqual">
            <summary>left &lt;= right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Add">
            <summary>left + right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Subtract">
            <summary>left - right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Multiply">
            <summary>left * right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Divide">
            <summary>left / right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Modulus">
            <summary>left % right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ShiftLeft">
            <summary>left &lt;&lt; right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ShiftRight">
            <summary>left &gt;&gt; right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.NullCoalescing">
            <summary>left ?? right</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Any">
            <summary>
            Any binary operator (used in pattern matching)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.None">
            <summary>
            Unknown node type
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.StartNode">
            <summary>
            Node in front of a statement
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.BetweenStatements">
            <summary>
            Node between two statements
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.EndNode">
            <summary>
            Node at the end of a statement list
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.LoopCondition">
            <summary>
            Node representing the position before evaluating the condition of a loop.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdge.IsLeavingTryFinally">
            <summary>
            Gets whether this control flow edge is leaving any try-finally statements.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdge.TryFinallyStatements">
            <summary>
            Gets the try-finally statements that this control flow edge is leaving.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.Normal">
            <summary>
            Regular control flow.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.ConditionTrue">
            <summary>
            Conditional control flow (edge taken if condition is true)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.ConditionFalse">
            <summary>
            Conditional control flow (edge taken if condition is false)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.Jump">
            <summary>
            A jump statement (goto, goto case, break or continue)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.EmptyExpression">
            <summary>
            Type&lt;[EMPTY]&gt;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.TreeTraversal">
            <summary>
            Static helper methods for traversing trees.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BusyManager">
            <summary>
            This class is used to prevent stack overflows by representing a 'busy' flag
            that prevents reentrance when another call is running.
            However, using a simple 'bool busy' is not thread-safe, so we use a
            thread-static BusyManager.
            </summary>
        </member>
        <member name="M:Mono.CSharp.IntConstant.TryImplicitIntConversion(Mono.CSharp.TypeSpec)">
            <summary>
              Attempts to perform an implicit constant conversion of the IntConstant
              into a different data type using casts (See Implicit Constant
              Expression Conversions)
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ImplicitNumericConversion(Mono.CSharp.Expression,Mono.CSharp.TypeSpec)">
             <summary>
               Implicit Numeric Conversions.
            
               expr is the expression to convert, returns a new expression of type
               target_type or null if an implicit conversion is not possible.
             </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.FindMostEncompassedType(System.Collections.Generic.IEnumerable{Mono.CSharp.TypeSpec})">
            <summary>
             Finds "most encompassed type" according to the spec (13.4.2)
             amongst the methods in the MethodGroupExpr
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.FindMostSpecificTarget(System.Collections.Generic.IList{Mono.CSharp.MethodSpec},Mono.CSharp.TypeSpec,System.Boolean)">
            <summary>
             Finds the most specific target Tx according to section 13.4.4
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ImplicitUserConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
             User-defined Implicit conversions
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitUserConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
             User-defined Explicit conversions
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ImplicitConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Converts implicitly the resolved expression `expr' into the
              `target_type'.  It returns a new expression that can be used
              in a context that expects a `target_type'.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ImplicitConversionStandard(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
             <summary>
               Attempts to apply the `Standard Implicit
               Conversion' rules to the expression `expr' into
               the `target_type'.  It returns a new expression
               that can be used in a context that expects a
               `target_type'.
            
               This is different from `ImplicitConversion' in that the
               user defined implicit conversions are excluded.
             </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ImplicitConversionRequired(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Attempts to implicitly convert `source' into `target_type', using
              ImplicitConversion.  If there is no implicit conversion, then
              an error is signaled
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitNumericConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec)">
             <summary>
               Performs the explicit numeric conversions
            
             There are a few conversions that are not part of the C# standard,
             they were interim hacks in the C# compiler that were supposed to
             become explicit operators in the UIntPtr class and IntPtr class,
             but for historical reasons it did not happen, so the C# compiler
             ended up with these special hacks.
            
             See bug 59800 for details.
            
             The conversion are:
               UIntPtr->SByte
               UIntPtr->Int16
               UIntPtr->Int32
               IntPtr->UInt64
               UInt64->IntPtr
               SByte->UIntPtr
               Int16->UIntPtr
            
             </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitReferenceConversionExists(Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
            <summary>
             Returns whether an explicit reference conversion can be performed
             from source_type to target_type
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitReferenceConversion(Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
            <summary>
              Implements Explicit Reference conversions
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitConversionCore(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Performs an explicit conversion of the expression `expr' whose
              type is expr.Type to `target_type'.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitConversionStandard(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Same as ExplicitConversion, only it doesn't include user defined conversions
            </summary>
        </member>
        <member name="M:Mono.CSharp.Convert.ExplicitConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
              Performs an explicit conversion of the expression `expr' whose
              type is expr.Type to `target_type'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes">
            <summary>
            Contains static implementations of well-known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.UnknownType">
            <summary>
            Gets the type representing resolve errors.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.Null">
            <summary>
            The null type is used as type of the null literal. It is a reference type without any members; and it is a subtype of all reference types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.Dynamic">
            <summary>
            Type representing the C# 'dynamic' type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes.UnknownTypeImpl">
            <summary>
            Type representing resolve errors.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes.NullType">
            <summary>
            Type of the 'null' literal.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes.DynamicType">
            <summary>
            Type representing the C# 'dynamic' type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.NullableType">
            <summary>
            Static helper methods for working with nullable types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.IsNullable(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the specified type is a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.GetUnderlyingType(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Returns the element type, if <paramref name="type"/> is a nullable type.
            Otherwise, returns the type itself.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.ITypeReference)">
            <summary>
            Creates a nullable type reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.VoidTypeDefinition">
            <summary>
            Special type definition for 'void'.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition.RemoveDuplicates``1(System.Collections.Generic.List{``0})">
            <summary>
            Removes duplicate members from the list.
            This is necessary when the same member can be inherited twice due to multiple inheritance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition.AddDefaultConstructorIfRequired">
            <summary>
            Gets whether a default constructor should be added to this class if it is required.
            Such automatic default constructors will not appear in ITypeDefinition.Methods, but will be present
            in IType.GetMethods().
            </summary>
            <remarks>This way of creating the default constructor is necessary because
            we cannot create it directly in the IClass - we need to consider partial classes.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAccessor">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IAccessor"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IAccessor">
            <summary>
            Represents an accessor (property getter/setter; or event add/remove/invoke).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.Region">
            <summary>
            Gets the accessor region.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.Attributes">
            <summary>
            Gets the attributes defined on this accessor.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.ReturnTypeAttributes">
            <summary>
            Gets the attributes defined on the return type of the accessor. (e.g. [return: MarshalAs(...)])
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.Accessibility">
            <summary>
            Gets the accessibility of this accessor.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAccessor.GetFromAccessibility(ICSharpCode.NRefactory.TypeSystem.Accessibility)">
            <summary>
            Gets the default accessor with the specified accessibility (and without attributes or region).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ErrorResolveResult">
            <summary>
            Represents a resolve error.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.AliasNamespaceReference">
            <summary>
            Looks up an alias (identifier in front of :: operator).
            </summary>
            <remarks>
            The member lookup performed by the :: operator is handled
            by <see cref="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberTypeOrNamespaceReference"/>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.Modifiers.Any">
            <summary>
            Special value used to match any modifiers during pattern matching.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.AnyNode">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Choice">
            <summary>
            Matches one of several alternatives.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.AttributeTypeReference">
            <summary>
            Type reference used within an attribute.
            Looks up both 'withoutSuffix' and 'withSuffix' and returns the type that exists.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.QueryContinuationClause">
            <summary>
            Represents a query continuation.
            "(from .. select ..) into Identifier" or "(from .. group .. by ..) into Identifier"
            Note that "join .. into .." is not a query continuation!
            
            This is always the first(!!) clause in a query expression.
            The tree for "from a in b select c into d select e" looks like this:
            new QueryExpression {
            	new QueryContinuationClause {
            		PrecedingQuery = new QueryExpression {
            			new QueryFromClause(a in b),
            			new QuerySelectClause(c)
            		},
            		Identifier = d
            	},
            	new QuerySelectClause(e)
            }
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.QueryJoinClause">
            <summary>
            Represents a join or group join clause.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.LambdaExpression">
            <summary>
            Parameters => Body
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BitVector16">
            <summary>
            Holds 16 boolean values.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Driver">
            <summary>
               The compiler driver.
            </summary>
        </member>
        <member name="T:Mono.CSharp.UnaryMutator">
             <summary>
               Unary Mutator expressions (pre and post ++ and --)
             </summary>
            
             <remarks>
               UnaryMutator implements ++ and -- expressions.   It derives from
               ExpressionStatement becuase the pre/post increment/decrement
               operators can be used in a statement context.
            
             FIXME: Idea, we could split this up in two classes, one simpler
             for the common case, and one with the extra fields for more complex
             classes (indexers require temporary access;  overloaded require method)
            
             </remarks>
        </member>
        <member name="T:Mono.CSharp.Probe">
             <summary>
               Base class for the `Is' and `As' classes. 
             </summary>
            
             <remarks>
               FIXME: Split this in two, and we get to save the `Operator' Oper
               size. 
             </remarks>
        </member>
        <member name="T:Mono.CSharp.Is">
            <summary>
              Implementation of the `is' operator.
            </summary>
        </member>
        <member name="T:Mono.CSharp.As">
            <summary>
              Implementation of the `as' operator.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Binary">
            <summary>
              Binary operators
            </summary>
        </member>
        <member name="M:Mono.CSharp.Binary.OperName(Mono.CSharp.Binary.Operator)">
            <summary>
              Returns a stringified representation of the Operator
            </summary>
        </member>
        <member name="M:Mono.CSharp.Binary.EmitBranchable(Mono.CSharp.EmitContext,System.Reflection.Emit.Label,System.Boolean)">
             <remarks>
               EmitBranchable is called from Statement.EmitBoolExpression in the
               context of a conditional bool expression.  This function will return
               false if it is was possible to use EmitBranchable, or true if it was.
            
               The expression's code is generated, and we will generate a branch to `target'
               if the resulting expression value is equal to isTrue
             </remarks>
        </member>
        <member name="T:Mono.CSharp.Conditional">
            <summary>
              Implements the ternary conditional operator (?:)
            </summary>
        </member>
        <member name="T:Mono.CSharp.ParameterReference">
            <summary>
              This represents a reference to a parameter in the intermediate
              representation.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Invocation">
            <summary>
              Invocation of methods or delegates.
            </summary>
        </member>
        <member name="M:Mono.CSharp.Invocation.EmitCall(Mono.CSharp.EmitContext,Mono.CSharp.Expression,Mono.CSharp.MethodSpec,Mono.CSharp.Arguments,Mono.CSharp.Location)">
             <remarks>
               is_base tells whether we want to force the use of the `call'
               opcode instead of using callvirt.  Call is required to call
               a specific method, while callvirt will always use the most
               recent method in the vtable.
            
               is_static tells whether this is an invocation on a static method
            
               instance_expr is an expression that represents the instance
               it must be non-null if is_static is false.
            
               method is the method to invoke.
            
               Arguments is the list of arguments to pass to the method or constructor.
             </remarks>
        </member>
        <member name="M:Mono.CSharp.New.Constantify(Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
            <summary>
            Converts complex core type syntax like 'new int ()' to simple constant
            </summary>
        </member>
        <member name="T:Mono.CSharp.ArrayCreation">
             <summary>
               14.5.10.2: Represents an array creation expression.
             </summary>
            
             <remarks>
               There are two possible scenarios here: one is an array creation
               expression that specifies the dimensions and optionally the
               initialization data and the other which does not need dimensions
               specified but where initialization data is mandatory.
             </remarks>
        </member>
        <member name="T:Mono.CSharp.This">
            <summary>
              Represents the `this' construct
            </summary>
        </member>
        <member name="T:Mono.CSharp.ArglistAccess">
            <summary>
              Represents the `__arglist' construct
            </summary>
        </member>
        <member name="T:Mono.CSharp.Arglist">
            <summary>
              Represents the `__arglist (....)' construct
            </summary>
        </member>
        <member name="T:Mono.CSharp.TypeOf">
            <summary>
              Implements the typeof operator
            </summary>
        </member>
        <member name="T:Mono.CSharp.SizeOf">
            <summary>
              Implements the sizeof expression
            </summary>
        </member>
        <member name="T:Mono.CSharp.QualifiedAliasMember">
            <summary>
              Implements the qualified-alias-member (::) expression.
            </summary>
        </member>
        <member name="T:Mono.CSharp.MemberAccess">
            <summary>
              Implements the member access expression
            </summary>
        </member>
        <member name="T:Mono.CSharp.CheckedExpr">
            <summary>
              Implements checked expressions
            </summary>
        </member>
        <member name="T:Mono.CSharp.UnCheckedExpr">
            <summary>
              Implements the unchecked expression
            </summary>
        </member>
        <member name="T:Mono.CSharp.ElementAccess">
             <summary>
               An Element Access expression.
            
               During semantic analysis these are transformed into 
               IndexerAccess, ArrayAccess or a PointerArithmetic.
             </summary>
        </member>
        <member name="T:Mono.CSharp.ArrayAccess">
            <summary>
              Implements array access 
            </summary>
        </member>
        <member name="T:Mono.CSharp.EmptyExpression">
             <summary>
               This class exists solely to pass the Type around and to be a dummy
               that can be passed to the conversion functions (this is used by
               foreach implementation to typecast the object return value from
               get_Current into the proper type.  All code has been generated and
               we only care about the side effect conversions to be performed
            
               This is also now used as a placeholder where a no-action expression
               is needed (the `New' class).
             </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.NamespaceResolveResult">
            <summary>
            Represents that an expression resolved to a namespace.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.OutputVisitor">
            <summary>
            Outputs the AST.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.OutputVisitor.lastWritten">
            <summary>
            Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteSpecials(ICSharpCode.NRefactory.CSharp.AstNode,ICSharpCode.NRefactory.CSharp.AstNode)">
            <summary>
            Writes all specials from start to end (exclusive). Does not touch the positionStack.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteSpecialsUpToRole(ICSharpCode.NRefactory.Role)">
            <summary>
            Writes all specials between the current position (in the positionStack) and the next
            node with the specified role. Advances the current position.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteSpecialsUpToNode(ICSharpCode.NRefactory.CSharp.AstNode)">
            <summary>
            Writes all specials between the current position (in the positionStack) and the specified node.
            Advances the current position.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.Comma(ICSharpCode.NRefactory.CSharp.AstNode,System.Boolean)">
            <summary>
            Writes a comma.
            </summary>
            <param name="nextNode">The next node after the comma.</param>
            <param name="noSpacesAfterComma">When set prevents printing a space after comma.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteKeyword(System.String,ICSharpCode.NRefactory.Role{ICSharpCode.NRefactory.CSharp.CSharpTokenNode})">
            <summary>
            Writes a keyword, and all specials up to
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.Semicolon">
            <summary>
            Marks the end of a statement
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.Space(System.Boolean)">
            <summary>
            Writes a space depending on policy.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.IsKeyword(System.String,ICSharpCode.NRefactory.CSharp.AstNode)">
            <summary>
            Determines whether the specified identifier is a keyword in the given context.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role">
            <summary>
            Represents the role a node plays within its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Role.IsValid(System.Object)">
            <summary>
            Gets whether the specified node is valid in this role.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role`1">
            <summary>
            Represents the role a node plays within its parent.
            All nodes with this role have type T.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Role`1.NullObject">
            <summary>
            Gets the null object used when there's no node with this role.
            Not every role has a null object; this property returns null for roles without a null object.
            </summary>
            <remarks>
            Roles used for non-collections should always have a null object, so that no AST property returns null.
            However, roles used for collections only may leave out the null object.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.BacktrackingInfo">
            <summary>
            Container for the backtracking info.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ConstantValues.PrimitiveConstantExpression">
            <summary>
            C#'s equivalent to the SimpleConstantValue.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ConstantValues.ConstantArrayCreation">
            <summary>
            Represents an array creation (as used within an attribute argument)
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CacheManager">
            <summary>
            Allows the registration of static "caching types" which can then be used to efficiently retrieve an
            instance per CacheManager (or even per CacheManager and thread).
            </summary>
            <remarks>This class is thread-safe</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.CacheManager.Dispose">
            <summary>
            Invokes the <see cref="E:ICSharpCode.NRefactory.Utils.CacheManager.Disposed"/> event.
            </summary>
        </member>
        <member name="T:Mono.CSharp.SideEffectConstant">
            <summary>
              The value is constant, but when emitted has a side effect.  This is
              used by BitwiseAnd to ensure that the second expression is invoked
              regardless of the value of the left side.  
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.VarianceModifier">
            <summary>
            Represents the variance of a type parameter.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Invariant">
            <summary>
            The type parameter is not variant.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Covariant">
            <summary>
            The type parameter is covariant (used in output position).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Contravariant">
            <summary>
            The type parameter is contravariant (used in input position).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage">
            <summary>
            Stores a set of types and allows resolving them.
            </summary>
            <remarks>
            Concurrent read accesses are thread-safe, but a write access concurrent to any other access is not safe.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetClasses">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetClasses(System.String,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetNamespaces">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetNamespace(System.String,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.Synchronize">
            <summary>
            TypeStorage is mutable and does not provide any means for synchronization, so this method
            always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.RemoveType(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Removes a type definition from this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.UpdateType(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Adds the type definition to this project content.
            Replaces existing type definitions with the same name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.CacheManager">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext">
            <summary>
            Represents multiple type resolve contexts.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.Combine(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext"/> that combines the given resolve contexts.
            If one of the input parameters is null, the other input parameter is returned directly.
            If both input parameters are null, the function returns null.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext})">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext"/>
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetClasses">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetClasses(System.String,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetNamespaces">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetNamespace(System.String,System.StringComparer)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.Synchronize">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Accessibility">
            <summary>
            Enum that describes the accessibility of an entity.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.None">
            <summary>
            The entity is completely inaccessible. This is used for C# explicit interface implementations.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Private">
            <summary>
            The entity is only accessible within the same class.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Public">
            <summary>
            The entity is accessible everywhere.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Protected">
            <summary>
            The entity is only accessible within the same class and in derived classes.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Internal">
            <summary>
            The entity is accessible within the same project content.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedOrInternal">
            <summary>
            The entity is accessible both everywhere in the project content, and in all derived classes.
            </summary>
            <remarks>This corresponds to C# 'protected internal'.</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedAndInternal">
            <summary>
            The entity is accessible in derived classes within the same project content.
            </summary>
            <remarks>C# does not support this accessibility.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.WhileStatement">
            <summary>
            "while (Condition) EmbeddedStatement"
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UsingStatement">
            <summary>
            using (ResourceAcquisition) EmbeddedStatement
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.UsingStatement.ResourceAcquisition">
            <summary>
            Either a VariableDeclarationStatement, or an Expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.UsingDeclaration">
            <summary>
            using Import;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.NullReferenceExpression">
            <summary>
            null
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.MemberReferenceExpression">
            <summary>
            Target.MemberName
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.BaseReferenceExpression">
            <summary>
            base
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.NodeType.TypeReference">
            <summary>
            DomType
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.NodeType.TypeDeclaration">
            <summary>
            Type or delegate declaration
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.CSharp.NodeType.Pattern">
            <summary>
            Placeholder for a pattern
            </summary>
        </member>
        <member name="T:Mono.CSharp.EmitContext">
            <summary>
              An Emit Context is created for each body of code (from methods,
              properties bodies, indexer bodies or constructor bodies)
            </summary>
        </member>
        <member name="F:Mono.CSharp.BuilderContext.Options.CheckedScope">
             <summary>
               This flag tracks the `checked' state of the compilation,
               it controls whether we should generate code that does overflow
               checking, or if we generate code that ignores overflows.
            
               The default setting comes from the command line option to generate
               checked or unchecked code plus any source code changes using the
               checked/unchecked statements or expressions.   Contrast this with
               the ConstantCheckState flag.
             </summary>
        </member>
        <member name="F:Mono.CSharp.BuilderContext.Options.ConstantCheckState">
            <summary>
              The constant check state is always set to `true' and cant be changed
              from the command line.  The source code can change this setting with
              the `checked' and `unchecked' statements and expressions. 
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.return_type">
            <summary>
              The value that is allowed to be returned or NULL if there is no
              return type.
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.temporary_storage">
            <summary>
              Keeps track of the Type to LocalBuilder temporary storage created
              to store structures (used to compute the address of the structure
              value on structure method invocations)
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.return_value">
            <summary>
              The location where we store the return value.
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.ReturnLabel">
            <summary>
              The location where return has to jump to return the
              value
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.HasReturnLabel">
            <summary>
              If we already defined the ReturnLabel
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.LoopBegin">
            <summary>
              Current loop begin and end labels.
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.LoopEnd">
            <summary>
              Current loop begin and end labels.
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.DefaultTarget">
            <summary>
              Default target in a switch statement.   Only valid if
              InSwitch is true
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.Switch">
            <summary>
              If this is non-null, points to the current switch statement
            </summary>
        </member>
        <member name="F:Mono.CSharp.EmitContext.CurrentAnonymousMethod">
            <summary>
             Whether we are inside an anonymous method.
            </summary>
        </member>
        <member name="M:Mono.CSharp.EmitContext.Mark(Mono.CSharp.Location)">
            <summary>
              This is called immediately before emitting an IL opcode to tell the symbol
              writer to which source line this opcode belongs.
            </summary>
        </member>
        <member name="M:Mono.CSharp.EmitContext.GetTemporaryLocal(Mono.CSharp.TypeSpec)">
            <summary>
              Returns a temporary storage for a variable of type t as 
              a local variable in the current body.
            </summary>
        </member>
        <member name="M:Mono.CSharp.EmitContext.TemporaryReturn">
             <summary>
               ReturnValue creates on demand the LocalBuilder for the
               return value from the function.  By default this is not
               used.  This is only required when returns are found inside
               Try or Catch statements.
            
               This method is typically invoked from the Emit phase, so
               we allow the creation of a return label if it was not
               requested during the resolution phase.   Could be cleaned
               up, but it would replicate a lot of logic in the Emit phase
               of the code that uses it.
             </summary>
        </member>
        <member name="T:Mono.CSharp.TypeParameterExpr">
            <summary>
              A TypeExpr which already resolved to a type parameter.
            </summary>
        </member>
        <member name="M:Mono.CSharp.TypeArguments.Resolve(Mono.CSharp.IMemberContext)">
            <summary>
              Resolve the type arguments.
            </summary>
        </member>
        <member name="P:Mono.CSharp.TypeArguments.Arguments">
            <summary>
              We may only be used after Resolve() is called and return the fully
              resolved types.
            </summary>
        </member>
        <member name="M:Mono.CSharp.GenericTypeExpr.#ctor(Mono.CSharp.TypeSpec,Mono.CSharp.TypeArguments,Mono.CSharp.Location)">
            <summary>
              Instantiate the generic type `t' with the type arguments `args'.
              Use this constructor if you already know the fully resolved
              generic type.
            </summary>		
        </member>
        <member name="T:Mono.CSharp.GenericMethod">
            <summary>
              A generic method definition.
            </summary>
        </member>
        <member name="M:Mono.CSharp.GenericMethod.Define(Mono.CSharp.MethodOrOperator)">
            <summary>
              Define and resolve the type parameters.
              We're called from Method.Define().
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter">
            <summary>
            Default implementation for IParameter.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter.#ctor(ICSharpCode.NRefactory.TypeSystem.IParameter)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader">
            <summary>
            Allows loading an IProjectContent from an already compiled assembly.
            </summary>
            <remarks>Instance methods are not thread-safe; you need to create multiple instances of CecilLoader
            if you want to load multiple project contents in parallel.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadAssembly(Mono.Cecil.AssemblyDefinition)">
            <summary>
            Loads the assembly definition into a project content.
            </summary>
            <returns>IProjectContent that represents the assembly</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadType(Mono.Cecil.TypeDefinition,ICSharpCode.NRefactory.TypeSystem.IProjectContent)">
            <summary>
            Loads a type from Cecil.
            </summary>
            <param name="typeDefinition">The Cecil TypeDefinition.</param>
            <param name="projectContent">The project content used as parent for the new type.</param>
            <returns>ITypeDefinition representing the Cecil type.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.ReadTypeReference(Mono.Cecil.TypeReference,Mono.Cecil.ICustomAttributeProvider,ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Reads a type reference.
            </summary>
            <param name="type">The Cecil type reference that should be converted into
            a type system type reference.</param>
            <param name="typeAttributes">Attributes associated with the Cecil type reference.
            This is used to support the 'dynamic' type.</param>
            <param name="entity">The entity that owns this type reference.
            Used for generic type references.</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.EarlyBindContext">
            <summary>
            Gets/Sets the early bind context.
            This context is used to pre-resolve type references - setting this property will cause the CecilLoader
            to directly reference the resolved types, and create links (<see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference"/>) to types
            that could not be resolved.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.IncludeInternalMembers">
            <summary>
            Specifies whether to include internal members. The default is false.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.DocumentationProvider">
            <summary>
            Gets/Sets the documentation provider that is used to retrieve the XML documentation for all members.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.InterningProvider">
            <summary>
            Gets/Sets the interning provider.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope">
            <summary>
            Represents a scope that contains "using" statements.
            This is either the file itself, or a namespace declaration.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope.#ctor(ICSharpCode.NRefactory.TypeSystem.IProjectContent)">
            <summary>
            Creates a new root using scope.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope.#ctor(ICSharpCode.NRefactory.CSharp.Resolver.UsingScope,System.String)">
            <summary>
            Creates a new nested using scope.
            </summary>
            <param name="parent">The parent using scope.</param>
            <param name="namespaceName">The full namespace name.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope.HasAlias(System.String)">
            <summary>
            Gets whether this using scope has an alias (either using or extern)
            with the specified name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.ParsedFile">
            <summary>
            Represents a file that was parsed and converted for the type system.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.GotoStatement">
            <summary>
            "goto Label;"
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.GotoCaseStatement">
            <summary>
            or "goto case LabelExpression;"
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.CSharp.GotoCaseStatement.LabelExpression">
            <summary>
            Used for "goto case LabelExpression;"
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.GotoDefaultStatement">
            <summary>
            or "goto default;"
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Repeat">
            <summary>
            Represents an optional node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MapTypeIntoNewContext">
            <summary>
            Converts a type by replacing all type definitions with the equivalent definitions in the new context.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.NamedArgumentExpression">
            <summary>
            Represents a named argument passed to a method or attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.IndexerExpression">
            <summary>
            Target[Arguments]
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.GraphVizGraph">
            <summary>
            GraphViz graph.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.color">
            <summary>edge stroke color</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.constraint">
            <summary>use edge to affect node ranking</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.fontsize">
            <summary>point size of label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.fontsize">
            <summary>point size of label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.height">
            <summary>minimum height in inches</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.margin">
            <summary>space around label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.shape">
            <summary>node shape</summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast">
            <summary>
            Static helper method for converting between primitive types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast.Cast(System.TypeCode,System.Object,System.Boolean)">
            <summary>
            Performs a conversion between primitive types.
            Unfortunately we cannot use Convert.ChangeType because it has different semantics
            (e.g. rounding behavior for floats, overflow, etc.), so we write down every possible primitive C# cast
            and let the compiler figure out the exact semantics.
            And we have to do everything twice, once in a checked-block, once in an unchecked-block.
            </summary>
        </member>
        <member name="T:Mono.CSharp.Enum">
            <summary>
              Enumeration container
            </summary>
        </member>
        <member name="F:Mono.CSharp.BlockContext.ReturnLabel">
            <summary>
              The location where return has to jump to return the
              value
            </summary>
        </member>
        <member name="F:Mono.CSharp.BlockContext.HasReturnLabel">
            <summary>
              If we already defined the ReturnLabel
            </summary>
        </member>
        <member name="M:Mono.CSharp.CloneContext.RemapBlockCopy(Mono.CSharp.Block)">
            
             Remaps block to cloned copy if one exists.
            
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference">
            <summary>
            Type reference used to reference nested types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,System.Int32)">
            <summary>
            Creates a new NestedTypeReference.
            </summary>
            <param name="declaringTypeRef">Reference to the declaring type.</param>
            <param name="name">Name of the nested class</param>
            <param name="additionalTypeParameterCount">Number of type parameters on the inner class (without type parameters on baseTypeRef)</param>
            <remarks>
            <paramref name="declaringTypeRef"/> must be exactly the (unbound) declaring type, not a derived type, not a parameterized type.
            NestedTypeReference thus always resolves to a type definition, never to (partially) parameterized types.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ConstantResolveResult">
            <summary>
            ResolveResult representing a compile-time constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.LockStatement">
            <summary>
            lock (Expression) EmbeddedStatement;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.CSharp.SizeOfExpression">
            <summary>
            sizeof(Type)
            </summary>
        </member>
    </members>
</doc>
