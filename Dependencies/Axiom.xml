<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Axiom</name>
    </assembly>
    <members>
        <member name="T:Axiom.Serialization.MaterialSerializer">
            <summary>
            Summary description for MaterialSerializer.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.scriptContext">
            <summary>
            	Represents the current parsing context.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.rootAttribParsers">
            <summary>
            	Parsers for the root of the material script
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.materialAttribParsers">
            <summary>
            	Parsers for the material section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.techniqueAttribParsers">
            <summary>
            	Parsers for the technique section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.passAttribParsers">
            <summary>
            	Parsers for the pass section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.textureUnitAttribParsers">
            <summary>
            	Parsers for the texture unit section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.programRefAttribParsers">
            <summary>
            	Parsers for the program reference section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.programAttribParsers">
            <summary>
            	Parsers for the program definition section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.programDefaultParamAttribParsers">
            <summary>
            	Parsers for the program definition section of a script.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.InvokeParser(System.String,Axiom.Collections.AxiomCollection{System.Reflection.MethodInfo})">
            <summary>
            	Internal method for finding &amp; invoking an attribute parser.
            </summary>
            <param name="line"></param>
            <param name="parsers"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.FinishProgramDefinition">
            <summary>
            	Internal method for saving a program definition which has been built up.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.LogParseError(Axiom.Serialization.MaterialScriptContext,System.String,System.Object[])">
            <summary>
            	Helper method for logging parser errors.
            </summary>
            <param name="context">Current parsing context.</param>
            <param name="error">Error message.</param>
            <param name="substitutions">Items to sub in for the error message, if the error contains them.</param>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseScriptLine(System.String)">
            <summary>
            	Internal method for parsing a material.
            </summary>
            <param name="line"></param>
            <returns>True if it expects the next line to be a "{", false otherwise.</returns>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.RegisterParserMethods">
            <summary>
            	Queries this serializer class for methods intended to parse material script attributes.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseProgramCustomParameter(System.String,Axiom.Serialization.MaterialScriptContext)">
            <summary>
            	Parse custom GPU program parameters.
            </summary>
            <remarks>
            	This one is called explicitly, and is not added to any parser list.
            </remarks>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseColorOp(System.String,Axiom.Serialization.MaterialScriptContext)">
            Note: Allows both spellings of color :-).
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseColorOpFallback(System.String,Axiom.Serialization.MaterialScriptContext)">
            Note: Allows both spellings of color :-).
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseColorOpEx(System.String,Axiom.Serialization.MaterialScriptContext)">
            Note: Allows both spellings of color :-).
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseScript(System.IO.Stream,System.String,System.String)">
             <summary>
            		Parses a Material script file passed in the specified stream.
             </summary>
             <param name="stream">Stream containing the material file data.</param>
             <param name="groupName">Name of the material group.</param>
            <param name="fileName"></param>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ProcessAutoProgramParam(System.Boolean,System.String,System.String[],Axiom.Serialization.MaterialScriptContext,System.Int32,System.String)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <param name="commandName"></param>
             <param name="parameters"></param>
             <param name="context"></param>
        </member>
        <member name="T:Axiom.Serialization.MaterialSerializer.MaterialAttributeParserHandler">
            <summary>
            	The method signature for all material attribute parsing methods.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialScriptSection">
            <summary>
            	Enum to identify material sections.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialScriptContext">
            <summary>
            	Struct for holding the script context while parsing.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialAttributeParserAttribute">
            <summary>
            	Custom attribute to mark methods as handling the parsing for a material script attribute.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.ParserCommandAttribute">
            <summary>
            	Custom attribute to mark methods as handling the parsing for a material script attribute.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.IScriptLoader">
            <summary>
            Abstract class defining the interface used by classes which wish
            to perform script loading to define instances of whatever they manage.
            </summary>
            <remarks>
            Typically classes of this type wish to either parse individual script files
            on demand, or be called with a group of files matching a certain pattern
            at the appropriate time. Normally this will coincide with resource loading,
            although the script use does not necessarily have to be a ResourceManager
            (which subclasses from this class), it may be simply a script loader which
            manages non-resources but needs to be synchronised at the same loading points.
            <para/>
            Subclasses should add themselves to the ResourceGroupManager as a script loader
            if they wish to be called at the point a resource group is loaded, at which
            point the ParseScript method will be called with each file which matches a
            the pattern returned from ScriptPatterns.
            </remarks>
            <ogre name="ScriptLoader">
                <file name="OgreScriptLoader.h" revision="1.4" lastUpdated="6/20/2006" lastUpdatedBy="Borrillis" />
            </ogre>
        </member>
        <member name="M:Axiom.Scripting.IScriptLoader.ParseScript(System.IO.Stream,System.String,System.String)">
            <summary>
            Parse a script file.
            </summary>
            <param name="stream">reference to a data stream which is the source of the script</param>
            <param name="groupName">
            The name of a resource group which should be used if any resources
            are created during the parse of this script.
            </param>
            <param name="fileName"></param>
        </member>
        <member name="P:Axiom.Scripting.IScriptLoader.ScriptPatterns">
            <summary>
            Gets the file patterns which should be used to find scripts for this class.
            </summary>
            <remarks>
            This method is called when a resource group is loaded if you use
            ResourceGroupManager::registerScriptLoader. Returns a list of file
            patterns, in the order they should be searched in.
            </remarks>
        </member>
        <member name="P:Axiom.Scripting.IScriptLoader.LoadingOrder">
            <summary>
            Gets the relative loading order of scripts of this type.
            </summary>
            <remarks>
            There are dependencies between some kinds of scripts, and to enforce
            this all implementors of this interface must define a loading order.
            Returns a value representing the relative loading order of these scripts
            compared to other script users, where higher values load later.
            </remarks>
        </member>
        <member name="T:Axiom.Scripting.IPropertyCommand">
            <summary>
            Specialization of the IPropertyCommand using object
            </summary>
        </member>
        <member name="T:Axiom.Scripting.IPropertyCommand`1">
            <summary>
            Provides an interface for setting object properties via a Command Pattern.
            </summary>
            <typeparam name="TObjectType">Type of the object to operate on.</typeparam>
        </member>
        <member name="M:Axiom.Scripting.IPropertyCommand`1.Get(`0)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.IPropertyCommand`1.Set(`0,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompiler">
            <summary>
            This is the main class for the compiler. It calls the parser
            and processes the CST into an AST and then uses translators
            to translate the AST into the final resources.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.Compiler.ScriptCompiler._imports">
            <summary>
            The set of imported scripts to avoid circular dependencies
            </summary>
        </member>
        <member name="F:Axiom.Scripting.Compiler.ScriptCompiler._importRequests">
            <summary>
            This holds the target objects for each script to be imported
            </summary>
        </member>
        <member name="F:Axiom.Scripting.Compiler.ScriptCompiler._importTable">
            <summary>
            This stores the imports of the scripts, so they are separated and can be treated specially
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.String,System.String,System.String)">
            <summary>
            Takes in a string of script code and compiles it into resources
            </summary>
            <param name="script">The script code</param>
            <param name="source">The source of the script code (e.g. a script file)</param>
            <param name="group">The resource group to place the compiled resources into</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String,System.Boolean)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String,System.Boolean,System.Boolean)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Compiles the given abstract syntax tree
            </summary>
            <param name="nodes"></param>
            <param name="group"></param>
            <param name="doImports"></param>
            <param name="doObjects"></param>
            <param name="doVariables"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Compile(System.Collections.Generic.IList{Axiom.Scripting.Compiler.ConcreteNode},System.String)">
            <summary>
            Compiles resources from the given concrete node list
            </summary>
            <param name="nodes">The list of nodes to compile</param>
            <param name="group">The resource group to place the compiled resources into</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.AddError(Axiom.Scripting.Compiler.ScriptCompiler.CompileErrorCode,System.String,System.UInt32,System.String)">
            <summary>
            Adds the given error to the compiler's list of errors
            </summary>
            <param name="code"></param>
            <param name="file"></param>
            <param name="line"></param>
            <param name="msg"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._fireEvent(Axiom.Scripting.Compiler.ScriptCompilerEvent@)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler._fireEvent(Axiom.Scripting.Compiler.ScriptCompilerEvent@,System.Object@)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._fireEvent(Axiom.Scripting.Compiler.ScriptCompilerEvent@,System.Object@)">
            <summary>
            Internal method for firing the handleEvent method
            </summary>
            <param name="evt"></param>
            <param name="retVal"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._isNameExcluded(System.String,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <summary>
            Returns true if the given class is name excluded
            </summary>
            <param name="cls"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._processImports(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode}@)">
            <summary>
            This built-in function processes import nodes
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._processVariables(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode}@)">
            <summary>
            Handles processing the variables
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._processObjects(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode}@,System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode})">
            <summary>
            Handles object inheritance and variable expansion
            </summary>
            <param name="nodes"></param>
            <param name="top"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._loadImportPath(System.String)">
            <summary>
            Loads the requested script and converts it to an AST
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler._locateTarget(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.String)">
            <summary>
            Returns the abstract nodes from the given tree which represent the target
            </summary>
            <param name="nodes"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompiler.OnImportFile">
            <see cref="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnImportFile"/>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompiler.OnPreConversion">
            <see cref="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnPreConversion"/>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompiler.OnPostConversion">
            <see cref="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnPostConversion"/>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompiler.OnCompileError">
            <see cref="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnCompileError"/>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompiler.OnCompilerEvent">
            <see cref="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnCompilerEvent"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <summary>
            Internal method that checks if this Translator is the right translator for the node
            supplied by the <see cref="T:Axiom.Scripting.Compiler.ScriptTranslatorManager"/>.
            </summary>
            <param name="nodeId">The Id of the node</param>
            <param name="parentId">The Id of the node's parent (if any)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <summary>
            This function translates the given node into Ogre resource(s).
            </summary>
            <param name="compiler">The compiler invoking this translator</param>
            <param name="node">The current AST node to be translated</param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator._processNode(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <summary>
            Retrieves a new translator from the factories and uses it to process the give node
            </summary>
            <param name="compiler"></param>
            <param name="node"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getNodeAt(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.Int32)">
            <summary>
            Retrieves the node iterator at the given index
            </summary>
            <param name="nodes"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getBoolean(Axiom.Scripting.Compiler.AST.AbstractNode,System.Boolean@)">
            <summary>
            Converts the node to a boolean and returns true if successful
            </summary>
            <param name="node"></param>
            <param name="result"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getString(Axiom.Scripting.Compiler.AST.AbstractNode,System.String@)">
            <summary>
            Converts the node to a string and returns true if successful
            </summary>
            <param name="node"></param>
            <param name="result"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getReal(Axiom.Scripting.Compiler.AST.AbstractNode,Axiom.Math.Real@)">
            <summary>
            Converts the node to a Real and returns true if successful
            </summary>
            <param name="node"></param>
            <param name="result"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getFloat(Axiom.Scripting.Compiler.AST.AbstractNode,System.Single@)">
            <summary>
            Converts the node to a float and returns true if successful
            </summary>
            <param name="node"></param>
            <param name="result"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getInt(Axiom.Scripting.Compiler.AST.AbstractNode,System.Int32@)">
            <summary>
            Converts the node to an int and returns true if successful
            </summary>
            <param name="node"></param>
            <param name="result"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getUInt(Axiom.Scripting.Compiler.AST.AbstractNode,System.UInt32@)">
            <summary>
            Converts the node to a uint and returns true if successful
            </summary>
            <param name="node"></param>
            <param name="result"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getColor(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.Int32,Axiom.Core.ColorEx@,System.Int32)">
            <summary>
            Converts the range of nodes to a ColourValue and returns true if successful
            </summary>
            <param name="nodes"></param>
            <param name="i"></param>
            <param name="result"></param>
            <param name="maxEntries"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getMatrix4(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.Int32,Axiom.Math.Matrix4@)">
            <summary>
            Converts the range of nodes to a Matrix4 and returns true if successful
            </summary>
            <param name="nodes"></param>
            <param name="i"></param>
            <param name="m"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getInts(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.Int32,System.Int32[]@,System.Int32)">
            <summary>
            Converts the range of nodes to an array of ints and returns true if successful
            </summary>
            <param name="nodes"></param>
            <param name="i"></param>
            <param name="vals"></param>
            <param name="count"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getFloats(System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode},System.Int32,System.Single[]@,System.Int32)">
            <summary>
            Converts the range of nodes to an array of floats and returns true if successful
            </summary>
            <param name="nodes"></param>
            <param name="i"></param>
            <param name="vals"></param>
            <param name="count"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.getEnumeration``1(Axiom.Scripting.Compiler.AST.AbstractNode,Axiom.Scripting.Compiler.ScriptCompiler,``0@)">
            <summary>
            Converts the node to an enum of type T and returns true if successful
            </summary>
            <typeparam name="T"></typeparam>
            <param name="node"></param>
            <param name="compiler"></param>
            <param name="property"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.ParticleSystemTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.ParticleSystemTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositorTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionTechniqueTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionTechniqueTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.TextureSourceTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.TextureSourceTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.TextureUnitTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.TextureUnitTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.ParticleEmitterTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.ParticleEmitterTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionTargetPassTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionTargetPassTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.TechniqueTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.TechniqueTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionPassTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionPassTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompiler.CompileErrorCode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.ParticleAffectorTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.ParticleAffectorTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionPassClearTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionPassClearTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.PassTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.PassTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.GpuProgramTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.GpuProgramTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionPassStencilTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.CompositionPassStencilTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.MaterialTranslator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.CheckFor(Axiom.Scripting.Compiler.Keywords,Axiom.Scripting.Compiler.Keywords)"/>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompiler.MaterialTranslator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)">
            <see cref="M:Axiom.Scripting.Compiler.ScriptCompiler.Translator.Translate(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.AST.AbstractNode)"/>
        </member>
        <member name="T:Axiom.Overlays.OverlayManager">
            <summary>
               Manages Overlay objects, parsing them from Ogre .overlay files and
               storing a lookup library of them. Also manages the creation of
               OverlayContainers and OverlayElements, used for non-interactive 2D
               elements such as HUDs.
            </summary>
        </member>
        <member name="T:Axiom.Core.Singleton`1">
            <summary>
            A generic singleton
            </summary>
            <remarks>
            Although this class will allow it, don't try to do this: Singleton&lt; interface &gt;
            </remarks>
            <typeparam name="T">a class</typeparam>
        </member>
        <member name="M:Axiom.Core.Singleton`1.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Core.Singleton`1.isDisposed">
            <summary>
            Determines if this instance has been disposed of already.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.Create(System.String)">
            <summary>
            	Creates and return a new overlay.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.GetByName(System.String)">
            <summary>
            Retrieve an Overlay by name
            </summary>
            <param name="name">Name of Overlay to retrieve</param>
            <returns>The overlay or null if not found.</returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.Destroy(System.String)">
            <summary>
            Destroys an existing overlay by name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.Destroy(Axiom.Overlays.Overlay)">
            <summary>
            Destroys an existing overlay
            </summary>
            <param name="overlay"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.DestroyAll">
            <summary>
            Destroys all existing overlays
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.QueueOverlaysForRendering(Axiom.Core.Camera,Axiom.Graphics.RenderQueue,Axiom.Core.Viewport)">
            <summary>
            	Internal method for queueing the visible overlays for rendering.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
            <param name="viewport"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseAttrib(System.String,Axiom.Overlays.Overlay)">
            <summary>
               Parses an attribute belonging to an Overlay.
            </summary>
            <param name="line"></param>
            <param name="overlay"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseChildren(System.IO.TextReader,System.String,Axiom.Overlays.Overlay,System.Boolean,Axiom.Overlays.OverlayElementContainer)">
             <summary>
            
             </summary>
             <param name="script"></param>
             <param name="line"></param>
             <param name="overlay"></param>
             <param name="isTemplate"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseElementAttrib(System.String,Axiom.Overlays.Overlay,Axiom.Overlays.OverlayElement)">
             <summary>
            
             </summary>
             <param name="line"></param>
             <param name="overlay"></param>
             <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseNewElement(System.IO.TextReader,System.String,System.String,System.Boolean,Axiom.Overlays.Overlay,System.Boolean)">
            <summary>
               Overloaded.  Calls overload with default of empty template name and null for the parent container.
            </summary>
            <param name="script"></param>
            <param name="type"></param>
            <param name="name"></param>
            <param name="isContainer"></param>
            <param name="overlay"></param>
            <param name="isTemplate"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseNewElement(System.IO.TextReader,System.String,System.String,System.Boolean,Axiom.Overlays.Overlay,System.Boolean,System.String,Axiom.Overlays.OverlayElementContainer)">
            <summary>
               Parses a new element
            </summary>
            <param name="script"></param>
            <param name="type"></param>
            <param name="name"></param>
            <param name="isContainer"></param>
            <param name="overlay"></param>
            <param name="isTemplate"></param>
            <param name="templateName"></param>
            <param name="parent"></param>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.Overlays">
            <summary>
            returns all existing overlays
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.HasViewportChanged">
            <summary>
            	Gets if the viewport has changed dimensions.
            </summary>
            <remarks>
            	This is used by pixel-based GuiControls to work out if they need to reclaculate their sizes.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.ViewportHeight">
            <summary>
            	Gets the height of the destination viewport in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.ViewportWidth">
            <summary>
            	Gets the width of the destination viewport in pixels.
            </summary>
        </member>
        <member name="T:Axiom.Media.Image">
            <summary>
               Class representing an image file.
            </summary>
            <remarks>
               The Image class usually holds uncompressed image data and is the
               only object that can be loaded in a texture. Image objects handle 
               image data decoding themselves by the means of locating the correct 
               ICodec implementation for each data type.
            </remarks>
        </member>
        <member name="M:Axiom.Core.DisposableObject.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !IsDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Core.DisposableObject.IsDisposed">
            <summary>
            Determines if this instance has been disposed of already.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.buffer">
            <summary>
               Byte array containing the image data.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.bufferPinnedHandle">
            <summary>
              This allows me to pin the buffer, so that I can return PixelBox 
              objects representing subsets of this image.  Since the PixelBox
              does not own the data, and has an IntPtr, I need to pin the
              internal buffer here.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.bufPtr">
            <summary>
              This is the pointer to the contents of buffer.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.width">
            <summary>
               Width of the image (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.height">
            <summary>
               Width of the image (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.depth">
            <summary>
               Depth of the image
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.size">
            <summary>
               Size of the image buffer.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.numMipMaps">
            <summary>
               Number of mip maps in this image.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.flags">
            <summary>
               Additional features on this image.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.format">
            <summary>
               Image format.
            </summary>
        </member>
        <member name="M:Axiom.Media.Image.ApplyGamma(System.Byte[],System.Single,System.Int32,System.Int32)">
            <summary>
               Performs gamma adjustment on this image.
            </summary>
            <remarks>
               Basic algo taken from Titan Engine, copyright (c) 2000 Ignacio 
               Castano Iguado.
            </remarks>
            <param name="buffer"></param>
            <param name="gamma"></param>
            <param name="size"></param>
            <param name="bpp"></param>
        </member>
        <member name="M:Axiom.Media.Image.ApplyGamma(System.IntPtr,System.Single,System.Int32,System.Int32)">
            <summary>
              Variant of ApplyGamma that operates on an unmanaged chunk of memory
            </summary>
            <param name="bufPtr"></param>
            <param name="gamma"></param>
            <param name="size"></param>
            <param name="bpp"></param>
        </member>
        <member name="M:Axiom.Media.Image.FlipAroundX">
            <summary>
            	Flips this image around the X axis.
                This will invalidate any 
            </summary>
        </member>
        <member name="M:Axiom.Media.Image.FromFile(System.String)">
            <summary>
               Loads an image file from the file system.
            </summary>
            <param name="fileName">Full path to the image file on disk.</param>
        </member>
        <member name="M:Axiom.Media.Image.FromRawStream(System.IO.Stream,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from memory.
            </summary>
            <param name="stream">Stream containing the raw image data.</param>
            <param name="width">Width of this image data (in pixels).</param>
            <param name="height">Height of this image data (in pixels).</param>
            <param name="format">Pixel format used in this texture.</param>
            <returns>A new instance of Image containing the raw data supplied.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromRawStream(System.IO.Stream,System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from memory.
            </summary>
            <param name="stream">Stream containing the raw image data.</param>
            <param name="width">Width of this image data (in pixels).</param>
            <param name="height">Height of this image data (in pixels).</param>
            <param name="depth"></param>
            <param name="format">Pixel format used in this texture.</param>
            <returns>A new instance of Image containing the raw data supplied.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromDynamicImage(System.Byte[],System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from a byte array.
            </summary>
            <param name="buffer">Raw image buffer.</param>
            <param name="width">Width of this image data (in pixels).</param>
            <param name="height">Height of this image data (in pixels).</param>
            <param name="format">Pixel format used in this texture.</param>
            <returns>A new instance of Image containing the raw data supplied.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromDynamicImage(System.Byte[],System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from a byte array.
            </summary>
            <param name="buffer">Raw image buffer.</param>
            <param name="width">Width of this image data (in pixels).</param>
            <param name="height">Height of this image data (in pixels).</param>
            <param name="depth"></param>
            <param name="format">Pixel format used in this texture.</param>
            <returns>A new instance of Image containing the raw data supplied.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromStream(System.IO.Stream,System.String)">
            <summary>
               Loads an image from a stream.
            </summary>
            <remarks>
               This method allows loading an image from a stream, which is helpful for when
               images are being decompressed from an archive into a stream, which needs to be
               loaded as is.
            </remarks>
            <param name="stream">Stream serving as the data source.</param>
            <param name="type">
               Type (i.e. file format) of image.  Used to decide which image decompression codec to use.
            </param>
        </member>
        <member name="M:Axiom.Media.Image.Save(System.String)">
            <summary>
            Saves the Image as a file
            </summary>
            <remarks>
            The codec used to save the file is determined by the extension of the filename passed in
            Invalid or unrecognized extensions will throw an exception.
            </remarks>
            <param name="filename">Filename to save as</param>
        </member>
        <member name="M:Axiom.Media.Image.GetPixelBox(System.Int32,System.Int32)">
            <summary>
            Get a PixelBox encapsulating the image data of a mipmap
            </summary>
            <param name="face"></param>
            <param name="mipmap"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.Image.HasFlag(Axiom.Media.ImageFlags)">
            <summary>
               Checks if the specified flag is set on this image.
            </summary>
            <param name="flag">The flag to check for.</param>
            <returns>True if the flag is set, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Media.Image.Scale(Axiom.Media.PixelBox,Axiom.Media.PixelBox)">
            <summary>
            Scale a 1D, 2D or 3D image volume.
            </summary>
            <param name="src">PixelBox containing the source pointer, dimensions and format</param>
            <param name="dst">PixelBox containing the destination pointer, dimensions and format</param>
            <remarks>
            This function can do pixel format conversion in the process.
            dst and src can point to the same PixelBox object without any problem
            </remarks>
        </member>
        <member name="M:Axiom.Media.Image.Scale(Axiom.Media.PixelBox,Axiom.Media.PixelBox,Axiom.Media.ImageFilter)">
            <summary>
            Scale a 1D, 2D or 3D image volume.
            </summary>
            <param name="src">PixelBox containing the source pointer, dimensions and format</param>
            <param name="scaled">PixelBox containing the destination pointer, dimensions and format</param>
            <param name="filter">Which filter to use</param>
            <remarks>
            This function can do pixel format conversion in the process.
            dst and src can point to the same PixelBox object without any problem
            </remarks>
        </member>
        <member name="M:Axiom.Media.Image.Resize(System.Int32,System.Int32)">
            <summary>
            Resize a 2D image, applying the appropriate filter.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Axiom.Media.Image.Resize(System.Int32,System.Int32,Axiom.Media.ImageFilter)">
            <summary>
            Resize a 2D image, applying the appropriate filter.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="filter"></param>
        </member>
        <member name="M:Axiom.Media.Image.CropImage(Axiom.Media.Image,System.UInt32,System.UInt32,System.Int32,System.Int32)">
            <summary>
            Little utility function that crops an image
            (Doesn't alter the source image, returns a cropped representation)
            </summary>
            <param name="source">The source image</param>
            <param name="offsetX">The X offset from the origin</param>
            <param name="offsetY">The Y offset from the origin</param>
            <param name="width">The width to crop to</param>
            <param name="height">The height to crop to</param>
            <returns>Returns the cropped representation of the source image if the parameters are valid, otherwise, returns the source image.</returns>
        </member>
        <member name="M:Axiom.Media.Image.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
             
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
             	isDisposed = true;
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Media.Image.Data">
            <summary>
               Gets the byte array that holds the image data.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Size">
            <summary>
               Gets the size (in bytes) of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Width">
            <summary>
               Gets the width of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Height">
            <summary>
               Gets the height of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Depth">
            <summary>
               Gets the depth of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.NumMipMaps">
            <summary>
               Gets the number of mipmaps contained in this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.NumFaces">
            <summary>
              Get the numer of faces of the image. This is usually 6 for a cubemap,
              and 1 for a normal image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Format">
            <summary>
               Gets the format of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.BitsPerPixel">
            <summary>
               Gets the number of bits per pixel in this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.HasAlpha">
            <summary>
               Gets whether or not this image has an alpha component in its pixel format.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.RowSpan">
            <summary>
            Width of the image in bytes
            </summary>
        </member>
        <member name="T:Axiom.Media.ImageFlags">
            <summary>
               Various flags that give details on a particular image.
            </summary>
        </member>
        <member name="T:Axiom.Media.PixelFormat">
            <summary>
               The pixel format used for images.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.Unknown">
            <summary>
               Unknown pixel format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.L8">
            <summary>
               8-bit pixel format, all bits luminance.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A8">
            <summary>
               8-bit pixel format, all bits alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A4L4">
            <summary>
               8-bit pixel format, 4 bits alpha, 4 bits luminance.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.R3G3B2">
            <summary>
              8-bit pixel format, 3 bits red, 3 bits green, 2 bits blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.R5G6B5">
            <summary>
               16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B5G6R5">
            <summary>
               16-bit pixel format, 5 bits blue, 6 bits green, 5 bits red.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A4R4G4B4">
            <summary>
               16-bit pixel format, 4 bits for alpha, red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B4G4R4A4">
            <summary>
               16-bit pixel format, 4 bits for blue, green, red and alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A8L8">
            <summary>
               16-bit pixel format, 8 bits for alpha, 8 bits for luminance.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.L16">
            <summary>
               16-bit pixel format, all bits luminance.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A1R5G5B5">
            <summary>
               16-bit pixel format, 1 bit for alpha, 5 bits for blue, green and red.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.R8G8B8">
            <summary>
               24-bit pixel format, 8 bits for red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B8G8R8">
            <summary>
               24-bit pixel format, 8 bits for blue, green and red.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A8R8G8B8">
            <summary>
               32-bit pixel format, 8 bits for alpha, red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A8B8G8R8">
            <summary>
               32-bit pixel format, 8 bits for alpha, blue, green and red`.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B8G8R8A8">
            <summary>
               32-bit pixel format, 8 bits for blue, green, red and alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.R8G8B8A8">
            <summary>
               32-bit pixel format, 8 bits for red, green, blue and alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.X8R8G8B8">
            <summary>
               32-bit pixel format, 8 bits for red, green and blue.
               like PF_A8R8G8B8, but alpha will get discarded
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.X8B8G8R8">
            <summary>
               32-bit pixel format, 8 bits for blue, green and red.
            	like PF_A8R8G8B8, but alpha will get discarded
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A2R10G10B10">
            <summary>
               32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A2B10G10R10">
            <summary>
               32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT1">
            <summary>
               DDS (DirectDraw Surface) DXT1 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT2">
            <summary>
               DDS (DirectDraw Surface) DXT2 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT3">
            <summary>
               DDS (DirectDraw Surface) DXT3 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT4">
            <summary>
               DDS (DirectDraw Surface) DXT4 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT5">
            <summary>
               DDS (DirectDraw Surface) DXT5 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DEPTH">
            <summary>
            	Depth texture format
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.SHORT_RGBA">
            <summary>
              64 bit pixel format, 16 bits for red, 16 bits for green, 16 bits for blue, 16 bits for alpha
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT16_R">
            <summary>
               16 bit floating point with a single channel (red)
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT16_RGB">
            <summary>
               48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT16_RGBA">
            <summary>
               64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT32_R">
            <summary>
            	32 bit floating point with a single channel (red)
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT32_RGB">
            <summary>
               96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT32_RGBA">
            <summary>
               128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT16_GR">
            <summary>
            	32-bit pixel format, 2-channel floating point pixel format, 16 bits (float) for green, 16 bits (float) for red
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.FLOAT32_GR">
            <summary>
            	64-bit pixel format, 2-channel floating point pixel format, 32 bits (float) for green, 32 bits (float) for red
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.SHORT_GR">
            <summary>
            32-bit pixel format, 16-bit green, 16-bit red
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.SHORT_RGB">
            <summary>
            48-bit pixel format, 16 bits for red, green and blue
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.Count">
            <summary>
               The last one, used to size arrays of PixelFormat.  Don't add anything after this one!
            </summary>
        </member>
        <member name="T:Axiom.Media.PixelFormatFlags">
            <summary>
               Flags defining some on/off properties of pixel formats
            </summary>
        </member>
        <member name="T:Axiom.Media.PixelComponentType">
            <summary>
               Pixel component format
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelComponentType.Byte">
            <summary>
             Byte per component (8 bit fixed 0.0..1.0)
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelComponentType.Short">
            <summary>
            Short per component (16 bit fixed 0.0..1.0))
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelComponentType.Float16">
            <summary>
            16 bit float per component
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelComponentType.Float32">
            <summary>
            32 bit float per component
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelComponentType.Count">
            <summary>
            Number of pixel types
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.QuaternionCollection">
            <summary>
            	A strongly-typed collection of <see cref="T:Axiom.Math.Quaternion"/> objects.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Synchronized(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Creates a synchronized (thread-safe) wrapper for a 
                <c>QuaternionCollection</c> instance.
            </summary>
            <returns>
                An <c>QuaternionCollection</c> wrapper that is synchronized (thread-safe).
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.ReadOnly(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Creates a read-only wrapper for a 
                <c>QuaternionCollection</c> instance.
            </summary>
            <returns>
                An <c>QuaternionCollection</c> wrapper that is read-only.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that has the specified initial capacity.
            </summary>
            <param name="capacity">
            	The number of elements that the new <c>QuaternionCollection</c> is initially capable of storing.
            </param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that contains elements copied from the specified <c>QuaternionCollection</c>.
            </summary>
            <param name="c">The <c>QuaternionCollection</c> whose elements are copied to the new collection.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor(Axiom.Math.Quaternion[])">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that contains elements copied from the specified <see cref="T:Axiom.Math.Quaternion"/> array.
            </summary>
            <param name="a">The <see cref="T:Axiom.Math.Quaternion"/> array whose elements are copied to the new list.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.CopyTo(Axiom.Math.Quaternion[])">
            <summary>
            	Copies the entire <c>QuaternionCollection</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Quaternion"/> array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Quaternion"/> array to copy to.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.CopyTo(Axiom.Math.Quaternion[],System.Int32)">
            <summary>
            	Copies the entire <c>QuaternionCollection</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Quaternion"/> array, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Quaternion"/> array to copy to.</param>
            <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Add(Axiom.Math.Quaternion)">
            <summary>
            	Adds a <see cref="T:Axiom.Math.Quaternion"/> to the end of the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to be added to the end of the <c>QuaternionCollection</c>.</param>
            <returns>The index at which the value has been added.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Clear">
            <summary>
            	Removes all elements from the <c>QuaternionCollection</c>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Clone">
            <summary>
            	Creates a shallow copy of the <see cref="T:Axiom.Math.Collections.QuaternionCollection"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Contains(Axiom.Math.Quaternion)">
            <summary>
            	Determines whether a given <see cref="T:Axiom.Math.Quaternion"/> is in the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to check for.</param>
            <returns><c>true</c> if <paramref name="item"/> is found in the <c>QuaternionCollection</c>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.IndexOf(Axiom.Math.Quaternion)">
            <summary>
            	Returns the zero-based index of the first occurrence of a <see cref="T:Axiom.Math.Quaternion"/>
            	in the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to locate in the <c>QuaternionCollection</c>.</param>
            <returns>
            	The zero-based index of the first occurrence of <paramref name="item"/> 
            	in the entire <c>QuaternionCollection</c>, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Insert(System.Int32,Axiom.Math.Quaternion)">
            <summary>
            	Inserts an element into the <c>QuaternionCollection</c> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Remove(Axiom.Math.Quaternion)">
            <summary>
            	Removes the first occurrence of a specific <see cref="T:Axiom.Math.Quaternion"/> from the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to remove from the <c>QuaternionCollection</c>.</param>
            <exception cref="T:System.ArgumentException">
            	The specified <see cref="T:Axiom.Math.Quaternion"/> was not found in the <c>QuaternionCollection</c>.
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.RemoveAt(System.Int32)">
            <summary>
            	Removes the element at the specified index of the <c>QuaternionCollection</c>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.GetEnumerator">
            <summary>
            	Returns an enumerator that can iterate through the <c>QuaternionCollection</c>.
            </summary>
            <returns>An <see cref="T:Axiom.Math.Collections.QuaternionCollection.Enumerator"/> for the entire <c>QuaternionCollection</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.AddRange(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Adds the elements of another <c>QuaternionCollection</c> to the current <c>QuaternionCollection</c>.
            </summary>
            <param name="x">The <c>QuaternionCollection</c> whose elements should be added to the end of the current <c>QuaternionCollection</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/> of the <c>QuaternionCollection</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.AddRange(Axiom.Math.Quaternion[])">
            <summary>
            	Adds the elements of a <see cref="T:Axiom.Math.Quaternion"/> array to the current <c>QuaternionCollection</c>.
            </summary>
            <param name="x">The <see cref="T:Axiom.Math.Quaternion"/> array whose elements should be added to the end of the <c>QuaternionCollection</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/> of the <c>QuaternionCollection</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.TrimToSize">
            <summary>
            	Sets the capacity to the actual number of elements.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.ValidateIndex(System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="i"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="i"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.ValidateIndex(System.Int32,System.Boolean)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="i"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="i"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Count">
            <summary>
            	Gets the number of elements actually contained in the <c>QuaternionCollection</c>.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IsSynchronized">
            <summary>
            	Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
            <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.SyncRoot">
            <summary>
            	Gets an object that can be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Item(System.Int32)">
            <summary>
            	Gets or sets the <see cref="T:Axiom.Math.Quaternion"/> at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IsFixedSize">
            <summary>
            	Gets a value indicating whether the collection has a fixed size.
            </summary>
            <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IsReadOnly">
            <summary>
            	gets a value indicating whether the <B>IList</B> is read-only.
            </summary>
            <value>true if the collection is read-only; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Capacity">
            <summary>
            	Gets or sets the number of elements the <c>QuaternionCollection</c> can contain.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator">
            <summary>
            	Supports type-safe iteration over a <see cref="T:Axiom.Math.Collections.QuaternionCollection"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.QuaternionCollection.Enumerator">
            <summary>
            	Supports simple iteration over a <see cref="T:Axiom.Math.Collections.QuaternionCollection"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Enumerator.#ctor(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
            <param name="tc"></param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Enumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Enumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Input.InputReader">
            <summary>
            	Abstract class which allows input to be read from various
            	controllers.
             </summary>
             <remarks>
            	Temporary implementation only. This class is likely to be
            	refactored into a better design when I get time to look at it
            	properly. For now it's a quick-and-dirty way to get what I need.
            </remarks>
        </member>
        <member name="F:Axiom.Input.InputReader.useKeyboardEvents">
            <summary>
            	Flag for whether or not to fire keyboard events.
            </summary>
        </member>
        <member name="F:Axiom.Input.InputReader.useMouseEvents">
            <summary>
            	Flag for whether or not to fire mouse events.
            </summary>
        </member>
        <member name="F:Axiom.Input.InputReader.modifiers">
            <summary>
            	Active modifier keys.
            </summary>
        </member>
        <member name="M:Axiom.Input.InputReader.Initialize(Axiom.Graphics.RenderWindow,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Subclasses should initialize the underlying input subsystem using this
            	method.
            </summary>
            <param name="parent">Parent window that the input belongs to.</param>
            <param name="useGamepad"></param>
            <param name="ownMouse">
            	If true, input will be taken over from the OS and exclusive to the window.
            	If false, input will still be shared with other apps.
            </param>
            <param name="useKeyboard"></param>
            <param name="useMouse"></param>
        </member>
        <member name="M:Axiom.Input.InputReader.Capture">
            <summary>
            	Captures the state of all the input devices.
            </summary>
            <remarks>
            	This method captures the state of all input devices and
            	stores it internally for use when the enquiry methods are
            	next called. This is done to ensure that all input is
            	captured at once and therefore combinations of input are not
            	subject to time differences when methods are called.
            </remarks>
        </member>
        <member name="M:Axiom.Input.InputReader.IsKeyPressed(Axiom.Input.KeyCodes)">
            <summary>
            	Used to check if a particular key was pressed during the last call to Capture.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Input.InputReader.IsMousePressed(Axiom.Input.MouseButtons)">
            <summary>
               Returns true if the specified mouse button is currently down.
            </summary>
            <param name="button">Mouse button to query.</param>
            <returns>True if the mouse button is down, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Input.InputReader.GetKeyChar(Axiom.Input.KeyCodes,Axiom.Input.ModifierKeys)">
            <summary>
            	Given a key code enum value, the corresponding character is returned.
            </summary>
        </member>
        <member name="M:Axiom.Input.InputReader.KeyChanged(Axiom.Input.KeyCodes,System.Boolean)">
            <summary>
            	Helper method for running logic on a key change.
            </summary>
            <param name="key">Code of the key being changed</param>
            <param name="down">True if the key is being pressed down, false if being released.</param>
        </member>
        <member name="M:Axiom.Input.InputReader.OnKeyDown(Axiom.Input.KeyEventArgs)">
            <summary>
            	Triggers the <see cref="E:Axiom.Input.InputReader.KeyDown"/> event.
            </summary>
            <param name="e">Event arguments.</param>
        </member>
        <member name="M:Axiom.Input.InputReader.OnKeyUp(Axiom.Input.KeyEventArgs)">
            <summary>
            	Triggers the <see cref="E:Axiom.Input.InputReader.KeyUp"/> event.
            </summary>
            <param name="e">Event arguments.</param>
        </member>
        <member name="M:Axiom.Input.InputReader.Dispose">
            <summary>
                Called to destroy this input reader.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.RelativeMouseX">
            <summary>
            	Retrieves the relative (compared to the last input poll) mouse movement
            	on the X (horizontal) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.RelativeMouseY">
            <summary>
            	Retrieves the relative (compared to the last input poll) mouse movement
            	on the Y (vertical) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.RelativeMouseZ">
            <summary>
            	Retrieves the relative (compared to the last input poll) mouse movement
            	on the Z (mouse wheel) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.AbsoluteMouseX">
            <summary>
            	Retrieves the absolute mouse position on the X (horizontal) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.AbsoluteMouseY">
            <summary>
            	Retrieves the absolute mouse position on the Y (vertical) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.AbsoluteMouseZ">
            <summary>
            	Retrieves the absolute mouse position on the Z (mouse wheel) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputReader.UseKeyboardEvents">
            <summary>
            	Get/Set whether or not to use event based keyboard input notification.
            </summary>
            <value>
            	When true, events will be fired when keyboard input occurs on a call to <see cref="M:Axiom.Input.InputReader.Capture"/>.
            	When false, the current keyboard state will be available via <see cref="M:Axiom.Input.InputReader.IsKeyPressed(Axiom.Input.KeyCodes)"/> .
            </value>
        </member>
        <member name="P:Axiom.Input.InputReader.UseMouseEvents">
            <summary>
            	Get/Set whether or not to use event based mouse input notification.
            </summary>
            <value>
            	When true, events will be fired when mouse input occurs on a call to <see cref="M:Axiom.Input.InputReader.Capture"/>.
            	When false, the current mouse state will be available via <see cref="M:Axiom.Input.InputReader.IsMousePressed(Axiom.Input.MouseButtons)"/> .
            </value>
        </member>
        <member name="E:Axiom.Input.InputReader.KeyDown">
            <summary>
            	Occurs when a key is initially pressed down.
            </summary>
        </member>
        <member name="E:Axiom.Input.InputReader.KeyUp">
            <summary>
            	Occurs when a key is released from being pressed down.
            </summary>
        </member>
        <member name="T:Axiom.Input.MouseEventHandler">
            <summary>
            	Delegate for mouse related events.
            </summary>
        </member>
        <member name="T:Axiom.Input.KeyboardEventHandler">
            <summary>
            	Delegate for keyboard related events.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.ArchiveManager">
            <summary>
             This class manages the available ArchiveFactory plugins.
            </summary>
            <ogre name="ArchiveManager">
                <file name="OgreArchiveManager.h"   revision="1.8.2.1" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreArchiveManager.cpp" revision="1.14.2.1" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
        </member>
        <member name="F:Axiom.FileSystem.ArchiveManager._factories">
            <summary>
            The list of factories
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.#ctor">
            <summary>
            Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.Load(System.String,System.String)">
            <summary>
            Opens an archive for file reading.
            </summary>
            <remarks>
            The archives are created using class factories within
            extension libraries.
            </remarks>
            <param name="filename">The filename that will be opened</param>
            <param name="archiveType">The library that contains the data-handling code</param>
            <returns>
            If the function succeeds, a valid pointer to an Archive object is returned.
            <para/>
            If the function fails, an exception is thrown.
            </returns>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.Unload(Axiom.FileSystem.Archive)">
            <summary>
             Unloads an archive.
             </summary>
             <remarks>
            You must ensure that this archive is not being used before removing it.
             </remarks>
            <param name="arch">The Archive to unload</param>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.Unload(System.String)">
            <summary>
             Unloads an archive.
             </summary>
             <remarks>
            You must ensure that this archive is not being used before removing it.
             </remarks>
            <param name="filename">The Archive to unload</param>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.AddArchiveFactory(Axiom.FileSystem.ArchiveFactory)">
            <summary>
            Add an archive factory to the list
            </summary>
            <param name="factory">The factory itself</param>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.dispose(System.Boolean)">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="T:Axiom.Collections.ControllerList">
            <summary>
            Summary description for AnimationCollection.
            </summary>
        </member>
        <member name="T:Axiom.Media.NearestResampler">
            <summary>
            nearest-neighbor resampler, does not convert formats.
            </summary>
        </member>
        <member name="M:Axiom.Media.NearestResampler.Scale(Axiom.Media.PixelBox,Axiom.Media.PixelBox)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="temp"></param>
        </member>
        <member name="M:Axiom.Media.NearestResampler.Scale(Axiom.Media.PixelBox,Axiom.Media.PixelBox,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Math.Real">
            <summary>
            a floating point number abstraction allows the use of either a single-precision or double-precision floating point number
            </summary>
            <remarks>
            Use the AXIOM_REAL_AS_DOUBLE condition compilation argument to use a double-precision value or
            AXIOM_REAL_AS_SINGLE to use a single-precision value.
            </remarks>
        </member>
        <member name="F:Axiom.Math.Real.englishCulture">
            <summary>
            	Culture info to use for parsing numeric data.
            </summary>
        </member>
        <member name="F:Axiom.Math.Real._value">
            <summary>Internal storage for value</summary>
        </member>
        <member name="F:Axiom.Math.Real.Zero">
            <summary>The value 0</summary>
        </member>
        <member name="F:Axiom.Math.Real.One">
            <summary>The value 1</summary>
        </member>
        <member name="F:Axiom.Math.Real.PositiveInfinity">
            <summary>The value of Positive Infinity</summary>
        </member>
        <member name="F:Axiom.Math.Real.NegativeInfinity">
            <summary>The value of Negative Infinity</summary>
        </member>
        <member name="F:Axiom.Math.Real.NaN">
            <summary>Represents not a number</summary>
        </member>
        <member name="F:Axiom.Math.Real.Epsilon">
            <summary>The value of Epsilon</summary>
        </member>
        <member name="F:Axiom.Math.Real.MaxValue">
            <summary>The maximum possible value</summary>
        </member>
        <member name="F:Axiom.Math.Real.MinValue">
            <summary>The minimum possible value</summary>
        </member>
        <member name="M:Axiom.Math.Real.IsPositiveInfinity(Axiom.Math.Real)">
            <summary>
            Returns a value indicating whether the specified number evaluates to positive infinity
            </summary>
            <param name="number">a floating point number</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:Axiom.Math.Real.IsNegativeInfinity(Axiom.Math.Real)">
            <summary>
            Returns a value indicating whether the specified number evaluates to negative infinity
            </summary>
            <param name="number">a floating point number</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:Axiom.Math.Real.IsInfinity(Axiom.Math.Real)">
            <summary>
            Returns a value indicating whether the specified number evaluates to negative infinity
            </summary>
            <param name="number">a floating point number</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:Axiom.Math.Real.IsNaN(Axiom.Math.Real)">
            <summary>
            Returns a value indicating whether the specified number evaluates to not a number
            </summary>
            <param name="number">a floating point number</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:Axiom.Math.Real.Parse(System.String)">
            <overloads>
            <summary>
            converts a string representation of a number in a specified style and culture-specific format
            to its floating point number equivilent
            </summary>
            <param name="value">a floating point number</param>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.FormatException"/>
            <exception cref="T:System.ArgumentNullException"/>
            <returns>a Real</returns>
            </overloads>
        </member>
        <member name="M:Axiom.Math.Real.Parse(System.String,System.IFormatProvider)">
            <param name="value"></param>
            <param name="provider"></param>
        </member>
        <member name="M:Axiom.Math.Real.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <param name="value"></param>
            <param name="style"></param>
            <param name="provider"></param>
        </member>
        <member name="M:Axiom.Math.Real.Parse(System.String,System.Globalization.NumberStyles)">
            <param name="value">a floating point number</param>
            <param name="style"></param>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.Int32)">
            <overloads>
            <summary>
            initializes a Real with a specified value
            </summary>
            </overloads>
            <param name="value">an integer representation of the value to convert</param>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.Int64)">
            <param name="value">a long representation of the value to convert</param>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.Single)">
            <param name="value">a float representation of the value to convert</param>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.Double)">
            <param name="value">a double representation of the value to convert</param>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.Decimal)">
            <param name="value">a decimal representation of the value to convert</param>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.String)">
            <param name="value">a string representation of the value to convert</param>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(System.Int32)~Axiom.Math.Real">
            <summary>
            Implicit conversion from int to Real
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Explicit(Axiom.Math.Real)~System.Int32">
            <summary>
            Explicit conversion from Real to int
            </summary>
            <param name="real"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(System.Int64)~Axiom.Math.Real">
            <summary>
            Implicit conversion from int to Real
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Explicit(Axiom.Math.Real)~System.Int64">
            <summary>
            Explicit conversion from Real to int
            </summary>
            <param name="real"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(System.Single)~Axiom.Math.Real">
            <summary>
            Implicit conversion from float to Real
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(Axiom.Math.Real)~System.Single">
            <summary>
            Implicit conversion from Real to float
            </summary>
            <param name="real"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(System.Double)~Axiom.Math.Real">
            <summary>
            Implicit conversion from double to Real
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(Axiom.Math.Real)~System.Double">
            <summary>
            Explicit conversion from Real to double
            </summary>
            <param name="real"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(System.Decimal)~Axiom.Math.Real">
            <summary>
            Implicit conversion from decimal to Real
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Explicit(Axiom.Math.Real)~System.Decimal">
            <summary>
            Explicit conversion from Real to decimal
            </summary>
            <param name="real"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Implicit(System.String)~Axiom.Math.Real">
            <summary>
            Implicit conversion from string to Real
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Explicit(Axiom.Math.Real)~System.String">
            <summary>
            Explicit conversion from Real to string
            </summary>
            <param name="real"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Equality(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Used to test equality between two Reals
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <remarks>The == operator uses the static Tolerance value to determine equality</remarks>
        </member>
        <member name="M:Axiom.Math.Real.op_Inequality(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Used to test inequality between two Reals
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <remarks>The == operator uses the static Tolerance value to determine equality </remarks>
        </member>
        <member name="M:Axiom.Math.Real.op_GreaterThan(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_LessThan(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_GreaterThanOrEqual(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_LessThanOrEqual(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Addition(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Used when a Real is added to another Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Subtraction(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Used to subtract a Real from another Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Multiply(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Used when a Real is multiplied by a Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_Division(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
                Used when a Real is divided by a Real
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.op_UnaryNegation(Axiom.Math.Real)">
            <summary>
            	Used to negate the elements of a Real.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Add(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Used when a Real is added to another Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Subtract(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Used to subtract a Real from another Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Multiply(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Used when a Real is multiplied by a Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Divide(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Used when a Real is divided by a Real.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Negate(Axiom.Math.Real)">
            <summary>
            	Used to negate the elements of a Real.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Floor">
            <summary>
            Returns the samllest integer less than or equal to the current value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Ceiling">
            <summary>
            Returns the samllest integer greater than or equal to the current value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Real.Equals(Axiom.Math.Real)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Math.Real.Equals(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Math.Real.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Math.Real.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Axiom.Math.Real.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Axiom.Math.Real.CompareTo(Axiom.Math.Real)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Math.Radian">
            <summary>
            Wrapper class which indicates a given angle value is in Radians.
            </summary>
            <remarks>
            Radian values are interchangeable with Degree values, and conversions
            will be done automatically between them.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.Collections.VertexElementList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.TextureEffectList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.RenderTextureList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.PassList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.TechniqueList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.TextureUnitStateList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.RenderableList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.TriangleList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.EdgeList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.EdgeGroupList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.VertexDataList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.IndexDataList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.ShadowRenderableList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.OperationTypeList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimableType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.Int">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.Float">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.Vector2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.Vector3">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.Vector4">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.Quaternion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimableType.ColorEx">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimableValue">
             <summary>
                 Defines an object property which is animable, ie may be keyframed.
             </summary>
             <remarks>
                 Animable properties are those which can be altered over time by a 
                 predefined keyframe sequence. They may be set directly, or they may
                 be modified from their existing state (common if multiple animations
                 are expected to apply at once). Implementors of this interface are
                 expected to override the 'setValue', 'setCurrentStateAsBaseValue' and 
                 'ApplyDeltaValue' methods appropriate to the type in question, and to 
                 initialise the type.
                 
                 AnimableValue instances are accessible through any class which extends
                 AnimableObject in order to expose it's animable properties.
                 
                 This class is an instance of the Adapter pattern, since it generalises
                 access to a particular property. Whilst it could have been templated
                 such that the type which was being referenced was compiled in, this would
                 make it more difficult to aggregated generically, and since animations
                 are often comprised of multiple properties it helps to be able to deal
                 with all values through a single class.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(System.Int32)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(System.Single)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(Axiom.Math.Vector2)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(Axiom.Math.Vector3)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(Axiom.Math.Vector4)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(Axiom.Math.Quaternion)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetAsBaseValue(Axiom.Core.ColorEx)">
            Internal method to set a value as base
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(System.Int32)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(System.Single)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(Axiom.Math.Vector2)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(Axiom.Math.Vector3)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(Axiom.Math.Vector4)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(Axiom.Math.Quaternion)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(Axiom.Core.ColorEx)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetValue(System.Object)">
            Set value 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(System.Int32)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(System.Single)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(Axiom.Math.Vector2)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(Axiom.Math.Vector3)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(Axiom.Math.Vector4)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(Axiom.Math.Quaternion)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(Axiom.Core.ColorEx)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.ApplyDeltaValue(System.Object)">
            Apply the specified delta 
        </member>
        <member name="M:Axiom.Animating.AnimableValue.SetCurrentStateAsBaseValue">
            Sets the current state as the 'base' value; used for delta animation
            Any instantiated derived class must implement this guy
        </member>
        <member name="T:Axiom.Animating.IAnimableObject">
            <summary>
            Defines an interface to classes which have one or more AnimableValue instances to expose.
            </summary>
        </member>
        <member name="M:Axiom.Animating.IAnimableObject.CreateAnimableValue(System.String)">
            <summary>
            	Create an AnimableValue for the attribute with the given name, or 
                throws an exception if this object doesn't support creating them.
            </summary>
        </member>
        <member name="P:Axiom.Animating.IAnimableObject.AnimableValueNames">
            <summary>
            	Return the names of all the AnimableValue names supported by this object.
                This can return the null list if there are none.
            </summary>
        </member>
        <member name="T:Axiom.Utilities.Proclaim">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Utilities.Proclaim.NotNull(System.Object[])">
            <summary>
            Asserts if any argument is <c>null</c>.
            </summary>
            <param name="vars"></param>
        </member>
        <member name="M:Axiom.Utilities.Proclaim.NotEmpty(System.String)">
            <summary>
            Asserts if the string is <c>null</c> or zero length.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Axiom.Utilities.Proclaim.NotEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Asserts if the collection is <c>null</c> or the <c>Count</c> is zero.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
        </member>
        <member name="M:Axiom.Utilities.Proclaim.NotNullItems``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Asserts if any item in the collection is <c>null</c>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
        </member>
        <member name="P:Axiom.Utilities.Proclaim.Unreachable">
            <summary>
            Asserts if this statement is reached.
            </summary>
            <exception cref="T:System.InvalidOperationException">Code is supposed to be unreachable.</exception>
        </member>
        <member name="T:Axiom.Scripting.Compiler.Parser.Tokens">
            <summary>
            These codes represent token IDs which are numerical translations of
            specific lexemes. Specific compilers using the lexer can register their
            own token IDs which are given precedence over these built-in ones
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.VariableGetAbstractNode">
            <summary>
            This abstract node represents a variable assignment
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.AbstractNode">
            <summary>
            base node type for the AST
            </summary>
        </member>
        <member name="F:Axiom.Scripting.Compiler.AST.AbstractNode.Context">
            <summary>
            An holder for translation context data
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.AbstractNode.#ctor(Axiom.Scripting.Compiler.AST.AbstractNode)">
            <summary>
            Constructor
            </summary>
            <param name="parent">the parent AbstractNode in the tree</param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone">
            <summary>
            Returns a new AbstractNode which is a replica of this one
            </summary>
            <returns>a new AbstractNode</returns>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value">
            <summary>
            Returns a string value depending on the type of the AbstractNode.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.VariableGetAbstractNode.Clone">
            <see cref="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone"/>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.VariableGetAbstractNode.Value">
            <see cref="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value"/>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.AtomAbstractNode">
            <summary>
             This is an abstract node which cannot be broken down further
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.AtomAbstractNode.Clone">
            <see cref="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone"/>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.AtomAbstractNode.Value">
            <see cref="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value"/>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleAffectorFactory">
            <summary>
            	Abstract class defining the interface to be implemented by creators of ParticleAffector subclasses.
            </summary>
            <remarks>
            	Plugins or 3rd party applications can add new types of particle affectors  by creating
            	subclasses of the ParticleAffector class. Because multiple instances of these affectors may be
            	required, a factory class to manage the instances is also required. 
            	<p/>
            	ParticleAffectorFactory subclasses must allow the creation and destruction of ParticleAffector
            	subclasses. They must also be registered with the ParticleSystemManager. All factories have
            	a name which identifies them, examples might be 'ForceVector', 'Attractor', or 'Fader', and these can be 
            	also be used from particle system scripts.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.Create">
            <summary>
            	Creates a new affector instance.
            </summary>
            <remarks>
            	Subclasses MUST add a reference to the affectorList.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.Destroy(Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            	Destroys the affector referenced by the parameter.
            </summary>
            <param name="e">The Affector to destroy.</param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleAffectorFactory.Name">
            <summary>
            	Returns the name of the factory, which identifies the affector type this factory creates.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.MetricsMode">
            <summary>
            	Describes how the position / size of an element is to be treated. 
            </summary>
        </member>
        <member name="F:Axiom.Overlays.MetricsMode.Relative">
            <summary>'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0</summary>
        </member>
        <member name="F:Axiom.Overlays.MetricsMode.Pixels">
            <summary>Positions &amp; sizes are in absolute pixels.</summary>
        </member>
        <member name="F:Axiom.Overlays.MetricsMode.Relative_Aspect_Adjusted">
            <summary>
            Positions &amp; sizes are in virtual pixels
            </summary>
        </member>
        <member name="T:Axiom.Overlays.HorizontalAlignment">
            <summary>
            	Describes where '0' is in relation to the parent in the horizontal dimension.  Affects how 'left' is interpreted.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.HorizontalAlignment.Left">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.HorizontalAlignment.Center">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.HorizontalAlignment.Right">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Overlays.VerticalAlignment">
            <summary>
            	Describes where '0' is in relation to the parent in the vertical dimension.  Affects how 'top' is interpreted.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.VerticalAlignment.Top">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.VerticalAlignment.Center">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.VerticalAlignment.Bottom">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Math.AxisAlignedBox">
            <summary>
            	A 3D box aligned with the x/y/z axes.
            </summary>
            <remarks>
            	This class represents a simple box which is aligned with the
                axes. It stores 2 points as the extremeties of
                the box, one which is the minima of all 3 axes, and the other
                which is the maxima of all 3 axes. This class is typically used
                for an axis-aligned bounding box (AABB) for collision and
                visibility determination.
            </remarks>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Transform(Axiom.Math.Matrix4)">
            <summary>
            
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.UpdateCorners">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.SetExtents(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Sets both Minimum and Maximum at once, so that UpdateCorners only
            	needs to be called once as well.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Scale(Axiom.Math.Vector3)">
            <summary>
               Scales the size of the box by the supplied factor.
            </summary>
            <param name="factor">Factor of scaling to apply to the box.</param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.FromDimensions(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
                Return new bounding box from the supplied dimensions.
            </summary>
            <param name="center">Center of the new box</param>
            <param name="size">Entire size of the new box</param>
            <returns>New bounding box</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Merge(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Allows for merging two boxes together (combining).
            </summary>
            <param name="box">Source box.</param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Merge(Axiom.Math.Vector3)">
            <summary>
            	Extends the box to encompass the specified point (if needed).
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Contains(Axiom.Math.Vector3)">
            <summary>
            Tests whether the given point contained by this box.
            </summary>
            <param name="v"></param>
            <returns>True if the vector is contained inside the box.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Returns whether or not this box intersects another.
            </summary>
            <param name="box2"></param>
            <returns>True if the 2 boxes intersect, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Tests whether this box intersects a sphere.
            </summary>
            <param name="sphere"></param>
            <returns>True if the sphere intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.Plane)">
            <summary>
            
            </summary>
            <param name="plane"></param>
            <returns>True if the plane intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.Vector3)">
            <summary>
            	Tests whether the vector point is within this box.
            </summary>
            <param name="vector"></param>
            <returns>True if the vector is within this box, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersection(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Calculate the area of intersection of this box and another
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Size">
            <summary>
                Get/set the size of this bounding box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Center">
            <summary>
               Get/set the center point of this bounding box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Maximum">
            <summary>
            	Get/set the maximum corner of the box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Minimum">
            <summary>
            	Get/set the minimum corner of the box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Corners">
            <summary>
            	Returns an array of 8 corner points, useful for
            	collision vs. non-aligned objects.
            </summary>
            <remarks>
            	If the order of these corners is important, they are as
            	follows: The 4 points of the minimum Z face (note that
            	because we use right-handed coordinates, the minimum Z is
            	at the 'back' of the box) starting with the minimum point of
            	all, then anticlockwise around this face (if you are looking
            	onto the face from outside the box). Then the 4 points of the
            	maximum Z face, starting with maximum point of all, then
            	anticlockwise around this face (looking onto the face from
            	outside the box). Like this:
            	<pre>
            		 1-----2
            	    /|     /|
            	  /  |   /  |
            	5-----4   |
            	|   0-|--3
            	|  /   |  /
            	|/     |/
            	6-----7
            	</pre>
            </remarks>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.IsNull">
            <summary>
            	Get/set the value of whether this box is null (i.e. not dimensions, etc).
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.IsInfinite">
            <summary>
            Returns true if the box is infinite.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Null">
            <summary>
            	Returns a null box
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Volume">
            <summary>
                Calculate the volume of this box
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareBuffer">
            <summary>
                Abstract class defining common features of hardware buffers.
            </summary>
            <remarks>
                A 'hardware buffer' is any area of memory held outside of core system ram,
                and in our case refers mostly to video ram, although in theory this class
                could be used with other memory areas such as sound card memory, custom
                coprocessor memory etc.
                <p/>
                This reflects the fact that memory held outside of main system RAM must
                be interacted with in a more formal fashion in order to promote
                cooperative and optimal usage of the buffers between the various
                processing units which manipulate them.
                <p/>
                This abstract class defines the core interface which is common to all
                buffers, whether it be vertex buffers, index buffers, texture memory
                or framebuffer memory etc.
                <p/>
                Buffers have the ability to be 'shadowed' in system memory, this is because
                the kinds of access allowed on hardware buffers is not always as flexible as
                that allowed for areas of system memory - for example it is often either
                impossible, or extremely undesirable from a performance standpoint to read from
                a hardware buffer; when writing to hardware buffers, you should also write every
                byte and do it sequentially. In situations where this is too restrictive,
                it is possible to create a hardware, write-only buffer (the most efficient kind)
                and to back it with a system memory 'shadow' copy which can be read and updated arbitrarily.
                Axiom handles synchronizing this buffer with the real hardware buffer (which should still be
                created with the <see cref="F:Axiom.Graphics.BufferUsage.Dynamic"/> flag if you intend to update it very frequently).
                Whilst this approach does have it's own costs, such as increased memory overhead, these costs can
                often be outweighed by the performance benefits of using a more hardware efficient buffer.
                You should look for the 'useShadowBuffer' parameter on the creation methods used to create
                the buffer of the type you require (see <see cref="T:Axiom.Graphics.HardwareBufferManager"/>) to enable this feature.
                <seealso cref="T:Axiom.Graphics.HardwareBufferManager"/>
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.sizeInBytes">
            <summary>
                Total size (in bytes) of the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.usage">
            <summary>
                Usage type for this buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.isLocked">
            <summary>
                Is this buffer currently locked?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.lockStart">
            <summary>
                Byte offset into the buffer where the current lock is held.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.lockSize">
            <summary>
                Total size (int bytes) of locked buffer data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.useSystemMemory">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.useShadowBuffer">
            <summary>
                Does this buffer have a shadow buffer?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.shadowBuffer">
            <summary>
                Reference to the sys memory shadow buffer tied to this hardware buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.shadowUpdated">
            <summary>
                Flag indicating whether the shadow buffer (if it exists) has been updated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.suppressHardwareUpdate">
            <summary>
                Flag indicating whether hardware updates from shadow buffer should be supressed.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.ID">
            <summary>
            	Unique id for this buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.#ctor(Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="usage">Usage type.</param>
            <param name="useSystemMemory"></param>
            <param name="useShadowBuffer">Use a software shadow buffer?</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Lock(Axiom.Graphics.BufferLocking)">
            <summary>
            	Convenient overload to allow locking the entire buffer with only having
            	to supply the locking type.
            </summary>
            <param name="locking">Locking options.</param>
            <returns>IntPtr to the beginning of the locked region of buffer memory.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Lock(System.Int32,System.Int32,Axiom.Graphics.BufferLocking)">
            <summary>
            	Used to lock a vertex buffer in hardware memory in order to make modifications.
            </summary>
            <param name="offset">Starting index in the buffer to lock.</param>
            <param name="length">Number of bytes to lock after the offset.</param>
            <param name="locking">Specifies how to lock the buffer.</param>
            <returns>An array of the <code>System.Type</code> associated with this VertexBuffer.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.LockImpl(System.Int32,System.Int32,Axiom.Graphics.BufferLocking)">
            <summary>
                Internal implementation of Lock, which will be overridden by subclasses to provide
                the core locking functionality.
            </summary>
            <param name="offset">Offset into the buffer (in bytes) to lock.</param>
            <param name="length">Length of the portion of the buffer (int bytes) to lock.</param>
            <param name="locking">Locking type.</param>
            <returns>IntPtr to the beginning of the locked portion of the buffer.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Unlock">
            <summary>
            	Must be called after a call to <code>Lock</code>.  Unlocks the vertex buffer in the hardware
            	memory.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.UnlockImpl">
            <summary>
                Abstract implementation of <see cref="M:Axiom.Graphics.HardwareBuffer.Unlock"/>.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.ReadData(System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Reads data from the buffer and places it in the memory pointed to by 'dest'.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to read.</param>
            <param name="length">The size of the area to read, in bytes.</param>
            <param name="dest">
                The area of memory in which to place the data, must be large enough to
                accommodate the data!
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.IntPtr,System.Boolean)">
            <summary>
                Writes data to the buffer from an area of system memory; note that you must
                ensure that your buffer is big enough.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="src">The source of the data to be written.</param>
            <param name="discardWholeBuffer">
                If true, this allows the driver to discard the entire buffer when writing,
                such that DMA stalls can be avoided; use if you can.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Writes data to the buffer from an area of system memory; note that you must
                ensure that your buffer is big enough.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="src">The source of the data to be written.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.Array)">
            <summary>
               Allows passing in a managed array of data to fill the vertex buffer.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="data">
                Array of data to blast into the buffer.  This can be an array of custom structs, that hold
                position, normal, etc data.  The size of the struct *must* match the vertex size of the buffer,
                so use with care.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.Array,System.Boolean)">
            <summary>
               Allows passing in a managed array of data to fill the vertex buffer.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="data">
                Array of data to blast into the buffer.  This can be an array of custom structs, that hold
                position, normal, etc data.  The size of the struct *must* match the vertex size of the buffer,
                so use with care.
            </param>
            <param name="discardWholeBuffer">
                If true, this allows the driver to discard the entire buffer when writing,
                such that DMA stalls can be avoided; use if you can.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.CopyData(Axiom.Graphics.HardwareBuffer,System.Int32,System.Int32,System.Int32)">
            <summary>
                Copy data from another buffer into this one.
            </summary>
            <param name="srcBuffer">The buffer from which to read the copied data.</param>
            <param name="srcOffset">Offset in the source buffer at which to start reading.</param>
            <param name="destOffset">Offset in the destination buffer to start writing.</param>
            <param name="length">Length of the data to copy, in bytes.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.CopyData(Axiom.Graphics.HardwareBuffer,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
                Copy data from another buffer into this one.
            </summary>
            <param name="srcBuffer">The buffer from which to read the copied data.</param>
            <param name="srcOffset">Offset in the source buffer at which to start reading.</param>
            <param name="destOffset">Offset in the destination buffer to start writing.</param>
            <param name="length">Length of the data to copy, in bytes.</param>
            <param name="discardWholeBuffer">If true, will discard the entire contents of this buffer before copying.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.UpdateFromShadow">
            <summary>
                Updates the real buffer from the shadow buffer, if required.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.SuppressHardwareUpdate(System.Boolean)">
            <summary>
                Pass true to suppress hardware upload of shadow buffer changes.
            </summary>
            <param name="suppress">If true, shadow buffer updates won't be uploaded to hardware.</param>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.IsLocked">
            <summary>
            	Gets whether or not this buffer is currently locked.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.IsSystemMemory">
            <summary>
            	Gets whether this buffer is held in system memory.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.Size">
            <summary>
            	Gets the size (in bytes) for this buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.Usage">
            <summary>
            	Gets the usage of this buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.HasShadowBuffer">
            <summary>
                Gets a bool that specifies whether this buffer has a software shadow buffer.
            </summary>
        </member>
        <member name="T:Axiom.Core.Viewport">
            <summary>
            	Summary description for Viewport.
            	An abstraction of a viewport, i.e. a rendering region on a render
            	target.
            </summary>
            <remarks>
            	A viewport is the meeting of a camera and a rendering surface -
            	the camera renders the scene from a viewpoint, and places its
            	results into some subset of a rendering target, which may be the
            	whole surface or just a part of the surface. Each viewport has a
            	single camera as source and a single target as destination. A
            	camera only has 1 viewport, but a render target may have several.
            	A viewport also has a Z-order, i.e. if there is more than one
            	viewport on a single render target and they overlap, one must
            	obscure the other in some predetermined way.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.#ctor(Axiom.Core.Camera,Axiom.Graphics.RenderTarget,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            	The constructor. Dimensions of the viewport are expressed as a pecentage between
            	0 and 100. This allows the dimensions to apply irrespective of
            	changes in the target's size: e.g. to fill the whole area,
            	values of 0,0,100,100 are appropriate.
            </summary>
            <param name="camera">Reference to the camera to be the source for the image.</param>
            <param name="target">Reference to the render target to be the destination for the rendering.</param>
            <param name="left">Left</param>
            <param name="top">Top</param>
            <param name="width">Width</param>
            <param name="height">Height</param>
            <param name="zOrder">Relative Z-order on the target. Lower = further to the front.</param>
        </member>
        <member name="M:Axiom.Core.Viewport.UpdateDimensions">
            <summary>
            	Notifies the viewport of a possible change in dimensions.
            </summary>
            <remarks>
            	Used by the target to update the viewport's dimensions
            	(usually the result of a change in target size).
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.SetClearEveryFrame(System.Boolean,Axiom.Graphics.FrameBufferType)">
            <summary>
            Determines whether to clear the viewport before rendering.
            </summary>
            <remarks>
            You can use this method to set which buffers are cleared
            (if any) before rendering every frame.
            </remarks>
            <param name="inClear">Whether or not to clear any buffers</param>
            <param name="inBuffers">
            One or more values from FrameBufferType denoting
            which buffers to clear, if clear is set to true. Note you should
            not clear the stencil buffer here unless you know what you're doing.
            </param>
        </member>
        <member name="M:Axiom.Core.Viewport.Update">
            <summary>
            	Instructs the viewport to updates its contents from the viewpoint of
            	the current camera.
            </summary>
        </member>
        <member name="M:Axiom.Core.Viewport.Clear(Axiom.Graphics.FrameBufferType,Axiom.Core.ColorEx,Axiom.Math.Real,System.UInt16)">
            <summary>
            Instructs the viewport to clear itself, without performing an update.
            </summary>
            <remarks>
            You would not normally call this method when updating the viewport, 
            since the viewport usually clears itself when updating anyway
            <see cref="P:Axiom.Core.Viewport.ClearEveryFrame"/>. However, if you wish you have the
            option of manually clearing the frame buffer (or elements of it)
            using this method.
            </remarks>
            <param name="buffers">Bitmask identifying which buffer elements to clear</param>
            <param name="col">The color value to clear to, if <see cref="F:Axiom.Graphics.FrameBufferType.Color"/> is included</param>
            <param name="depth">The depth value to clear to, if  <see cref="F:Axiom.Graphics.FrameBufferType.Depth"/> is included</param>
            <param name="stencil">The stencil value to clear to, if <see cref="F:Axiom.Graphics.FrameBufferType.Stencil"/> is included</param>
        </member>
        <member name="M:Axiom.Core.Viewport.SetDimensions(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Allows setting the dimensions of the viewport (after creation).
            </summary>
            <remarks>
            	Dimensions relative to the size of the target,
            	represented as real values between 0 and 1. i.e. the full
            	target area is 0, 0, 1, 1.
            </remarks>
            <param name="left">Left edge of the viewport ([0.0, 1.0]).</param>
            <param name="top">Top edge of the viewport ([0.0, 1.0]).</param>
            <param name="width">Width of the viewport ([0.0, 1.0]).</param>
            <param name="height">Height of the viewport ([0.0, 1.0]).</param>
        </member>
        <member name="M:Axiom.Core.Viewport.SetOrientationMode(Axiom.Core.OrientationMode,System.Boolean)">
            <summary>
            Set the orientation mode of the viewport.
            </summary>
        </member>
        <member name="M:Axiom.Core.Viewport.GetActualDimensions(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            	Access to actual dimensions (based on target size).
            </summary>
            <param name="left">Left edge of the viewport (in pixels).</param>
            <param name="top">Top edge of the viewport (in pixels).</param>
            <param name="width">Width of the viewport (in pixels).</param>
            <param name="height">Height of the viewport (in pixels).</param>
        </member>
        <member name="E:Axiom.Core.Viewport.ViewportCameraChanged">
            <summary>
            Notification of when a new camera is set to target listening Viewport.
            </summary>
        </member>
        <member name="E:Axiom.Core.Viewport.ViewportDimensionsChanged">
            <summary>
            Notification of when target listening Viewport's dimensions changed.
            </summary>
        </member>
        <member name="E:Axiom.Core.Viewport.ViewportDestroyed">
            <summary>
            Notification of when target listening Viewport's is destroyed.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Camera">
            <summary>
            	Retrieves a reference to the camera for this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Target">
            <summary>
            	Retrieves a reference to the render target for this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Top">
            <summary>
            Gets the relative top edge of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Left">
            <summary>
            Gets the relative left edge of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Width">
            <summary>
            	Gets the relative width of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Height">
            <summary>
            	Gets the relative height of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualTop">
            <summary>
            	Gets the actual top edge of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualLeft">
            <summary>
            	Gets the actual left edge of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualWidth">
            <summary>
            	Gets the actual width of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualHeight">
            <summary>
            	Gets the actual height of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ZOrder">
            <summary>
            	Gets the ZOrder of this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.IsAutoUpdated">
            <summary>
            Gets/Sets whether this viewport is automatically updated if 
            Axioms's rendering loop or <see cref="M:Axiom.Graphics.RenderTarget.Update(System.Boolean)"/> is being used.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.BackgroundColor">
            <summary>
            Gets/Sets the background color which will be used to clear the screen every frame.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.IsUpdated">
            <summary>
            	Gets/Sets the IsUpdated value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ShowOverlays">
            <summary>
            	Tells this viewport whether it should display Overlay objects.
            </summary>
            <remarks>
            	Overlay objects are layers which appear on top of the scene. They are created via
            	SceneManager.CreateOverlay and every viewport displays these by default.
            	However, you probably don't want this if you're using multiple viewports,
            	because one of them is probably a picture-in-picture which is not supposed to
            	have overlays of it's own. In this case you can turn off overlays on this viewport
            	by calling this method.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.ShowSkies">
            <summary>
            Tells this viewport whether it should display skies.
            </summary>
            <remarks>
            Skies are layers which appear on background of the scene. They are created via
            SceneManager.SetSkyBox, SceneManager.SetSkyPlane and SceneManager.SetSkyDome and
            every viewport displays these by default. However, you probably don't want this if
            you're using multiple viewports, because one of them is probably a picture-in-picture
            which is not supposed to have skies of it's own. In this case you can turn off skies
            on this viewport by calling this method.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.ShowShadows">
            <summary>
            Tells this viewport whether it should display shadows.
            </summary>
            <remarks>
            This setting enables you to disable shadow rendering for a given viewport. The global
            shadow technique set on SceneManager still controls the type and nature of shadows,
            but this flag can override the setting so that no shadows are rendered for a given
            viewport to save processing time where they are not required.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.MaterialScheme">
            <summary>
            the material scheme which the viewport should use.
            </summary>
            <remarks>
            This allows you to tell the system to use a particular
            material scheme when rendering this viewport, which can
            involve using different techniques to render your materials.
            <see>Technique.SchemeName</see>
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.VisibilityMask">
            <summary>
            a per-viewport visibility mask.
            </summary>
            <remarks>
            The visibility mask is a way to exclude objects from rendering for
            a given viewport. For each object in the frustum, a check is made
            between this mask and the objects visibility flags
            <see cref="P:Axiom.Core.MovableObject.VisibilityFlags"/> , and if a binary 'and'
            returns zero, the object will not be rendered.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.RenderQueueInvocationSequenceName">
            <summary>
            The name of the render queue invocation sequence for this target.
            </summary>
            <remarks>
            RenderQueueInvocationSequence instances are managed through Root. By
            setting this, you are indicating that you wish this RenderTarget to
            be updated using a custom sequence of render queue invocations, with
            potentially customised ordering and render state options. You should
            create the named sequence through Root first, then set the name here.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.RenderQueueInvocationSequence">
            <summary>
            the invocation sequence - will return null if using standard
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ClearDepth">
            <summary>
            Gets the default depth buffer value to which the viewport is cleared.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ClearEveryFrame">
            <summary>
            	Determines whether to clear the viewport before rendering.
            </summary>
            <remarks>
            	If you expecting every pixel on the viewport to be redrawn
            	every frame, you can save a little time by not clearing the
            	viewport before every frame. Do so by setting this property
            	to false.
            </remarks>
            
        </member>
        <member name="P:Axiom.Core.Viewport.ClearBuffers">
            <summary>
            Gets the buffers to clear every frame
            </summary>
        </member>
        <member name="T:Axiom.Core.Viewport.ViewportEventHandler">
            <summary>
               Delegate for Viewport update events.
            </summary>
        </member>
        <member name="T:Axiom.Core.Viewport.ViewportEventArgs">
            <summary>
               Event arguments for render target updates.
            </summary>
        </member>
        <member name="M:Axiom.Core.PlatformInformation.#cctor">
             <summary>
             Empty static constructor
             DO NOT DELETE.  It needs to be here because:
            
                 # The presence of a static constructor suppresses beforeFieldInit.
                 # Static field variables are initialized before the static constructor is called.
                 # Having a static constructor is the only way to ensure that all resources are
                   initialized before other static functions are called.
            
             (from "Static Constructors Demystified" by Satya Komatineni
              http://www.ondotnet.com/pub/a/dotnet/2003/07/07/staticxtor.html)
             </summary>
        </member>
        <member name="T:Axiom.Core.Entity">
            <summary>
               Defines an instance of a discrete, movable object based on a Mesh.
            </summary>
            <remarks>
            	Axiom generally divides renderable objects into 2 groups, discrete
            	(separate) and relatively small objects which move around the world,
            	and large, sprawling geometry which makes up generally immovable
            	scenery, aka 'level geometry'.
            	<para>
            	The <see cref="P:Axiom.Core.Entity.Mesh"/> and <see cref="T:Axiom.Core.SubMesh"/> classes deal with the definition of the geometry
            	used by discrete movable objects. Entities are actual instances of
            	objects based on this geometry in the world. Therefore there is
            	usually a single set <see cref="P:Axiom.Core.Entity.Mesh"/> for a car, but there may be multiple
            	entities based on it in the world. Entities are able to override
            	aspects of the Mesh it is defined by, such as changing material
            	properties per instance (so you can have many cars using the same
            	geometry but different textures for example). Because a <see cref="P:Axiom.Core.Entity.Mesh"/> is split
            	into a list of <see cref="T:Axiom.Core.SubMesh"/> objects for this purpose, the Entity class is a grouping class
            	(much like the <see cref="P:Axiom.Core.Entity.Mesh"/> class) and much of the detail regarding
            	individual changes is kept in the <see cref="T:Axiom.Core.SubEntity"/> class. There is a 1:1
            	relationship between <see cref="T:Axiom.Core.SubEntity"/> instances and the <see cref="T:Axiom.Core.SubMesh"/> instances
            	associated with the <see cref="P:Axiom.Core.Entity.Mesh"/> the Entity is based on.
            	</para>
            	<para>
            	Entity and <see cref="T:Axiom.Core.SubEntity"/> classes are never created directly.
            	Use <see cref="M:Axiom.Core.SceneManager.CreateEntity(System.String,System.String)"/> (passing a model name) to
            	create one.
            	</para>
            	<para>
            	Entities are included in the scene by using <see cref="M:Axiom.Core.SceneNode.AttachObject(Axiom.Core.MovableObject)"/>
            	to associate them with a scene node.
            	</para>
            </remarks>
        </member>
        <member name="T:Axiom.Core.MovableObject">
            <summary>
            	Abstract class defining a movable object in a scene.
            </summary>
            <remarks>
            	Instances of this class are discrete, relatively small, movable objects
            	which are attached to SceneNode objects to define their position.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.ShadowCaster">
            <summary>
            	This class defines the interface that must be implemented by shadow casters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetDarkCapBounds(Axiom.Core.Light,System.Single)">
            <summary>
            	Gets the world space bounding box of the dark cap, as extruded using the light provided.
            </summary>
            <param name="light"></param>
            <param name="dirLightExtrusionDist"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetEdgeList">
            <summary>
            	Gets details of the edges which might be used to determine a silhouette.
            </summary>
            <remarks>Defaults to LOD index 0.</remarks>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetEdgeList(System.Int32)">
            <summary>
            	Gets details of the edges which might be used to determine a silhouette.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetLightCapBounds">
            <summary>
            	Gets the world space bounding box of the light cap.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetWorldBoundingBox(System.Boolean)">
            <summary>
            	Get the world bounding box of the caster.
            </summary>
            <param name="derive"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetShadowVolumeRenderableEnumerator(Axiom.Graphics.ShadowTechnique,Axiom.Core.Light,Axiom.Graphics.HardwareIndexBuffer,System.Boolean,System.Single,System.Int32)">
            <summary>
            	Gets an iterator over the renderables required to render the shadow volume.
            </summary>
            <remarks>
            	Shadowable geometry should ideally be designed such that there is only one
            	ShadowRenderable required to render the the shadow; however this is not a necessary
            	limitation and it can be exceeded if required.
            </remarks>
            <param name="technique">The technique being used to generate the shadow.</param>
            <param name="light">The light to generate the shadow from.</param>
            <param name="indexBuffer">The index buffer to build the renderables into,
            the current contents are assumed to be disposable.</param>
            <param name="extrudeVertices">If true, this means this class should extrude
            the vertices of the back of the volume in software. If false, it
            will not be done (a vertex program is assumed).</param>
            <param name="extrusionDistance"></param>
            <param name="flags">Technique-specific flags, see <see cref="T:Axiom.Graphics.ShadowRenderableFlags"/></param>
            <returns>An iterator that will allow iteration over all renderables for the full shadow volume.</returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetLastShadowVolumeRenderableEnumerator">
            <summary>
            	Return the last calculated shadow renderables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.ExtrudeVertices(Axiom.Graphics.HardwareVertexBuffer,System.Int32,Axiom.Math.Vector4,System.Single)">
            <summary>
            	Utility method for extruding vertices based on a light.
            </summary>
            <remarks>
            	Unfortunately, because D3D cannot handle homogenous (4D) position
            	coordinates in the fixed-function pipeline (GL can, but we have to
            	be cross-API), when we extrude in software we cannot extrude to
            	infinity the way we do in the vertex program (by setting w to
            	0.0f). Therefore we extrude by a fixed distance, which may cause
            	some problems with larger scenes. Luckily better hardware (ie
            	vertex programs) can fix this.
            </remarks>
            <param name="vertexBuffer">The vertex buffer containing ONLY xyz position
            values, which must be originalVertexCount * 2 * 3 floats long.</param>
            <param name="originalVertexCount">The count of the original number of
            vertices, ie the number in the mesh, not counting the doubling
            which has already been done (by <see cref="M:Axiom.Graphics.VertexData.PrepareForShadowVolume"/>)
            to provide the extruded area of the buffer.</param>
            <param name="lightPosition"> 4D light position in object space, when w=0.0f this
            represents a directional light</param>
            <param name="extrudeDistance">The distance to extrude.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.UpdateEdgeListLightFacing(Axiom.Graphics.EdgeData,Axiom.Math.Vector4)">
            <summary>
            	Tells the caster to perform the tasks necessary to update the
            	edge data's light listing. Can be overridden if the subclass needs
            	to do additional things.
            </summary>
            <param name="edgeData">The edge information to update.</param>
            <param name="lightPosition">4D vector representing the light, a directional light has w=0.0.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GenerateShadowVolume(Axiom.Graphics.EdgeData,Axiom.Graphics.HardwareIndexBuffer,Axiom.Core.Light,Axiom.Graphics.Collections.ShadowRenderableList,System.Int32)">
            <summary>
            	Generates the indexes required to render a shadow volume into the
            	index buffer which is passed in, and updates shadow renderables to use it.
            </summary>
            <param name="edgeData">The edge information to use.</param>
            <param name="indexBuffer">The buffer into which to write data into; current
            contents are assumed to be discardable.</param>
            <param name="light">The light, mainly for type info as silhouette calculations
            should already have been done in <see cref="M:Axiom.Graphics.ShadowCaster.UpdateEdgeListLightFacing(Axiom.Graphics.EdgeData,Axiom.Math.Vector4)"/></param>
            <param name="shadowRenderables">A list of shadow renderables which has
            already been constructed but will need populating with details of
            the index ranges to be used.</param>
            <param name="flags">Additional controller flags, see <see cref="T:Axiom.Graphics.ShadowRenderableFlags"/>.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.ExtrudeBounds(Axiom.Math.AxisAlignedBox,Axiom.Math.Vector4,System.Single)">
            <summary>
            	Utility method for extruding a bounding box.
            </summary>
            <param name="box">Original bounding box, will be updated in-place.</param>
            <param name="lightPosition">4D light position in object space, when w=0.0f this
            represents a directional light</param>
            <param name="extrudeDistance">The distance to extrude.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetExtrusionDistance(Axiom.Math.Vector3,Axiom.Core.Light)">
            <summary>
            	Helper method for calculating extrusion distance.
            </summary>
            <param name="objectPos"></param>
            <param name="light"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetPointExtrusionDistance(Axiom.Core.Light)">
            <summary>
            	Get the distance to extrude for a point/spot light.
            </summary>
            <param name="light"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.ShadowCaster.CastShadows">
            <summary>
            	Gets/Sets whether or not this object currently casts a shadow.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.castShadows">
            <summary>
            	Does this object cast shadows?
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.isVisible">
            <summary>
               Is this object visible?
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.name">
            <summary>
               Name of this object.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.debugDisplay">
            Is debug display enabled?
        </member>
        <member name="F:Axiom.Core.MovableObject.upperDistance">
            Upper distance to still render
        </member>
        <member name="F:Axiom.Core.MovableObject.beyondFarDistance">
            Hidden because of distance?
        </member>
        <member name="F:Axiom.Core.MovableObject.renderingDisabled">
            Does rendering this object disabled by listener?
        </member>
        <member name="F:Axiom.Core.MovableObject.lightListUpdated">
            The last frame that this light list was updated in
        </member>
        <member name="F:Axiom.Core.MovableObject.parentIsTagPoint">
            <summary>
            	Flag which indicates whether this objects parent is a <see cref="T:Axiom.Animating.TagPoint"/>.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.parentNode">
            <summary>
               Node that this node is attached to.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.renderQueueID">
            <summary>
               The render queue to use when rendering this object.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.renderQueueIDSet">
            <summary>
               Flags whether the RenderQueue's default should be used.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.userData">
            <summary>
               A link back to a GameObject (or subclass thereof) that may be associated with this SceneObject.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.worldAABB">
            <summary>
               Cached world bounding box of this object.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.worldBoundingSphere">
            <summary>
               Cached world bounding spehere.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.worldDarkCapBounds">
            <summary>
            	World space AABB of this object's dark cap.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.DetachFromParent">
            <summary>
            Detaches an object from a parent SceneNode or TagPoint, if attached.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetWorldBoundingBox(System.Boolean)">
            <summary>
               Retrieves the axis-aligned bounding box for this object in world coordinates.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetWorldBoundingSphere">
            <summary>
               Overloaded method.  Calls the overload with a default of not deriving the transform.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetWorldBoundingSphere(System.Boolean)">
            <summary>
               Retrieves the worldspace bounding sphere for this object.
            </summary>
            <param name="derive">Whether or not to derive from parent transforms.</param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Core.MovableObject.queryFlags">
            <summary>
               Flags determining whether this object is included/excluded from scene queries.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.defaultQueryFlags">
            <summary>
            default query flags for all future MovableObject instances.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.AddQueryFlags(System.UInt32)">
            <summary>
            	Appends the specified flags to the current flags for this object.
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Core.MovableObject.RemoveQueryFlags(System.UInt32)">
            <summary>
            	Removes the specified flags from the current flags for this object.
            </summary>
            <param name="flags"></param>
        </member>
        <member name="F:Axiom.Core.MovableObject.visibilityFlags">
            <summary>
            Flags determining whether this object is visible (compared to SceneManager mask)
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.defaultVisibilityFlags">
            <summary>
            default visibility flags for all future MovableObject instances.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.AddVisibilityFlags(System.UInt32)">
            <summary>
            	Appends the specified flags to the current flags for this object.
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Core.MovableObject.RemoveVisibilityFlags(System.UInt32)">
            <summary>
            	Removes the specified flags from the current flags for this object.
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetDarkCapBounds(Axiom.Core.Light,System.Single)">
             <summary>
            
             </summary>
             <param name="light"></param>
             <param name="extrusionDistance"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetEdgeList(System.Int32)">
            <summary>
            	Overridden.  Returns null by default.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetPointExtrusionDistance(Axiom.Core.Light)">
            <summary>
            	Get the distance to extrude for a point/spot light
            </summary>
            <param name="light"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.CreateAnimableValue(System.String)">
            <summary>
                Part of the IAnimableObject interface.
            	Create an AnimableValue for the attribute with the given name, or
                throws an exception if this object doesn't support creating them.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="M:Axiom.Core.MovableObject.NotifyAttached(Axiom.Core.Node)">
            <summary>
            	Internal method called to notify the object that it has been attached to a node.
            </summary>
            <param name="node">Scene node to notify.</param>
        </member>
        <member name="M:Axiom.Core.MovableObject.NotifyAttached(Axiom.Core.Node,System.Boolean)">
             <summary>
            		Internal method called to notify the object that it has been attached to a node.
             </summary>
             <param name="node">Scene node to notify.</param>
            <param name="isTagPoint"></param>
        </member>
        <member name="M:Axiom.Core.MovableObject.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            	Internal method to notify the object of the camera to be used for the next rendering operation.
            </summary>
            <remarks>
            	Certain objects may want to do specific processing based on the camera position. This method notifies
            	them incase they wish to do this.
            </remarks>
            <param name="camera">Reference to the Camera being used for the current rendering operation.</param>
        </member>
        <member name="M:Axiom.Core.MovableObject.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            An abstract method that causes the specified RenderQueue to update itself.
            </summary>
            <remarks>This is an internal method used by the engine assembly only.</remarks>
            <param name="queue">The render queue that this object should be updated in.</param>
        </member>
        <member name="P:Axiom.Core.MovableObject.BoundingBox">
            <summary>
            	An abstract method required by subclasses to return the bounding box of this object in local coordinates.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.BoundingRadius">
            <summary>
            	An abstract method required by subclasses to return the bounding box of this object in local coordinates.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.UserData">
            <summary>
                Get/Sets a link back to a GameObject (or subclass thereof, such as Entity) that may be associated with this SceneObject.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.ParentNode">
            <summary>
            	Gets the parent node that this object is attached to.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.IsAttached">
            <summary>
            	See if this object is attached to another node.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.IsVisible">
            <summary>
            	States whether or not this object should be visible.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.Name">
            <summary>
            	Name of this SceneObject.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.ParentNodeFullTransform">
            <summary>
            	Gets the full transformation of the parent SceneNode or TagPoint.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.TypeFlags">
            <summary>
            Get the 'type flags' for this MovableObject.
            </summary>
            <remarks>
            A type flag identifies the type of the MovableObject as a bitpattern.
            This is used for categorical inclusion / exclusion in SceneQuery
            objects. By default, this method returns all ones for objects not
            created by a MovableObjectFactory (hence always including them);
            otherwise it returns the value assigned to the MovableObjectFactory.
            Custom objects which don't use MovableObjectFactory will need to
            override this if they want to be included in queries.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.ShowBoundingBox">
            <summary>
               Allows showing the bounding box of an individual SceneObject.
            </summary>
            <remarks>
               This shows the bounding box of the SceneNode that the SceneObject is currently attached to.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.RenderQueueGroup">
            <summary>
            	Gets/Sets the render queue group this entity will be rendered through.
            </summary>
            <remarks>
            	Render queues are grouped to allow you to more tightly control the ordering
            	of rendered objects. If you do not call this method, all Entity objects default
            	to <see cref="F:Axiom.Core.RenderQueueGroupID.Main"/> which is fine for most objects. You may want to alter this
            	if you want this entity to always appear in front of other objects, e.g. for
            	a 3D menu system or such.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.IsInScene">
            <summary>
            Returns true if this object is attached to a SceneNode or TagPoint,
            and this SceneNode / TagPoint is currently in an active part of the
            scene graph.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.RenderingDistance">
            <summary>
            Gets/Sets the distance at which the object is no longer rendered.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.DefaultQueryFlags">
            <summary>
            Gets/Sets default query flags for all future MovableObject instances.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.QueryFlags">
            <summary>
            	Gets/Sets the query flags for this object.
            </summary>
            <remarks>
            	When performing a scene query, this object will be included or excluded according
            	to flags on the object and flags on the query. This is a bitwise value, so only when
            	a bit on these flags is set, will it be included in a query asking for that flag. The
            	meaning of the bits is application-specific.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.DefaultVisibilityFlags">
            <summary>
            Gets/Sets default visibility flags for all future MovableObject instances.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.VisibilityFlags">
            <summary>
            Gets/Sets the visibility flags for this object.
            </summary>
            <remarks>
            As well as a simple true/false value for visibility (as seen in <see cref="P:Axiom.Core.MovableObject.IsVisible"/>),
            you can also set visiblity flags which when 'and'ed with the SceneManager's
            visibility mask can also make an object invisible.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.CastShadows">
            <summary>
            	Overridden.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.DebugDisplayEnabled">
            <summary>
            Gets/Sets whether or not the debug display of this object is enabled.
            <remarks>
            Some objects aren't visible themselves but it can be useful to display
            a debug representation of them. Or, objects may have an additional
            debug display on top of their regular display. This option enables /
            disables that debug display. Objects that are not visible never display
            debug geometry regardless of this setting.
            </remarks>
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.AnimableValueNames">
            <summary>
                Part of the IAnimableObject interface.
            	The implementation of this property just returns null; descendents
                are free to override this.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.IsDisposed">
            <summary>
            Determines if this instance has been disposed of already.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.Creator">
            <summary>
                Notify the object of it's creator (internal use only).
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.Manager">
            <summary>
                Notify the object of it's manager (internal use only).
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.MovableType">
            <summary>
            Gets the MovableType for this MovableObject.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.animationState">
            <summary>
               State of animation for animable meshes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.boneMatrices">
            <summary>
               Cached bone matrices, including and world transforms.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.childObjectList">
            <summary>
            	List of child objects attached to this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.displaySkeleton">
            <summary>
               Flag that determines whether or not to display skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.frameAnimationLastUpdated">
            <summary>
            	Records the last frame in which animation was updated.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.frameBonesLastUpdated">
            <summary>
                Frame the bones were last update.
            </summary>
            <remarks>
                Stored as an array so the reference can be shared amongst skeleton instances.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Entity.fullBoundingBox">
            <summary>
               Bounding box that 'contains' all the meshes of each child entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.hardwareAnimation">
            <summary>
                Flag indicating whether hardware animation is supported by this entities materials
            </summary>
            <remarks>
                Because fixed-function indexed vertex blending is rarely supported
                by existing graphics cards, hardware animation can only be done if
                the vertex programs in the materials used to render an entity support
                it. Therefore, this method will only return true if all the materials
                assigned to this entity have vertex programs assigned, and all those
                vertex programs must support 'includes_morph_animation true' if using
                morph animation, 'includes_pose_animation true' if using pose animation
                and 'includes_skeletal_animation true' if using skeletal animation.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Entity.hardwarePoseCount">
            <summary>
                Number of hardware poses supported by materials
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.hardwareVertexAnimVertexData">
            <summary>
                Vertex data details for hardware vertex anim of shared geometry
                - separate since we need to s/w anim for shadows whilst still altering
                the vertex data for hardware morphing (pos2 binding)
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.lastParentXform">
            <summary>
            	The most recent parent transform applied during animation
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.materialName">
            <summary>
               Name of the material to be used for this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.mesh">
            <summary>
               3D Mesh that represents this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.numBoneMatrices">
            <summary>
               Number of matrices associated with this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.shadowRenderables">
            <summary>
            	List of shadow renderables for this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.skelAnimVertexData">
            <summary>
                Vertex data details for software skeletal anim of shared geometry
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.skeletonInstance">
            <summary>
            	This entity's personal copy of a master skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.sharedSkeletonInstances">
            <summary>
            List of Entities that this entity shares it's skeleton with
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.softwareAnimationNormalsRequests">
            <summary>
                Counter indicating number of requests for software blended normals.
            </summary>
            <remarks>
                If non-zero, and getSoftwareAnimationRequests() also returns non-zero,
                then software animation of normals will be performed in updateAnimation
                regardless of the current setting of isHardwareAnimationEnabled or any
                internal optimise for eliminate software animation. Currently it is not
                possible to force software animation of only normals. Consequently this
                value is always less than or equal to that returned by getSoftwareAnimationRequests().
                Requests for software animation of normals are made by calling the
                addSoftwareAnimationRequest() method with 'true' as the parameter.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Entity.softwareAnimationRequests">
            <summary>
                Counter indicating number of requests for software animation.
            </summary>
            <remarks>
               If non-zero then software animation will be performed in updateAnimation
               regardless of the current setting of isHardwareAnimationEnabled or any
               internal optimise for eliminate software animation. Requests for software
               animation are made by calling the AddSoftwareAnimationRequest() method.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Entity.softwareVertexAnimVertexData">
            <summary>
                Vertex data details for software vertex anim of shared geometry
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.subEntityList">
            <summary>
               List of sub entities.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.tempSkelAnimInfo">
            <summary>
            	Temp blend buffer details for shared geometry.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.tempVertexAnimInfo">
            Data for vertex animation
            <summary>
                Temp buffer details for software vertex anim of shared geometry
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.vertexAnimationAppliedThisFrame">
            <summary>
                Have we applied any vertex animation to shared geometry?
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.#ctor(System.String,Axiom.Core.Mesh)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject)">
            <summary>
            	Attaches another object to a certain bone of the skeleton which this entity uses.
            </summary>
            <remarks>
            	This method can be used to attach another object to an animated part of this entity,
            	by attaching it to a bone in the skeleton (with an offset if required). As this entity
            	is animated, the attached object will move relative to the bone to which it is attached.
            </remarks>
            <param name="boneName">The name of the bone (in the skeleton) to attach this object.</param>
            <param name="sceneObject">Reference to the object to attach.</param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject,Axiom.Math.Quaternion)">
            <summary>
            	Attaches another object to a certain bone of the skeleton which this entity uses.
            </summary>
            <param name="boneName">The name of the bone (in the skeleton) to attach this object.</param>
            <param name="sceneObject">Reference to the object to attach.</param>
            <param name="offsetOrientation">An adjustment to the orientation of the attached object, relative to the bone.</param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            	Attaches another object to a certain bone of the skeleton which this entity uses.
            </summary>
            <param name="boneName">The name of the bone (in the skeleton) to attach this object.</param>
            <param name="sceneObject">Reference to the object to attach.</param>
            <param name="offsetOrientation">An adjustment to the orientation of the attached object, relative to the bone.</param>
            <param name="offsetPosition">An adjustment to the position of the attached object, relative to the bone.</param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectImpl(Axiom.Core.MovableObject,Axiom.Animating.TagPoint)">
            <summary>
            	Internal implementation of attaching a 'child' object to this entity and assign
            	the parent node to the child entity.
            </summary>
            <param name="sceneObject">Object to attach.</param>
            <param name="tagPoint">TagPoint to attach the object to.</param>
        </member>
        <member name="M:Axiom.Core.Entity.DetachObjectFromBone(Axiom.Core.MovableObject)">
            <summary>
            Detaches an object by reference.
            </summary>
            <param name="obj"></param>
            <remarks>
            Use this method to destroy a MovableObject which is attached to a bone of belonging this entity.
            But sometimes the object may be not in the child object list because it is a lod entity,
            this method can safely detect and ignore in this case and won't raise an exception.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Entity.DetachObjectImpl(Axiom.Core.MovableObject)">
            <summary>
            	Internal implementation of detaching a 'child' object from this entity and
            	clearing the assignment of the parent node to the child entity.
            </summary>
            <param name="pObject">Object to detach.</param>
        </member>
        <member name="M:Axiom.Core.Entity.NotifyAttached(Axiom.Core.Node,System.Boolean)">
            <summary>
            	Internal method called to notify the object that it has been attached to a node.
            </summary>
            <param name="node">Scene node to which we are being attached.</param>
            <param name="isTagPoint"></param>
        </member>
        <member name="M:Axiom.Core.Entity.BuildSubEntities">
            <summary>
            	Used to build a list of sub-entities from the meshes located in the mesh.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.CacheBoneMatrices">
            <summary>
               Protected method to cache bone matrices from a skeleton.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.FindBlendedVertexData(Axiom.Graphics.VertexData)">
            <summary>
            	Internal method - given vertex data which could be from the <see cref="P:Axiom.Core.Entity.Mesh"/> or
            	any <see cref="T:Axiom.Core.SubMesh"/>, finds the temporary blend copy.
            </summary>
            <param name="originalData"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.FindSubEntityForVertexData(Axiom.Graphics.VertexData)">
            <summary>
            	Internal method - given vertex data which could be from the	Mesh or
            	any SubMesh, finds the corresponding SubEntity.
            </summary>
            <param name="original"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.UpdateAnimation">
            <summary>
            	Perform all the updates required for an animated entity.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.InitHardwareAnimationElements(Axiom.Graphics.VertexData,System.UInt16)">
            <summary>
                Initialize the hardware animation elements for given vertex data
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.ApplyVertexAnimation(System.Boolean,System.Boolean)">
            <summary>
                Apply vertex animation
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.MarkBuffersUnusedForAnimation">
            <summary>
                Mark all vertex data as so far unanimated.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.MarkBuffersUsedForAnimation">
            <summary>
                Mark just this vertex data as animated.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.RestoreBuffersForUnusedAnimation(System.Boolean)">
            <summary>
                Internal method to restore original vertex data where we didn't
                perform any vertex animation this frame.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.GetAllAnimationStates">
            <summary>
               For entities based on animated meshes, gets the AnimationState object for a single animation.
            </summary>
            <remarks>
               You animate an entity by updating the animation state objects. Each of these represents the
               current state of each animation available to the entity. The AnimationState objects are
               initialized from the Mesh object.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.GetAnimationState(System.String)">
            <summary>
               For entities based on animated meshes, gets the AnimationState object for a single animation.
            </summary>
            <remarks>
               You animate an entity by updating the animation state objects. Each of these represents the
               current state of each animation available to the entity. The AnimationState objects are
               initialized from the Mesh object.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Core.Entity.usingManualLod">
            <summary>
            Flag indicating that mesh uses manual LOD and so might have multiple SubEntity versions.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.lodEntityList">
            <summary>
            List of entities with various levels of detail.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.materialLodFactor">
            <summary>
            LOD bias factor
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.materialLodFactorTransformed">
            <summary>
            LOD bias factor, transformed for optimisation when calculating adjusted lod value
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.minMaterialLodIndex">
            <summary>
            Index of minimum detail LOD (NB higher index is lower detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.maxMaterialLodIndex">
            <summary>
            Index of maximum detail LOD (NB lower index is higher detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.meshLodIndex">
            <summary>
               The LOD number of the mesh to use, calculated by NotifyCurrentCamera.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.meshLodFactorTransformed">
            <summary>
               LOD bias factor, inverted for optimization when calculating adjusted depth.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.minMeshLodIndex">
            <summary>
               Index of minimum detail LOD (higher index is lower detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.maxMeshLodIndex">
            <summary>
               Index of maximum detail LOD (lower index is higher detail).
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.SetMaterialLodBias(Axiom.Math.Real,System.Int32,System.Int32)">
            <summary>
               Sets a level-of-detail bias for the material detail of this entity.
            </summary>
            <remarks>
               Level of detail reduction is normally applied automatically based on the Material
               settings. However, it is possible to influence this behavior for this entity
               by adjusting the LOD bias. This 'nudges' the material level of detail used for this
               entity up or down depending on your requirements. You might want to use this
               if there was a particularly important entity in your scene which you wanted to
               detail better than the others, such as a player model.
               <p/>
               There are three parameters to this method; the first is a factor to apply; it
               defaults to 1.0 (no change), by increasing this to say 2.0, this model would
               take twice as long to reduce in detail, whilst at 0.5 this entity would use lower
               detail versions twice as quickly. The other 2 parameters are hard limits which
               let you set the maximum and minimum level-of-detail version to use, after all
               other calculations have been made. This lets you say that this entity should
               never be simplified, or that it can only use LODs below a certain level even
               when right next to the camera.
            </remarks>
            <param name="factor">Proportional factor to apply to the distance at which LOD is changed.
               Higher values increase the distance at which higher LODs are displayed (2.0 is
               twice the normal distance, 0.5 is half).</param>
            <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower
               indexes are higher detail: index 0 is the original full detail model).</param>
            <param name="minDetailIndex">The index of the minimum LOD this entity is allowed to use (higher
               indexes are lower detail. Use something like 99 if you want unlimited LODs (the actual
               LOD will be limited by the number in the material)</param>
        </member>
        <member name="M:Axiom.Core.Entity.SetMeshLodBias(System.Single,System.Int32,System.Int32)">
            <summary>
               Sets a level-of-detail bias on this entity.
            </summary>
            <remarks>
               Level of detail reduction is normally applied automatically based on the Mesh
               settings. However, it is possible to influence this behavior for this entity
               by adjusting the LOD bias. This 'nudges' the level of detail used for this
               entity up or down depending on your requirements. You might want to use this
               if there was a particularly important entity in your scene which you wanted to
               detail better than the others, such as a player model.
               <p/>
               There are three parameters to this method; the first is a factor to apply; it
               defaults to 1.0 (no change), by increasing this to say 2.0, this model would
               take twice as long to reduce in detail, whilst at 0.5 this entity would use lower
               detail versions twice as quickly. The other 2 parameters are hard limits which
               let you set the maximum and minimum level-of-detail version to use, after all
               other calculations have been made. This lets you say that this entity should
               never be simplified, or that it can only use LODs below a certain level even
               when right next to the camera.
            </remarks>
            <param name="factor">Proportional factor to apply to the distance at which LOD is changed.
               Higher values increase the distance at which higher LODs are displayed (2.0 is
               twice the normal distance, 0.5 is half).</param>
            <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower
               indexes are higher detail: index 0 is the original full detail model).</param>
            <param name="minDetailIndex">The index of the minimum LOD this entity is allowed to use (higher
               indexes are lower detail. Use something like 99 if you want unlimited LODs (the actual
               LOD will be limited by the number in the Mesh)</param>
        </member>
        <member name="M:Axiom.Core.Entity.GetManualLodLevel(System.Int32)">
            <summary>
            Gets a reference to the entity representing the numbered manual level of detail.
            </summary>
            <remarks>
            The zero-based index never includes the original entity, unlike <see name="Mesh.GetLodLevel"/>.
            </remarks>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
             <summary>
            
             </summary>
             <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.Entity.PrepareTempBlendedBuffers">
            <summary>
            	Internal method for preparing this Entity for use in animation.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.CloneVertexDataRemoveBlendInfo(Axiom.Graphics.VertexData)">
            <summary>
            	Internal method to clone vertex data definitions but to remove blend buffers.
            </summary>
            <param name="source">Vertex data to clone.</param>
            <returns>A cloned instance of 'source' without blending information.</returns>
        </member>
        <member name="M:Axiom.Core.Entity.ExtractTempBufferInfo(Axiom.Graphics.VertexData,Axiom.Graphics.TempBlendedBufferInfo)">
            <summary>
            	Internal method for extracting metadata out of source vertex data
            	for fast assignment of temporary buffers later.
            </summary>
            <param name="sourceData"></param>
            <param name="info"></param>
        </member>
        <member name="M:Axiom.Core.Entity.GetSubEntity(System.Int32)">
            <summary>
               Gets the SubEntity at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.ReevaluateVertexProcessing">
            <summary>
            	Trigger an evaluation of whether hardware skinning is supported for this entity.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.CopyAnimationStateSubset(Axiom.Animating.AnimationStateSet,Axiom.Animating.AnimationStateSet)">
            <summary>
                Copies a subset of animation states from source to target.
            </summary>
            <remarks>
                This routine assume target is a subset of source, it will copy all animation state
                of the target with the settings from source.
            </remarks>
            <param name="target">Reference to animation state set which will receive the states.</param>
            <param name="source">Reference to animation state set which will use as source.</param>
        </member>
        <member name="M:Axiom.Core.Entity.Clone(System.String)">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.BoneMatrixCount">
            <summary>
            	Gets the number of bone matrices for this entity if it has a skeleton attached.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.BoundingBox">
            <summary>
            	Gets the full local bounding box of this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.BoundingRadius">
            <summary>
               Local bounding radius of this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.ChildObjectsBoundingBox">
            <summary>
               Merge all the child object Bounds and return it.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Entity.DisplaySkeleton">
            <summary>
               Gets/Sets the flag to render the skeleton of this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.HasSkeleton">
            <summary>
            	Returns true if this entity has a skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.Mesh">
            <summary>
            	Gets the 3D mesh associated with this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.MaterialName">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Entity.SubEntityCount">
            <summary>
               Gets the number of sub entities that belong to this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.SoftwareVertexAnimVertexData">
            <summary>
               Advanced method to get the temporarily blended software vertex animation information
            </summary>
            <remarks>
                Internal engine will eliminate software animation if possible, this
                information is unreliable unless added request for software animation
                via addSoftwareAnimationRequest.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Entity.HardwareVertexAnimVertexData">
            <summary>
               Advanced method to get the hardware morph vertex information
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.BuffersMarkedForAnimation">
            <summary>
            	Are buffers already marked as vertex animated?
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.IsHardwareAnimationEnabled">
            <summary>
            	Is hardware animation enabled for this entity?
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.MeshLodIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Entity.TypeFlags">
            <summary>
            Get the 'type flags' for this <see cref="T:Axiom.Core.Entity"/>.
            </summary>
            <seealso cref="P:Axiom.Core.MovableObject.TypeFlags"/>
        </member>
        <member name="T:Axiom.Core.Entity.EntityShadowRenderable">
            <summary>
            	Nested class to allow entity shadows.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowRenderable">
            <summary>
            	Class which represents the renderable aspects of a set of shadow volume faces.
            </summary>
            <remarks>
            	Note that for casters comprised of more than one set of vertex buffers (e.g. SubMeshes each
            	using their own geometry), it will take more than one <see cref="T:Axiom.Graphics.ShadowRenderable"/> to render the
            	shadow volume. Therefore for shadow caster geometry, it is best to stick to one set of
            	vertex buffers (not necessarily one buffer, but the positions for the entire geometry
            	should come from one buffer if possible)
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.IRenderable">
            <summary>
            	Interface defining the interface all renderable objects must implement.
            </summary>
            <remarks>
            	This interface abstracts renderable discrete objects which will be queued in the render pipeline,
            	grouped by material. Classes implementing this interface must be based on a single material, a single
            	world matrix (or a collection of world matrices which are blended by weights), and must be
            	renderable via a single render operation.
            	<p/>
            	Note that deciding whether to put these objects in the rendering pipeline is done from the more specific
            	classes e.g. entities. Only once it is decided that the specific class is to be rendered is the abstract version
            	created (could be more than one per visible object) and pushed onto the rendering queue.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
               Gets the world transform matrix / matrices for this renderable object.
            </summary>
            <remarks>
               If the object has any derived transforms, these are expected to be up to date as long as
               all the SceneNode structures have been updated before this is called.
             <p/>
               This method will populate xform with 1 matrix if it does not use vertex blending. If it
               does use vertex blending it will fill the passed in pointer with an array of matrices,
               the length being the value returned from getNumWorldTransforms.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            	Returns the camera-relative squared depth of this renderable.
            </summary>
            <remarks>
            	Used to sort transparent objects. Squared depth is used rather than
            	actual depth to avoid having to perform a square root on the result.
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetCustomParameter(System.Int32)">
            <summary>
            	Gets the custom value associated with this Renderable at the given index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.SetCustomParameter(System.Int32,Axiom.Math.Vector4)">
            <summary>
            	Sets a custom parameter for this Renderable, which may be used to
            	drive calculations for this specific Renderable, like GPU program parameters.
            </summary>
            <remarks>
            	Calling this method simply associates a numeric index with a 4-dimensional
            	value for this specific Renderable. This is most useful if the material
            	which this Renderable uses a vertex or fragment program, and has an
            	AutoConstant.Custom parameter entry. This parameter entry can refer to the
            	index you specify as part of this call, thereby mapping a custom
            	parameter for this renderable to a program parameter.
            </remarks>
            <param name="index">
            	The index with which to associate the value. Note that this
            	does not have to start at 0, and can include gaps. It also has no direct
            	correlation with a GPU program parameter index - the mapping between the
            	two is performed by the AutoConstant.Custom entry, if that is used.
            </param>
            <param name="val">The value to associate.</param>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.UpdateCustomGpuParameter(Axiom.Graphics.GpuProgramParameters.AutoConstantEntry,Axiom.Graphics.GpuProgramParameters)">
            <summary>
            	Update a custom GpuProgramParameters constant which is derived from
            	information only this Renderable knows.
            </summary>
            <remarks>
            	This method allows a Renderable to map in a custom GPU program parameter
            	based on it's own data. This is represented by a GPU auto parameter
            	of AutoConstantType.Custom, and to allow there to be more than one of these per
            	Renderable, the 'data' field on the auto parameter will identify
            	which parameter is being updated. The implementation of this method
            	must identify the parameter being updated, and call a 'SetConstant'
            	method on the passed in <see cref="T:Axiom.Graphics.GpuProgramParameters"/> object, using the details
            	provided in the incoming auto constant setting to identify the index
            	at which to set the parameter.
            </remarks>
            <param name="constant">The auto constant entry referring to the parameter being updated.</param>
            <param name="parameters">The parameters object which this method should call to set the updated parameters.</param>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.CastsShadows">
            <summary>
            	Gets whether this renderable would normally cast a shadow.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.Material">
            <summary>
               Get the material associated with this renderable object.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.Technique">
            <summary>
               Technique being used to render this object according to the current hardware.
            </summary>
            <remarks>
               This is to allow Renderables to use a chosen Technique if they wish, otherwise
               they will use the best Technique available for the Material they are using.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.RenderOperation">
            <summary>
               Gets the render operation required to send this object to the frame buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.Lights">
            <summary>
               Gets a list of lights, ordered relative to how close they are to this renderable.
            </summary>
            <remarks>
               Directional lights, which have no position, will always be first on this list.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.NormalizeNormals">
            <summary>
               Returns whether or not this Renderable wishes the hardware to normalize normals.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.NumWorldTransforms">
            <summary>
               Gets the number of world transformations that will be used for this object.
            </summary>
            <remarks>
               When a renderable uses vertex blending, it uses multiple world matrices instead of a single
               one. Each vertex sent to the pipeline can reference one or more matrices in this list
               with given weights.
               If a renderable does not use vertex blending this method returns 1, which is the default for
               simplicity.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.UseIdentityProjection">
            <summary>
               Returns whether or not to use an 'identity' projection.
            </summary>
            <remarks>
               Usually IRenderable objects will use a projection matrix as determined
               by the active camera. However, if they want they can cancel this out
               and use an identity projection, which effectively projects in 2D using
               a {-1, 1} view space. Useful for overlay rendering. Normal renderables need
               not override this.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.UseIdentityView">
            <summary>
               Returns whether or not to use an 'identity' projection.
            </summary>
            <remarks>
               Usually IRenderable objects will use a view matrix as determined
               by the active camera. However, if they want they can cancel this out
               and use an identity matrix, which means all geometry is assumed
               to be relative to camera space already. Useful for overlay rendering.
               Normal renderables need not override this.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.PolygonModeOverrideable">
            <summary>
            Gets whether this renderable's chosen detail level can be
            overridden (downgraded) by the camera setting.
            override true means that a lower camera detail will override this
            renderables detail level, false means it won't.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.WorldOrientation">
            <summary>
               Gets the worldspace orientation of this renderable; this is used in order to
               more efficiently update parameters to vertex &amp; fragment programs, since inverting Quaterion
               and Vector in order to derive object-space positions / directions for cameras and
               lights is much more efficient than inverting a complete 4x4 matrix, and also
               eliminates problems introduced by scaling.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.WorldPosition">
            <summary>
               Gets the worldspace position of this renderable; this is used in order to
               more efficiently update parameters to vertex &amp; fragment programs, since inverting Quaterion
               and Vector in order to derive object-space positions / directions for cameras and
               lights is much more efficient than inverting a complete 4x4 matrix, and also
               eliminates problems introduced by scaling.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderable.lightCap">
            <summary>
            	Used only if IsLightCapSeparate == true.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowRenderable.GetRenderOperationForUpdate">
            <summary>
            	Gets the internal render operation for setup.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowRenderable.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.IsLightCapSeperate">
            <summary>
            	Does this renderable require a separate light cap?
            </summary>
            <remarks>
            	If possible, the light cap (when required) should be contained in the
            	usual geometry of the shadow renderable. However, if for some reason
            	the normal depth function (less than) could cause artefacts, then a
            	separate light cap with a depth function of 'always fail' can be used
            	instead. The primary example of this is when there are floating point
            	inaccuracies caused by calculating the shadow geometry separately from
            	the real geometry.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.LightCapRenderable">
            <summary>
            	Get the light cap version of this renderable.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.IsVisible">
            <summary>
            	Should this ShadowRenderable be treated as visible?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.Material">
            <summary>
            	Gets/Sets the material to use for this shadow renderable.
            </summary>
            <remarks>
            	Should be set by the caller before adding to a render queue.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.RenderOperation">
            <summary>
            	Gets the render operation for this shadow renderable.
            </summary>
            <param name="value"></param>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.currentVertexData">
            <summary>
            	Link to current vertex data used to bind (maybe changes)
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.originalPosBufferBinding">
            <summary>
            	Original position buffer source binding.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.positionBuffer">
            <summary>
            	Shared ref to the position buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.subEntity">
            <summary>
            	Link to SubEntity, only present if SubEntity has it's own geometry.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.wBuffer">
            <summary>
            	Shared ref to w-coord buffer (optional).
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.EntityShadowRenderable.RebindPositionBuffer(Axiom.Graphics.VertexData,System.Boolean)">
            <summary>
            	Rebind the source positions for temp buffer users.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.EntityShadowRenderable.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="P:Axiom.Core.Entity.EntityShadowRenderable.PositionBuffer">
            <summary>
            	Gets a reference to the position buffer in use by this renderable.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.EntityShadowRenderable.WBuffer">
            <summary>
            	Gets a reference to the w-buffer in use by this renderable.
            </summary>
        </member>
        <member name="T:Axiom.Core.AbstractFactory`1">
            <summary>
            Abstract factory class implementation. Provides a basic Factory
            implementation that can be overriden by derivitives
            </summary>
            <typeparam name="T">The Type to instantiate</typeparam>
        </member>
        <member name="T:Axiom.Core.IAbstractFactory`1">
            <summary>
            Abstract factory class. Does nothing by itself, but derived classes can add functionality.
            </summary>
            <typeparam name="T"></typeparam>
            <ogre name="FactoryObj">
                <file name="OgreFactoryObj.h"   revision="1.10" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre>
        </member>
        <member name="M:Axiom.Core.IAbstractFactory`1.CreateInstance(System.String)">
            <summary>
            Creates a new object.
            </summary>
            <param name="name">Name of the object to create</param>
            <returns>
            An object created by the factory. The type of the object depends on
            the factory.
            </returns>
        </member>
        <member name="M:Axiom.Core.IAbstractFactory`1.DestroyInstance(`0@)">
            <summary>
            Destroys an object which was created by this factory.
            </summary>
            <param name="obj">the object to destroy</param>
        </member>
        <member name="P:Axiom.Core.IAbstractFactory`1.Type">
            <summary>
            The factory type.
            </summary>
        </member>
        <member name="M:Axiom.Core.AbstractFactory`1.CreateInstance(System.String)">
            <summary>
            Creates a new object.
            </summary>
            <param name="name">Name of the object to create</param>
            <returns>
            An object created by the factory. The type of the object depends on
            the factory.
            </returns>
        </member>
        <member name="M:Axiom.Core.AbstractFactory`1.CreateInstance(System.String,Axiom.Collections.NameValuePairList)">
            <summary>
            Creates a new object.
            </summary>
            <param name="name">Name of the object to create</param>
            <param name="parms">List of Name/Value pairs to initialize the object with</param>
            <returns>
            An object created by the factory. The type of the object depends on
            the factory.
            </returns>
        </member>
        <member name="M:Axiom.Core.AbstractFactory`1.DestroyInstance(`0@)">
            <summary>
            Destroys an object which was created by this factory.
            </summary>
            <param name="obj">the object to destroy</param>
        </member>
        <member name="P:Axiom.Core.AbstractFactory`1.Type">
            <summary>
            The factory type.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObjectFactory.DestroyInstance(Axiom.Core.MovableObject@)">
            <summary>
                Destroy an instance of the object
            </summary>
            <param name="obj">
                The MovableObject to destroy.
            </param>
        </member>
        <member name="M:Axiom.Core.MovableObjectFactory.CreateInstance(System.String,Axiom.Core.SceneManager,Axiom.Collections.NamedParameterList)">
            <summary>
                Create a new instance of the object.
            </summary>
            <param name="name">
                The name of the new object
            </param>
            <param name="manager">
                The SceneManager instance that will be holding the instance once created.
            </param>
            <param name="param">
                Name/value pair list of additional parameters required to construct the object
                (defined per subtype).
            </param>
            <returns>A new MovableObject</returns>
        </member>
        <member name="M:Axiom.Core.MovableObjectFactory.CreateInstance(System.String,Axiom.Core.SceneManager)">
            <summary>
                Create a new instance of the object.
            </summary>
            <param name="name">
                The name of the new object
            </param>
            <param name="manager">
                The SceneManager instance that will be holding the instance once created.
            </param>
            <returns>A new MovableObject</returns>
        </member>
        <member name="P:Axiom.Core.MovableObjectFactory.TypeFlag">
            <summary>
                Gets/Sets the type flag for this factory.
            </summary>
            <remarks>
                A type flag is like a query flag, except that it applies to all instances
                of a certain type of object.
                This should normally only be called by Root in response to
                a 'true' result from RequestTypeFlags. However, you can actually use
                it yourself if you're careful; for example to assign the same mask
                to a number of different types of object, should you always wish them
                to be treated the same in queries.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObjectFactory.RequestTypeFlags">
             <summary>
                 Does this factory require the allocation of a 'type flag', used to
            	    selectively include / exclude this type from scene queries?
             </summary>
             <remarks>
                 The default implementation here is to return 'false', ie not to
                 request a unique type mask from Root. For objects that
                 never need to be excluded in SceneQuery results, that's fine, since
                 the default implementation of MovableObject::getTypeFlags is to return
                 all ones, hence matching any query type mask. However, if you want the
                 objects created by this factory to be filterable by queries using a
                 broad type, you have to give them a (preferably unique) type mask -
                 and given that you don't know what other MovableObject types are
                 registered, Root will allocate you one.
             </remarks>
            
        </member>
        <member name="T:Axiom.Core.ColorEx">
            <summary>
            	This class is necessary so we can store the color components as floating
            	point values in the range [0,1].  It serves as an intermediary to System.Drawing.Color, which
            	stores them as byte values.  This doesn't allow for slow color component
            	interpolation, because with the values always being cast back to a byte would lose
            	any small interpolated values (i.e. 223 - .25 as a byte is 223).
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.a">
            <summary>
            	Alpha value [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.r">
            <summary>
            	Red color component [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.g">
            <summary>
            	Green color component [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.b">
            <summary>
            	Blue color component [0,1].
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor taking RGB values
            </summary>
            <param name="r">Red color component.</param>
            <param name="g">Green color component.</param>
            <param name="b">Blue color component.</param>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Constructor taking all component values.
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red color component.</param>
            <param name="g">Green color component.</param>
            <param name="b">Blue color component.</param>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor(Axiom.Core.ColorEx)">
            <summary>
            Copy constructor.
            </summary>
            <param name="other">The ColorEx instance to copy</param>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToABGR">
            <summary>
            	Converts this color value to packed ABGR format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToARGB">
            <summary>
            	Converts this color value to packed ARBG format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToArrayRGBA(System.Single[])">
            <summary>
            	Populates the color components in a 4 elements array in RGBA order.
            </summary>
            <remarks>
            	Primarily used to help in OpenGL.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.Saturate">
            <summary>
            Clamps color value to the range [0, 1]
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.SaturateCopy">
            <summary>
            Clamps color value to the range [0, 1] in a copy
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.GetHashCode">
            <summary>
               Override GetHashCode.
            </summary>
            <remarks>
               Done mainly to quash warnings, no real need for it.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.CompareTo(System.Object)">
            <summary>
               Used to compare 2 ColorEx objects for equality.
            </summary>
            <param name="obj">An instance of a ColorEx object to compare to this instance.</param>
            <returns>0 if they are equal, 1 if they are not.</returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Axiom.Core.ColorEx.Transparent">
            <summary>
            	The color Transparent.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.AliceBlue">
            <summary>
            	The color AliceBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.AntiqueWhite">
            <summary>
            	The color AntiqueWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Aqua">
            <summary>
            	The color Aqua.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Aquamarine">
            <summary>
            	The color Aquamarine.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Azure">
            <summary>
            	The color Azure.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Beige">
            <summary>
            	The color Beige.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Bisque">
            <summary>
            	The color Bisque.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Black">
            <summary>
            	The color Black.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.BlanchedAlmond">
            <summary>
            	The color BlanchedAlmond.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Blue">
            <summary>
            	The color Blue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.BlueViolet">
            <summary>
            	The color BlueViolet.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Brown">
            <summary>
            	The color Brown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.BurlyWood">
            <summary>
            	The color BurlyWood.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.CadetBlue">
            <summary>
            	The color CadetBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Chartreuse">
            <summary>
            	The color Chartreuse.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Chocolate">
            <summary>
            	The color Chocolate.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Coral">
            <summary>
            	The color Coral.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.CornflowerBlue">
            <summary>
            	The color CornflowerBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Cornsilk">
            <summary>
            	The color Cornsilk.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Crimson">
            <summary>
            	The color Crimson.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Cyan">
            <summary>
            	The color Cyan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkBlue">
            <summary>
            	The color DarkBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkCyan">
            <summary>
            	The color DarkCyan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkGoldenrod">
            <summary>
            	The color DarkGoldenrod.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkGray">
            <summary>
            	The color DarkGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkGreen">
            <summary>
            	The color DarkGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkKhaki">
            <summary>
            	The color DarkKhaki.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkMagenta">
            <summary>
            	The color DarkMagenta.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkOliveGreen">
            <summary>
            	The color DarkOliveGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkOrange">
            <summary>
            	The color DarkOrange.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkOrchid">
            <summary>
            	The color DarkOrchid.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkRed">
            <summary>
            	The color DarkRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSalmon">
            <summary>
            	The color DarkSalmon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSeaGreen">
            <summary>
            	The color DarkSeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSlateBlue">
            <summary>
            	The color DarkSlateBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSlateGray">
            <summary>
            	The color DarkSlateGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkTurquoise">
            <summary>
            	The color DarkTurquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkViolet">
            <summary>
            	The color DarkViolet.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DeepPink">
            <summary>
            	The color DeepPink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DeepSkyBlue">
            <summary>
            	The color DeepSkyBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DimGray">
            <summary>
            	The color DimGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DodgerBlue">
            <summary>
            	The color DodgerBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Firebrick">
            <summary>
            	The color Firebrick.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.FloralWhite">
            <summary>
            	The color FloralWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.ForestGreen">
            <summary>
            	The color ForestGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Fuchsia">
            <summary>
            	The color Fuchsia.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Gainsboro">
            <summary>
            	The color Gainsboro.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.GhostWhite">
            <summary>
            	The color GhostWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Gold">
            <summary>
            	The color Gold.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Goldenrod">
            <summary>
            	The color Goldenrod.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Gray">
            <summary>
            	The color Gray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Green">
            <summary>
            	The color Green.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.GreenYellow">
            <summary>
            	The color GreenYellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Honeydew">
            <summary>
            	The color Honeydew.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.HotPink">
            <summary>
            	The color HotPink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.IndianRed">
            <summary>
            	The color IndianRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Indigo">
            <summary>
            	The color Indigo.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Ivory">
            <summary>
            	The color Ivory.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Khaki">
            <summary>
            	The color Khaki.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Lavender">
            <summary>
            	The color Lavender.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LavenderBlush">
            <summary>
            	The color LavenderBlush.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LawnGreen">
            <summary>
            	The color LawnGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LemonChiffon">
            <summary>
            	The color LemonChiffon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightBlue">
            <summary>
            	The color LightBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightCoral">
            <summary>
            	The color LightCoral.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightCyan">
            <summary>
            	The color LightCyan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightGoldenrodYellow">
            <summary>
            	The color LightGoldenrodYellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightGreen">
            <summary>
            	The color LightGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightGray">
            <summary>
            	The color LightGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightPink">
            <summary>
            	The color LightPink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSalmon">
            <summary>
            	The color LightSalmon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSeaGreen">
            <summary>
            	The color LightSeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSkyBlue">
            <summary>
            	The color LightSkyBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSlateGray">
            <summary>
            	The color LightSlateGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSteelBlue">
            <summary>
            	The color LightSteelBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightYellow">
            <summary>
            	The color LightYellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Lime">
            <summary>
            	The color Lime.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LimeGreen">
            <summary>
            	The color LimeGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Linen">
            <summary>
            	The color Linen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Magenta">
            <summary>
            	The color Magenta.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Maroon">
            <summary>
            	The color Maroon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumAquamarine">
            <summary>
            	The color MediumAquamarine.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumBlue">
            <summary>
            	The color MediumBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumOrchid">
            <summary>
            	The color MediumOrchid.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumPurple">
            <summary>
            	The color MediumPurple.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumSeaGreen">
            <summary>
            	The color MediumSeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumSlateBlue">
            <summary>
            	The color MediumSlateBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumSpringGreen">
            <summary>
            	The color MediumSpringGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumTurquoise">
            <summary>
            	The color MediumTurquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumVioletRed">
            <summary>
            	The color MediumVioletRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MidnightBlue">
            <summary>
            	The color MidnightBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MintCream">
            <summary>
            	The color MintCream.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MistyRose">
            <summary>
            	The color MistyRose.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Moccasin">
            <summary>
            	The color Moccasin.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.NavajoWhite">
            <summary>
            	The color NavajoWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Navy">
            <summary>
            	The color Navy.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.OldLace">
            <summary>
            	The color OldLace.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Olive">
            <summary>
            	The color Olive.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.OliveDrab">
            <summary>
            	The color OliveDrab.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Orange">
            <summary>
            	The color Orange.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.OrangeRed">
            <summary>
            	The color OrangeRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Orchid">
            <summary>
            	The color Orchid.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleGoldenrod">
            <summary>
            	The color PaleGoldenrod.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleGreen">
            <summary>
            	The color PaleGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleTurquoise">
            <summary>
            	The color PaleTurquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleVioletRed">
            <summary>
            	The color PaleVioletRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PapayaWhip">
            <summary>
            	The color PapayaWhip.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PeachPuff">
            <summary>
            	The color PeachPuff.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Peru">
            <summary>
            	The color Peru.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Pink">
            <summary>
            	The color Pink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Plum">
            <summary>
            	The color Plum.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PowderBlue">
            <summary>
            	The color PowderBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Purple">
            <summary>
            	The color Purple.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Red">
            <summary>
            	The color Red.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.RosyBrown">
            <summary>
            	The color RosyBrown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.RoyalBlue">
            <summary>
            	The color RoyalBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SaddleBrown">
            <summary>
            	The color SaddleBrown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Salmon">
            <summary>
            	The color Salmon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SandyBrown">
            <summary>
            	The color SandyBrown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SeaGreen">
            <summary>
            	The color SeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SeaShell">
            <summary>
            	The color SeaShell.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Sienna">
            <summary>
            	The color Sienna.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Silver">
            <summary>
            	The color Silver.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SkyBlue">
            <summary>
            	The color SkyBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SlateBlue">
            <summary>
            	The color SlateBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SlateGray">
            <summary>
            	The color SlateGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Snow">
            <summary>
            	The color Snow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SpringGreen">
            <summary>
            	The color SpringGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SteelBlue">
            <summary>
            	The color SteelBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Tan">
            <summary>
            	The color Tan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Teal">
            <summary>
            	The color Teal.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Thistle">
            <summary>
            	The color Thistle.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Tomato">
            <summary>
            	The color Tomato.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Turquoise">
            <summary>
            	The color Turquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Violet">
            <summary>
            	The color Violet.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Wheat">
            <summary>
            	The color Wheat.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.White">
            <summary>
            	The color White.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.WhiteSmoke">
            <summary>
            	The color WhiteSmoke.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Yellow">
            <summary>
            	The color Yellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.YellowGreen">
            <summary>
            	The color YellowGreen.
            </summary>
        </member>
        <member name="T:Axiom.Core.Camera">
             <summary>
            		A viewpoint from which the scene will be rendered.
             </summary>
            <remarks>
            		The engine renders scenes from a camera viewpoint into a buffer of
            		some sort, normally a window or a texture (a subclass of
            		RenderTarget). the engine cameras support both perspective projection (the default,
            		meaning objects get smaller the further away they are) and
            		orthographic projection (blueprint-style, no decrease in size
            		with distance). Each camera carries with it a style of rendering,
            		e.g. full textured, flat shaded, wireframe), field of view,
            		rendering distances etc, allowing you to use the engine to create
            		complex multi-window views if required. In addition, more than
            		one camera can point at a single render target if required,
            		each rendering to a subset of the target, allowing split screen
            		and picture-in-picture views.
            		<p/>
            		Cameras maintain their own aspect ratios, field of view, and frustrum,
            		and project co-ordinates into a space measured from -1 to 1 in x and y,
            		and 0 to 1 in z. At render time, the camera will be rendering to a
            		Viewport which will translate these parametric co-ordinates into real screen
            		co-ordinates. Obviously it is advisable that the viewport has the same
            		aspect ratio as the camera to avoid distortion (unless you want it!).
            		<p/>
            		Note that a Camera can be attached to a SceneNode, using the method
            		SceneNode.AttachObject. If this is done the Camera will combine it's own
            		position/orientation settings with it's parent SceneNode.
            		This is useful for implementing more complex Camera / object
            		relationships i.e. having a camera attached to a world object.
             </remarks>
        </member>
        <member name="T:Axiom.Core.Frustum">
            <summary>
                A frustum represents a pyramid, capped at the near and far end which is
                used to represent either a visible area or a projection area. Can be used
                for a number of applications.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.InfiniteFarPlaneAdjust">
            <summary>
            	Small constant used to reduce far plane projection to avoid inaccuracies.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.InfiniteFarPlaneDistance">
            <summary>
            	Arbitrary large distance to use for the far plane when set to 0 (infinite far plane).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._projectionType">
            <summary>
            	Perspective or Orthographic?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._fieldOfView">
            <summary>
                y-direction field-of-view (default 45).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._farDistance">
            <summary>
                Far clip distance - default 10000.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._nearDistance">
            <summary>
                Near clip distance - default 100.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._aspectRatio">
            <summary>
                x/y viewport ratio - default 1.3333
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._frustumOffset">
            <summary>
             Off-axis frustum center offset - default (0.0, 0.0)
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._focalLength">
            <summary>
             Focal length of frustum (for stereo rendering, defaults to 1.0)
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._planes">
            <summary>
                The 6 main clipping planes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._lastParentOrientation">
            <summary>
                Stored versions of parent orientation.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._lastParentPosition">
            <summary>
                Stored versions of parent position.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._projectionMatrixRS">
            <summary>
            Gets the projection matrix for this frustum adjusted for the current
            rendersystem specifics (may be right or left-handed, depth range
            may vary).
            </summary>
            <remarks>
            This method retrieves the rendering-API dependent version of the projection
            matrix. If you want a 'typical' projection matrix then use _projectionMatrix.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Frustum._projectionMatrixRSDepth">
            <summary>
             The depth-adjusted projection matrix for the current rendersystem,
             but one which still conforms to right-hand rules.
            </summary>
            <remarks>
                This differs from the rendering-API dependent getProjectionMatrix
                in that it always returns a right-handed projection matrix result
                no matter what rendering API is being used - this is required for
                vertex and fragment programs for example. However, the resulting depth
                range may still vary between render systems since D3D uses [0,1] and
                GL uses [-1,1], and the range must be kept the same between programmable
                and fixed-function pipelines.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Frustum._projectionMatrix">
             <summary>
             The normal projection matrix for this frustum, ie the
             projection matrix which conforms to standard right-handed rules and
             uses depth range [-1,+1].
             </summary>
            <remarks>
                This differs from the rendering-API dependent getProjectionMatrixRS
                in that it always returns a right-handed projection matrix with depth
                range [-1,+1], result no matter what rendering API is being used - this
                is required for some uniform algebra for example.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Frustum._viewMatrix">
            <summary>
                Pre-calced view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._recalculateFrustum">
            <summary>
                Something's changed in the frustum shape?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._recalculateView">
            <summary>
                Something in the view pos has changed?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._customViewMatrix">
            <summary>
             Are we using a custom view matrix?
             </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._customProjectionMatrix">
            <summary>
            Are we using a custom projection matrix?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._boundingBox">
            <summary>
                Bounding box of this frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._recalculateVertexData">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._vertexData">
            <summary>
                Vertex info for rendering this frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._material">
            <summary>
                Material to use when rendering this frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._recalculateWorldSpaceCorners">
            <summary>
            Signal to recalculate World Space Corners
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._worldSpaceCorners">
            <summary>
            	Frustum corners in world space.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._coeffL">
            Temp coefficient values calculated from a frustum change,
            			used when establishing the frustum planes when the view changes. 
        </member>
        <member name="F:Axiom.Core.Frustum.isReflected">
            <summary>
            	Is this frustum to act as a reflection of itself?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._reflectionMatrix">
            <summary>
            	Derive reflection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum._reflectionPlane">
            <summary>
            	Fixed reflection.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.linkedReflectionPlane">
            <summary>
            	Reference of a reflection plane (automatically updated).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.lastLinkedReflectionPlane">
            <summary>
            	Record of the last world-space reflection plane info used.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.useObliqueDepthProjection">
            <summary>
            	Is this frustum using an oblique depth projection?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.obliqueProjPlane">
            <summary>
            	Fixed oblique projection plane.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.linkedObliqueProjPlane">
            <summary>
            	Reference to oblique projection plane (automatically updated).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.lastLinkedObliqueProjPlane">
            <summary>
            	Record of the last world-space oblique depth projection plane info used.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.dummyLightList">
            <summary>
                Dummy list for IRenderable.Lights since we wont be lit.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.DisableCustomNearClipPlane">
            <summary>
            	Disables any custom near clip plane.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.DisableReflection">
            <summary>
                Disables reflection modification previously turned on with 
                <see cref="M:Axiom.Core.Frustum.EnableReflection(Axiom.Math.Plane)"/>.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableCustomNearClipPlane(Axiom.Graphics.IDerivedPlaneProvider)">
            <summary>
            	Links the frustum to a custom near clip plane, which can be used
            	to clip geometry in a custom manner without using user clip planes.
            </summary>
            <remarks>
            	<p>
            	There are several applications for clipping a scene arbitrarily by
            	a single plane; the most common is when rendering a reflection to
            	a texture, and you only want to render geometry that is above the
            	water plane (to do otherwise results in artefacts). Whilst it is
            	possible to use user clip planes, they are not supported on all
            	cards, and sometimes are not hardware accelerated when they are
            	available. Instead, where a single clip plane is involved, this
            	technique uses a 'fudging' of the near clip plane, which is
            	available and fast on all hardware, to perform as the arbitrary
            	clip plane. This does change the shape of the frustum, leading
            	to some depth buffer loss of precision, but for many of the uses of
            	this technique that is not an issue.</p>
            	<p>
            	This version of the method links to a plane, rather than requiring
            	a by-value plane definition, and therefore you can
            	make changes to the plane (e.g. by moving / rotating the node it is
            	attached to) and they will automatically affect this object.
            	</p>
            	<p>This technique only works for perspective projection.</p>
            </remarks>
            <param name="plane">The plane to link to to perform the clipping.</param>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableCustomNearClipPlane(Axiom.Math.Plane)">
            <summary>
            	Links the frustum to a custom near clip plane, which can be used
            	to clip geometry in a custom manner without using user clip planes.
            </summary>
            <remarks>
            	<p>
            	There are several applications for clipping a scene arbitrarily by
            	a single plane; the most common is when rendering a reflection to
            	a texture, and you only want to render geometry that is above the
            	water plane (to do otherwise results in artefacts). Whilst it is
            	possible to use user clip planes, they are not supported on all
            	cards, and sometimes are not hardware accelerated when they are
            	available. Instead, where a single clip plane is involved, this
            	technique uses a 'fudging' of the near clip plane, which is
            	available and fast on all hardware, to perform as the arbitrary
            	clip plane. This does change the shape of the frustum, leading
            	to some depth buffer loss of precision, but for many of the uses of
            	this technique that is not an issue.</p>
            	<p>
            	This version of the method links to a plane, rather than requiring
            	a by-value plane definition, and therefore you can
            	make changes to the plane (e.g. by moving / rotating the node it is
            	attached to) and they will automatically affect this object.
            	</p>
            	<p>This technique only works for perspective projection.</p>
            </remarks>
            <param name="plane">The plane to link to to perform the clipping.</param>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableReflection(Axiom.Math.Plane)">
            <summary>
                Modifies this camera so it always renders from the reflection of itself through the
                plane specified.
            </summary>
            <remarks>
                This is obviously useful for rendering planar reflections.
            </remarks>
            <param name="plane"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableReflection(Axiom.Graphics.IDerivedPlaneProvider)">
            <summary>
            	Modifies this frustum so it always renders from the reflection of itself through the
            	plane specified. Note that this version of the method links to a plane
            	so that changes to it are picked up automatically.
            </summary>
            <remarks>This is obviously useful for performing planar reflections.</remarks>
            <param name="plane"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.GetPositionForViewUpdate">
            <summary>
            	Get the derived position of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.GetOrientationForViewUpdate">
            <summary>
            	Get the derived orientation of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.AxisAlignedBox,Axiom.Core.FrustumPlane@)">
            <summary>
            	Tests whether the given box is visible in the Frustum.
             </summary>
            <param name="box"> Bounding box to be checked.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Sphere)">
            <summary>
            	Overloaded method.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Sphere,Axiom.Core.FrustumPlane@)">
            <summary>
            	Tests whether the given sphere is in the viewing frustum.
            </summary>
            <param name="sphere">Bounding sphere to be checked.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Vector3)">
            <summary>
            	Overloaded method.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Vector3,Axiom.Core.FrustumPlane@)">
            <summary>
            	Tests whether the given 3D point is in the viewing frustum.
            </summary>
            <param name="vertex">3D point to check for frustum visibility.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Frustum.InvalidateFrustum">
            <summary>
                Signal to update frustum information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.InvalidateView">
            <summary>
                Signal to update view information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.UpdateFrustum">
            <summary>
            	Updates the frustum data.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.UpdateView">
            <summary>
            	Updates the view matrix.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.SetOrthoWindow(System.Single,System.Single)">
            <summary>
            Set view area size for orthographic mode.
            </summary>
            <remarks>
            Note that this method adjusts the frustum's aspect ratio.
            </remarks>
            <param name="w">Width of the area to be visible</param>
            <param name="h">Height of the area to be visible</param>
        </member>
        <member name="M:Axiom.Core.Frustum.NotifyCurrentCamera(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
                Implemented to add outself to the rendering queue.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Core.Frustum.ProjectionType">
            <summary>
               Gets/Sets the type of projection to use (orthographic or perspective). Default is perspective.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.FieldOfView">
            <summary>
            	Sets the Y-dimension Field Of View (FOV) of the camera.
            </summary>
            <remarks>
            	Field Of View (FOV) is the angle made between the camera's position, and the left &amp; right edges
            	of the 'screen' onto which the scene is projected. High values (90+ Degrees) result in a wide-angle,
            	fish-eye kind of view, low values (30- Degrees) in a stretched, telescopic kind of view. Typical values
            	are between 45 and 60 Degrees.
            	<p/>
            	This value represents the HORIZONTAL field-of-view. The vertical field of view is calculated from
            	this depending on the dimensions of the viewport (they will only be the same if the viewport is square).
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.Far">
            <summary>
            	Gets/Sets the distance to the far clipping plane.
             </summary>
             <remarks>
            	The view frustrum is a pyramid created from the camera position and the edges of the viewport.
            	This frustrum does not extend to infinity - it is cropped near to the camera and there is a far
            	plane beyond which nothing is displayed. This method sets the distance for the far plane. Different
            	applications need different values: e.g. a flight sim needs a much further far clipping plane than
            	a first-person shooter. An important point here is that the larger the gap between near and far
            	clipping planes, the lower the accuracy of the Z-buffer used to depth-cue pixels. This is because the
            	Z-range is limited to the size of the Z buffer (16 or 32-bit) and the max values must be spread over
            	the gap between near and far clip planes. The bigger the range, the more the Z values will
            	be approximated which can cause artifacts when lots of objects are close together in the Z-plane. So
            	make sure you clip as close to the camera as you can - don't set a huge value for the sake of
            	it.
            </remarks>
            <value>
            	The distance to the far clipping plane from the frustum in
            	world coordinates.  If you specify 0, this means an infinite view
            	distance which is useful especially when projecting shadows; but
            	be careful not to use a near distance too close.
            </value>
        </member>
        <member name="P:Axiom.Core.Frustum.Near">
            <summary>
            	Gets/Sets the position of the near clipping plane.
            </summary>
            <remarks>
            	The position of the near clipping plane is the distance from the cameras position to the screen
            	on which the world is projected. The near plane distance, combined with the field-of-view and the
            	aspect ratio, determines the size of the viewport through which the world is viewed (in world
            	co-ordinates). Note that this world viewport is different to a screen viewport, which has it's
            	dimensions expressed in pixels. The cameras viewport should have the same aspect ratio as the
            	screen viewport it renders into to avoid distortion.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.AspectRatio">
            <summary>
            	Gets/Sets the aspect ratio to use for the camera viewport.
            </summary>
            <remarks>
            	The ratio between the x and y dimensions of the rectangular area visible through the camera
            	is known as aspect ratio: aspect = width / height .
            	<p/>
            	The default for most fullscreen windows is 1.3333f - this is also assumed unless you
            	use this property to state otherwise.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.FrustumOffset">
            <summary>
             Off-axis frustum center offset - default (0.0, 0.0)
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ProjectionMatrixRS">
            <summary>
            Gets the projection matrix for this frustum adjusted for the current
            rendersystem specifics (may be right or left-handed, depth range
            may vary).
            </summary>
            <remarks>
            This method retrieves the rendering-API dependent version of the projection
            matrix. If you want a 'typical' projection matrix then use ProjectionMatrix.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.ProjectionMatrixRSDepth">
            <summary>
               Gets the 'standard' projection matrix for this camera, ie the
               projection matrix which conforms to standard right-handed rules.
            </summary>
            <remarks>
               This differs from the rendering-API dependent ProjectionMatrix
               in that it always returns a right-handed projection matrix result
               no matter what rendering API is being used - this is required for
               vertex and fragment programs for example. However, the resulting depth
               range may still vary between render systems since D3D uses [0,1] and
               GL uses [-1,1], and the range must be kept the same between programmable
               and fixed-function pipelines.
               <para/>
               This corresponds to the Ogre mProjMatrixRSDepth and
               getProjectionMatrixWithRSDepth
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.ProjectionMatrix">
            <summary>
            Gets the projection matrix for this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ViewMatrix">
            <summary>
                Gets the view matrix for this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.IsFrustumOutOfDate">
            <summary>
            	Evaluates whether or not the view frustum is out of date.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.IsViewOutOfDate">
            <summary>
            	Gets whether or not the view matrix is out of date.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.IsReflected">
            <summary>
                Gets a flag that specifies whether this camera is being reflected or not.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ReflectionMatrix">
            <summary>
                Returns the reflection matrix of the camera if appropriate.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ReflectionPlane">
            <summary>
                Returns the reflection plane of the camera if appropriate.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.OrthoWindowHeight">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.OrthoWindowWidth">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Item(Axiom.Core.FrustumPlane)">
            <summary>
            	An indexer that accepts a FrustumPlane enum value and return the appropriate plane side of the Frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.BoundingRadius">
            <summary>
               Local bounding radius of this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.BoundingBox">
            <summary>
                Returns the bounding box for this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.TypeFlags">
            <summary>
            Get the 'type flags' for this <see cref="T:Axiom.Core.Frustum"/>.
            </summary>
            <seealso cref="P:Axiom.Core.MovableObject.TypeFlags"/>
        </member>
        <member name="P:Axiom.Core.Frustum.Material">
            <summary>
                Returns the material to use when rendering this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Technique">
            <summary>
                Just returns the best technique for our material.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Lights">
            <summary>
                Returns a dummy list since we won't be lit.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.orientation">
            <summary>
            	Camera orientation.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.position">
            <summary>
            	Camera position.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.derivedOrientation">
            <summary>
            	Orientation derived from parent.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.derivedPosition">
            <summary>
            	Position derived from parent.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.realOrientation">
            <summary>
            	Real world orientation of the camera.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.realPosition">
            <summary>
            	Real world position of the camera.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.isYawFixed">
            <summary>
            	Whether to yaw around a fixed axis.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.yawFixedAxis">
            <summary>
            	Fixed axis to yaw around.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.sceneLodFactor">
            <summary>
            	Scene LOD factor used to adjust overall LOD.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.invSceneLodFactor">
            <summary>
            	Inverted scene LOD factor, can be used by Renderables to adjust their LOD.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowLeft">
            <summary>
            	Left window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowRight">
            <summary>
            	Right window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowTop">
            <summary>
            	Top window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowBottom">
            <summary>
            	Bottom window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.isWindowSet">
            <summary>
            	Is viewing window used.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowClipPlanes">
            <summary>
            Windowed viewport clip planes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.recalculateWindow">
            <summary>
            	Was viewing window changed?
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.useRenderingDistance">
            <summary>
                Whether or not the rendering distance of objects should take effect for this camera
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.GetOrientationForViewUpdate">
            <summary>
            	Get the derived orientation of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetPositionForViewUpdate">
            <summary>
            	Get the derived position of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.InvalidateView">
            <summary>
            	Signal to update view information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.InvalidateFrustum">
            <summary>
            	Signal to update frustum information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.NotifyRenderedFaces(System.Int32)">
            <summary>
               Called by the scene manager to let this camera know how many faces were rendered within
               view of this camera every frame.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.NotifyRenderedBatches(System.Int32)">
            <summary>
               Called by the scene manager to let this camera know how many batches were rendered within
               view of this camera every frame.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.Move(Axiom.Math.Vector3)">
            <summary>
            Moves the camera's position by the vector offset provided along world axes.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Core.Camera.MoveRelative(Axiom.Math.Vector3)">
            <summary>
            Moves the camera's position by the vector offset provided along it's own axes (relative to orientation).
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Core.Camera.LookAt(Axiom.Math.Vector3)">
            <summary>
            	Specifies a target that the camera should look at.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Pitch(System.Single)">
            <summary>
            	Pitches the camera up/down counter-clockwise around it's local x axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Yaw(System.Single)">
            <summary>
            	Rolls the camera counter-clockwise, in degrees, around its local y axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Roll(System.Single)">
            <summary>
            	Rolls the camera counter-clockwise, in degrees, around its local z axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Rotate(Axiom.Math.Quaternion)">
            <summary>
            	Rotates the camera about an arbitrary axis.
            </summary>
            <param name="qnorm"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Rotate(Axiom.Math.Vector3,System.Single)">
            <summary>
            	Rotates the camera about an arbitrary axis.
            </summary>
            <param name="axis"></param>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.MovableObject)">
            <summary>
            	Enables / disables automatic tracking of a SceneObject.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param>
            <param name="target">The SceneObject which this Camera will track.</param>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode)">
            <summary>
            	Enables / disables automatic tracking of a SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param>
            <param name="target">The SceneNode which this Camera will track. Make sure you don't
            	delete this SceneNode before turning off tracking (e.g. SceneManager.ClearScene will
            	delete it so be careful of this). Can be null if and only if the enabled param is false.
            </param>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode,Axiom.Math.Vector3)">
            <summary>
            	Enables / disables automatic tracking of a SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param>
            <param name="target">The SceneNode which this Camera will track. Make sure you don't
            	delete this SceneNode before turning off tracking (e.g. SceneManager.ClearScene will
            	delete it so be careful of this). Can be null if and only if the enabled param is false.
            </param>
            <param name="offset">If supplied, the camera targets this point in local space of the target node
            	instead of the origin of the target node. Good for fine tuning the look at point.
            </param>
        </member>
        <member name="M:Axiom.Core.Camera.SetWindow(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the viewing window inside of viewport.
            </summary>
            <remarks>
            	This method can be used to set a subset of the viewport as the rendering target.
            </remarks>
            <param name="left">Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 0).</param>
            <param name="top">Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 0).</param>
            <param name="right">Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 1).</param>
            <param name="bottom">Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 1).</param>
        </member>
        <member name="M:Axiom.Core.Camera.GetRayForwardIntersect(Axiom.Math.Vector3,System.Collections.Generic.IEnumerable{Axiom.Math.Vector3},Axiom.Math.Real)">
            <summary>
            Helper function for forwardIntersect that intersects rays with canonical plane
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.ForwardIntersect(Axiom.Math.Plane,System.Collections.Generic.IList{Axiom.Math.Vector4})">
            <summary>
            Forward projects frustum rays to find forward intersection with plane.
            </summary>
            <remarks>
            Forward projection may lead to intersections at infinity.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Camera.SetWindowImpl">
            <summary>
            	Do actual window setting, using parameters set in <see cref="M:Axiom.Core.Camera.SetWindow(System.Single,System.Single,System.Single,System.Single)"/> call.
            </summary>
            <remarks>The method is called after projection matrix each change.</remarks>
        </member>
        <member name="M:Axiom.Core.Camera.ResetWindow">
            <summary>
            	Cancel view window.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.GetWindowPlane(System.Int32)">
            <summary>
            	Gets the window plane at the specified index.
            </summary>
            <param name="index">Index of the plane to get.</param>
            <returns>The window plane at the specified index.</returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetCameraToViewportRay(System.Single,System.Single,Axiom.Math.Ray@)">
            <summary>
                Gets a world space ray as cast from the camera through a viewport position.
            </summary>
            <param name="screenX">
                The x position at which the ray should intersect the viewport,
                in normalized screen coordinates [0,1].
            </param>
            <param name="screenY">
                The y position at which the ray should intersect the viewport,
                in normalized screen coordinates [0,1].
            </param>
            <param name="ray">
                Ray instance to populate with result
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetCameraToViewportRay(System.Single,System.Single)">
            <summary>
                Gets a world space ray as cast from the camera through a viewport position.
            </summary>
            <param name="screenX">
                The x position at which the ray should intersect the viewport,
                in normalized screen coordinates [0,1].
            </param>
            <param name="screenY">
                The y position at which the ray should intersect the viewport,
                in normalized screen coordinates [0,1].
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetCameraToViewportBoxVolume(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,System.Boolean)">
            <summary>
            Gets a world-space list of planes enclosing a volume based on a viewport rectangle.
            </summary>
            <param name="screenLeft">the left bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="screenTop">the upper bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="screenRight">the right bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="screenBottom">the lower bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="includeFarPlane">whether to include the far frustum plane</param>
            <remarks>
            Can be useful for populating a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/>, e.g. for a rubber-band selection.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetCameraToViewportBoxVolume(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.PlaneBoundedVolume,System.Boolean)">
            <summary>
            Gets a world-space list of planes enclosing a volume based on a viewport rectangle.
            </summary>
            <param name="screenLeft">the left bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="screenTop">the upper bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="screenRight">the right bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="screenBottom">the lower bound of the on-screen rectangle, expressed in normalized screen coordinates [0,1]</param>
            <param name="outVolume">The plane list to populate with the result</param>
            <param name="includeFarPlane">whether to include the far frustum plane</param>
            <remarks>
            Can be useful for populating a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/>, e.g. for a rubber-band selection.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.NotifyViewport(Axiom.Core.Viewport)">
            <summary>
            	Notifies this camera that a viewport is using it.
            </summary>
            <param name="viewport">Viewport that is using this camera.</param>
        </member>
        <member name="M:Axiom.Core.Camera.RenderScene(Axiom.Core.Viewport,System.Boolean)">
            <summary>
            	Called to ask a camera to render the scene into the given viewport.
            </summary>
            <param name="viewport"></param>
            <param name="showOverlays"></param>
        </member>
        <member name="M:Axiom.Core.Camera.AutoTrack">
            <summary>
            	Updates an auto-tracking camera.
            </summary>
        </member>
        <member name="E:Axiom.Core.Camera.CameraPreRenderScene">
            <summary>
            Called prior to the scene being rendered with this camera
            </summary>
        </member>
        <member name="E:Axiom.Core.Camera.CameraPostRenderScene">
            <summary>
            Called after the scene has been rendered with this camera
            </summary>
        </member>
        <member name="E:Axiom.Core.Camera.CameraDestroyed">
            <summary>
            Called when the camera is being destroyed
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.SceneManager">
            <summary>
               Returns the current SceneManager that this camera is using.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Orientation">
            <summary>
                Gets/Sets the camera's orientation.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Position">
            <summary>
                Gets/Sets the camera's position.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Direction">
            <summary>
            	Gets/Sets the camera's direction vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Up">
            <summary>
            	Gets camera's 'up' vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Right">
            <summary>
            	Gets camera's 'right' vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedOrientation">
            <summary>
            Gets the derived orientation of the camera, including any
            rotation inherited from a node attachment and reflection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedPosition">
            <summary>
            Gets the derived position of the camera, including any
            rotation inherited from a node attachment and reflection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedDirection">
            <summary>
            Gets the derived direction of the camera, including any
            rotation inherited from a node attachment and reflection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedUp">
            <summary>
            Gets the derived up vector of the camera, including any
            rotation inherited from a node attachment and reflection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedRight">
            <summary>
            Gets the derived right vector of the camera, including any
            rotation inherited from a node attachment and reflection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RealOrientation">
            <summary>
            Gets the real world orientation of the camera, including any
            rotation inherited from a node attachment
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RealPosition">
            <summary>
            Gets the real world orientation of the camera, including any
            rotation inherited from a node attachment
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RealDirection">
            <summary>
            Gets the derived direction of the camera, including any
            rotation inherited from a node attachment.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RealUp">
            <summary>
            Gets the derived up vector of the camera, including any
            rotation inherited from a node attachment.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RealRight">
            <summary>
            Gets the derived right vector of the camera, including any
            rotation inherited from a node attachment.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.FixedYawAxis">
            <summary>
            Tells the camera whether to yaw around it's own local Y axis or a fixed axis of choice.
            </summary>
            <remarks>
            This property allows you to change the yaw behaviour of the camera
            - by default, the camera yaws around a fixed Y axis. This is
            often what you want - for example if you're making a first-person
            shooter, you really don't want the yaw axis to reflect the local
            camera Y, because this would mean a different yaw axis if the
            player is looking upwards rather than when they are looking
            straight ahead. You can change this behaviour by setting this
            property to <seealso cref="P:Axiom.Math.Vector3.Zero"/>, which you will want to do if you are making a completely
            free camera like the kind used in a flight simulator.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.PolygonMode">
            <summary>
            	Sets the level of rendering detail required from this camera.
            </summary>
            <remarks>
            	Each camera is set to render at full detail by default, that is
            	with full texturing, lighting etc. This method lets you change
            	that behavior, allowing you to make the camera just render a
            	wireframe view, for example.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.RenderedFaceCount">
            <summary>
            Gets the last count of triangles visible in the view of this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RenderedBatchCount">
            <summary>
            Gets the last count of batches visible in the view of this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.AutoTrackingTarget">
            <summary>
            	SceneNode which this Camera will automatically track.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.AutoTrackingOffset">
            <summary>
            	Tracking offset for fine tuning.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.LodBias">
            <summary>
                Sets the level-of-detail factor for this Camera.
            </summary>
            <remarks>
                This method can be used to influence the overall level of detail of the scenes
                rendered using this camera. Various elements of the scene have level-of-detail
                reductions to improve rendering speed at distance; this method allows you
                to hint to those elements that you would like to adjust the level of detail that
                they would normally use (up or down).
                <p/>
                The most common use for this method is to reduce the overall level of detail used
                for a secondary camera used for sub viewports like rear-view mirrors etc.
                Note that scene elements are at liberty to ignore this setting if they choose,
                this is merely a hint.
                <p/>
                Higher values increase the detail, so 2.0 doubles the normal detail and 0.5 halves it.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.LodCamera">
            <summary>
            Get/Sets a reference to the Camera which should be used to determine LOD settings.
            </summary>
            <remarks>
            Sometimes you don't want the LOD of a render to be based on the camera
            that's doing the rendering, you want it to be based on a different
            camera. A good example is when rendering shadow maps, since they will
            be viewed from the perspective of another camera. Therefore this method
            lets you associate a different camera instance to use to determine the LOD.
            <para />
            To revert the camera to determining LOD based on itself, set this property with
            a reference to itself.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.InverseLodBias">
            <summary>
                Used for internal Lod calculations.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.IsWindowSet">
            <summary>
            	Gets the flag specifying if a viewport window is being used.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.WindowPlanes">
            <summary>
             Gets the window clip planes, only applicable if isWindowSet == true
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Viewport">
            <summary>
            	Get the last viewport which was attached to this camera.
            </summary>
            <remarks>
            	This is not guaranteed to be the only viewport which is
            	using this camera, just the last once which was created referring
            	to it.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.AutoAspectRatio">
            <summary>
            	If set to true a viewport that owns this frustum will be able to
            	recalculate the aspect ratio whenever the frustum is resized.
            </summary>
            <remarks>
            	You should set this to true only if the frustum / camera is used by
            	one viewport at the same time. Otherwise the aspect ratio for other
            	viewports may be wrong.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.UseRenderingDistance">
            <summary>
            	Whether or not the rendering distance of objects should take effect for this camera
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.CullFrustum">
            <summary>
                Tells the camera to use a separate Frustum instance to perform culling.
            </summary>
            <remarks>
            	By calling this method, you can tell the camera to perform culling
            	against a different frustum to it's own. This is mostly useful for
            	debug cameras that allow you to show the culling behaviour of another
                camera, or a manual frustum instance.
                This can either be a manual Frustum instance (which you can attach
                to scene nodes like any other MovableObject), or another camera.
                If you pass null to this property it reverts the camera to normal behaviour.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.IsViewOutOfDate">
            <summary>
            	Evaluates whether or not the view matrix is out of date.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Camera.FrustumViewMatrix">
            <summary>
            Returns the ViewMatrix for the underlying Frustum only
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.BoundingRadius">
            <summary>
            	Overridden to return a proper bounding radius for the camera.
            </summary>
        </member>
        <member name="T:Axiom.Core.Camera.CameraEventHandler">
            <summary>
               Delegate for Viewport update events.
            </summary>
        </member>
        <member name="T:Axiom.Core.Camera.CameraEventArgs">
            <summary>
               Event arguments for render target updates.
            </summary>
        </member>
        <member name="T:Axiom.Media.LinearResampler">
            <summary>
            default floating-point linear resampler, does format conversion
            </summary>
        </member>
        <member name="M:Axiom.Media.LinearResampler.Scale(Axiom.Media.PixelBox,Axiom.Media.PixelBox)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="T:Axiom.Media.LinearResampler.Byte">
            <summary>
            byte linear resampler, does not do any format conversions.
            </summary>
            <remarks>
            only handles pixel formats that use 1 byte per color channel.
            2D only; punts 3D pixelboxes to default <see cref="T:Axiom.Media.LinearResampler"/> (slow).
            templated on bytes-per-pixel to allow compiler optimizations, such
            as unrolling loops and replacing multiplies with bitshifts
            </remarks>
        </member>
        <member name="T:Axiom.Media.LinearResampler.Float32">
            <summary>
            float32 linear resampler, converts FLOAT32_RGB/FLOAT32_RGBA only.
            avoids overhead of pixel unpack/repack function calls
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.FileSystemArchive">
            <summary>
            Specialization of the Archive class to allow reading of files from filesystem folders / directories.
            </summary>
            <ogre name="FileSystemArchive">
                <file name="OgreFileSystem.h"   revision="1.6.2.1" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreFileSystem.cpp" revision="1.8" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre>
        </member>
        <member name="T:Axiom.FileSystem.Archive">
            <summary>Archive-handling class.</summary>
            <remarks>
            An archive is a generic term for a container of files. This may be a
            filesystem folder, it may be a compressed archive, it may even be 
            a remote location shared on the web. This class is designed to be 
            subclassed to provide access to a range of file locations. 
            <para/>
            Instances of this class are never constructed or even handled by end-user
            applications. They are constructed by custom ArchiveFactory classes, 
            which plugins can register new instances of using ArchiveManager. 
            End-user applications will typically use ResourceManager or 
            ResourceGroupManager to manage resources at a higher level, rather than 
            reading files directly through this class. Doing it this way allows you
            to benefit from OGRE's automatic searching of multiple file locations 
            for the resources you are looking for.
            </remarks>
            <ogre name="FileInfo">
                <file name="OgreArchive.h"   revision="1.7" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
        </member>
        <member name="M:Axiom.FileSystem.Archive.#ctor(System.String,System.String)">
            <summary>
            Constructor - don't call direct, used by IArchiveFactory.
            </summary>
            <param name="name"></param>
            <param name="archType"></param>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Load">
            <summary>
            Loads the archive
            </summary>
            <remarks>
            This initializes all the internal data of the class.
            <para/>
            Do not call this function directly, it is meant to be used
            only by the ArchiveManager class.
            </remarks>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Unload">
            <summary>
            Unloads the archive
            </summary>
            <remarks>
            Do not call this function directly, it is meant to be used
            only by the ArchiveManager class.
            </remarks>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Open(System.String,System.Boolean)">
            <summary>
            Open a stream on a given file. 
            </summary>
            <remarks>
            There is no equivalent 'close' method; the returned stream
            controls the lifecycle of this file operation.
            </remarks>
            <param name="filename">The fully qualified name of the file</param>
            <param name="readOnly">True to open for Read Access, false for Read/Write </param>
            <returns>A reference to a Stream which can be used to read / write
             the file. If the file is not present, returns null.
            </returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Open(System.String)">
            <summary>
            Open a stream on a given file. 
            </summary>
            <remarks>
            There is no equivalent 'close' method; the returned stream
            controls the lifecycle of this file operation.
            </remarks>
            <param name="filename">The fully qualified name of the file</param>
            <returns>
            A reference to a Stream which can be used to read the file. If the file is not present, returns null.
            </returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Create(System.String)">
            <summary>
            Create a new file (or overwrite one already there).
            </summary>
            <remarks>If the archive is read-only then this method will fail.</remarks>
            <param name="filename">The fully qualified name of the file</param>
            <returns>A Stream which can be used to read / write the file.</returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Create(System.String,System.Boolean)">
            <summary>
            Create a new file (or overwrite one already there).
            </summary>
            <remarks>If the archive is read-only then this method will fail.</remarks>
            <param name="filename">The fully qualified name of the file</param>
            <param name="overwrite">True to overwrite an existing file.</param>
            <returns>A Stream which can be used to read / write the file.</returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Remove(System.String)">
            <summary>
            Delete a named file.
            </summary>
            <remarks>If the archive is read-only then this method will fail.</remarks>
            <param name="filename">The fully qualified name of the file</param>
        </member>
        <member name="M:Axiom.FileSystem.Archive.List">
            <overloads>
            <summary>
            List all file names in the archive.
            </summary>
            <remarks>    
            This method only returns filenames, you can also retrieve other
            information using listFileInfo.
            </remarks>
            <returns>A list of filenames matching the criteria, all are fully qualified</returns>
            </overloads>
        </member>
        <member name="M:Axiom.FileSystem.Archive.List(System.Boolean)">
            <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that)</param>
        </member>
        <member name="M:Axiom.FileSystem.Archive.ListFileInfo">
            <summary>
            List all files in the archive with accompanying information.
            </summary>
            <returns>A list of structures detailing quite a lot of information about all the files in the archive.</returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.ListFileInfo(System.Boolean)">
            <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that)</param>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Find(System.String)">
            <overloads>
            <summary>
            Find all file names matching a given pattern in this archive.
            </summary>
            <remarks> 
            This method only returns filenames, you can also retrieve other
            information using findFileInfo.
            </remarks>
            <param name="pattern">The pattern to search for; wildcards (*) are allowed</param>
            <returns>A list of filenames matching the criteria, all are fully qualified</returns>
            </overloads>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Find(System.String,System.Boolean)">
            <param name="pattern">The pattern to search for; wildcards (*) are allowed</param>
            <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that)</param>
        </member>
        <member name="M:Axiom.FileSystem.Archive.Exists(System.String)">
            <summary>
            Find out if the named file exists
            </summary>
            <param name="fileName">fully qualified filename</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.GetModifiedTime(System.String)">
            <summary>
            Retrieve the modification time of a given file
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.Archive.FindFileInfo(System.String)">
            <overloads>
            <summary>
            Find all files matching a given pattern in this archive and get 
            some detailed information about them.
            </summary>
            <param name="pattern">The pattern to search for; wildcards (*) are allowed</param>
            <returns>A list of file information structures for all files matching the criteria.</returns>
            </overloads>
        </member>
        <member name="M:Axiom.FileSystem.Archive.FindFileInfo(System.String,System.Boolean)">
            <param name="pattern">The pattern to search for; wildcards (*) are allowed</param>
            <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that)</param>
        </member>
        <member name="M:Axiom.FileSystem.Archive.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
             
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.FileSystem.Archive.Name">
            Archive name
        </member>
        <member name="P:Axiom.FileSystem.Archive.Type">
            Archive type code
        </member>
        <member name="P:Axiom.FileSystem.Archive.IsCaseSensitive">
            Is this archive case sensitive in the way it matches files
        </member>
        <member name="P:Axiom.FileSystem.Archive.IsMonitorable">
            <summary>
            Is this archive capable of being monitored for additions, changes and deletions
            </summary>
        </member>
        <member name="F:Axiom.FileSystem.FileSystemArchive._basePath">
            <summary>Base path; actually the same as Name, but for clarity </summary>
        </member>
        <member name="F:Axiom.FileSystem.FileSystemArchive._directoryStack">
            <summary>Directory stack of previous directories </summary>
        </member>
        <member name="M:Axiom.FileSystem.FileSystemArchive.findFiles(System.String,System.Boolean,System.Collections.Generic.List{System.String},Axiom.FileSystem.FileInfoList)">
            <overloads>
            <summary>
            Utility method to retrieve all files in a directory matching pattern.
            </summary>
            <param name="pattern">File pattern</param>
            <param name="recursive">Whether to cascade down directories</param>
            <param name="simpleList">Populated if retrieving a simple list</param>
            <param name="detailList">Populated if retrieving a detailed list</param>
            </overloads>
        </member>
        <member name="M:Axiom.FileSystem.FileSystemArchive.findFiles(System.String,System.Boolean,System.Collections.Generic.List{System.String},Axiom.FileSystem.FileInfoList,System.String)">
            <param name="detailList"></param>
            <param name="currentDir">The current directory relative to the base of the archive, for file naming</param>
            <param name="pattern"></param>
            <param name="recursive"></param>
            <param name="simpleList"></param>
        </member>
        <member name="M:Axiom.FileSystem.FileSystemArchive.changeDirectory(System.String)">
            <summary>Utility method to change the current directory </summary>
        </member>
        <member name="M:Axiom.FileSystem.FileSystemArchive.pushDirectory(System.String)">
            <summary>Utility method to change directory and push the current directory onto a stack </summary>
        </member>
        <member name="M:Axiom.FileSystem.FileSystemArchive.popDirectory">
            <summary>Utility method to pop a previous directory off the stack and change to it </summary>
        </member>
        <member name="P:Axiom.FileSystem.FileSystemArchive.IsMonitorable">
            <summary>
            Is this archive capable of being monitored for additions, changes and deletions
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.FileSystemArchiveFactory">
            <summary>
            Specialization of IArchiveFactory for FileSystem files.
            </summary>
            <ogre name="FileSystemArchiveFactory">
                <file name="OgreFileSystem.h"   revision="1.6.2.1" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreFileSystem.cpp" revision="1.8" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre>
        </member>
        <member name="T:Axiom.FileSystem.ArchiveFactory">
            <summary>
            	abstract class for plugin developers to override to create 
            	new types of archive to load resources from.
            </summary>
            <remarks>            
            All access to 'archives' (collections of files, compressed or
            just folders, maybe even remote) is managed via the abstract
            Archive class. Plugins are expected to provide the
            implementation for the actual codec itself, but because a
            subclass of Archive has to be created for every archive, a
            factory class is required to create the appropriate subclass.
            <para/>
            So archive plugins create a subclass of Archive AND a subclass
            of ArchiveFactory which creates instances of the Archive
            subclass. See the 'Zip' and 'FileSystem' plugins for examples.
            Each Archive and ArchiveFactory subclass pair deal with a
            single archive type (identified by a string).
            </remarks>
            <ogre name="ArchiveFactory">
                <file name="OgreArchiveFactory.h"   revision="1.11" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
        </member>
        <member name="T:Axiom.Core.NameGenerator`1">
            <summary>
            Generates a unique name for a given type T
            </summary>
            <typeparam name="T">the type to generate a name for.</typeparam>
        </member>
        <member name="M:Axiom.Core.NameGenerator`1.#ctor">
            <summary>
            Constructor
            </summary>
            <remarks>
            use the name of the type as a base for generating unique names.
            </remarks>
        </member>
        <member name="M:Axiom.Core.NameGenerator`1.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="baseName">the base of the name for the type</param>
        </member>
        <member name="M:Axiom.Core.NameGenerator`1.GetNextUniqueName">
            <summary>
            Generates the next name
            </summary>
            <returns>the generated name</returns>
        </member>
        <member name="M:Axiom.Core.NameGenerator`1.GetNextUniqueName(System.String)">
            <summary>
            Generates the next name using a given prefix
            </summary>
            <param name="prefix">a prefix for the name</param>
            <returns>the generated name</returns>
        </member>
        <member name="P:Axiom.Core.NameGenerator`1.NextIdentifier">
            <summary>
            Gets/sets the next identifier used to generate a name
            </summary>
        </member>
        <member name="T:Axiom.Collections.SceneNodeCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.SceneNode">SceneNodes</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AxiomCollection`1">
            <summary>
            Serves as a basis for strongly typed collections in the engine.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection`1.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection`1.#ctor(System.Object)">
             <summary>
            
             </summary>
             <param name="parent"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection`1.Add(`0)">
            <summary>
            Adds an unnamed object to the <see cref="T:Axiom.Collections.AxiomCollection`1"/> and names it manually.
            </summary>
            <param name="item">The object to add.</param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection`1.AddRange(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Adds multiple items from a specified source collection
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Axiom.Collections.AxiomCollection`1"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1"/> for the <see cref="T:Axiom.Collections.AxiomCollection`1"/> values.</returns>
        </member>
        <member name="T:Axiom.Core.ChainedEvent`1">
             <summary>
            
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="M:Axiom.Core.ChainedEvent`1.Fire(System.Object,`0,System.Predicate{`0})">
             <summary>
            
             </summary>
             <param name="sender"></param>
             <param name="arg"></param>
             <param name="compare"></param>
             <returns></returns>
        </member>
        <member name="T:Axiom.Animating.Collections.AnimationStateCollection">
             <summary>
            Represents a collection of <see cref="T:Axiom.Animating.AnimationState">AnimationStates</see> that are sorted by name.
             </summary>
        </member>
        <member name="M:Axiom.Animating.Collections.AnimationStateCollection.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters">
            <summary>
            	Collects together the program parameters used for a GpuProgram.
            </summary>
            <remarks>
               Gpu program state includes constant parameters used by the program, and
               bindings to render system state which is propagated into the constants
               by the engine automatically if requested.
               <p/>
               GpuProgramParameters objects should be created through the GpuProgramManager and
               may be shared between multiple GpuProgram instances. For this reason they
               are managed using a shared pointer, which will ensure they are automatically
               deleted when no program is using them anymore.
               <p/>
               Different types of GPU programs support different types of constant parameters.
               For example, it's relatively common to find that vertex programs only support
               floating point constants, and that fragment programs only support integer (fixed point)
               parameters. This can vary depending on the program version supported by the
               graphics card being used. You should consult the documentation for the type of
               low level program you are using, or alternatively use the methods
               provided on Capabilities to determine the options.
               <p/>
               Another possible limitation is that some systems only allow constants to be set
               on certain boundaries, e.g. in sets of 4 values for example. Again, see
               Capabilities for full details.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.UpdateAutoParams(Axiom.Graphics.AutoParamDataSource,Axiom.Graphics.GpuProgramParameters.GpuParamVariability)">
            <summary>
            Update automatic parameters.
            </summary>
            <param name="source">The source of the parameters</param>
            <param name="mask">A mask of GpuParamVariability which identifies which autos will need updating</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetAutoConstantDefinition(System.String,Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition@)">
            <summary>
            Gets the auto constant definition associated with name if found else returns false
            </summary>
            <param name="name">The name of the auto constant</param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetAutoConstantDefinition(System.Int32,Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition@)">
            <summary>
            gets the auto constant definition using an index into the auto constant definition array.
            If the index is out of bounds then false is returned;
            </summary>
            <param name="idx">The auto constant index</param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.floatConstants">
            <summary>
            Definition of container that holds the current float constants.
            </summary>
            <remarks>
            Not necessarily in direct index order to constant indexes, logical
            to physical index map is derived from GpuProgram
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.intConstants">
            <summary>
            Definition of container that holds the current integer constants.
            </summary>
            <remarks>
            Not necessarily in direct index order to constant indexes, logical
            to physical index map is derived from GpuProgram
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.floatLogicalToPhysical">
            <summary>
            Logical index to physical index map - for low-level programs
            or high-level programs which pass params this way.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.intLogicalToPhysical">
            <summary>
            Packed list of floating-point constants (physical indexing)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters._combinedVariability">
            <summary>
            The combined variability masks of all parameters
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.autoConstants">
            <summary>
               List of automatically updated parameters.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.transposeMatrices">
            <summary>
                Specifies whether matrices need to be transposed prior to
                being sent to the hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.tmpVals">
            <summary>
            	Temp array for use when passing constants around.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.autoAddParamName">
            <summary>
            	Flag to indicate if names not found will be automatically added.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters._activePassIterationIndex">
            <summary>
            physical index for active pass iteration parameter real constant entry;
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.ClearAutoConstants">
            <summary>
               Clears all the existing automatic constants.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.CopyConstantsFrom(Axiom.Graphics.GpuProgramParameters)">
            <summary>
            	Copies the values of all constants (including auto constants) from another <see cref="T:Axiom.Graphics.GpuProgramParameters"/> object.
            </summary>
            <param name="source">Set of params to use as the source.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetFloatConstant(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetIntConstant(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetAutoConstant(System.Int32,Axiom.Graphics.GpuProgramParameters.AutoConstantType)">
            <summary>
               Sets up a constant which will automatically be updated by the engine.
            </summary>
            <remarks>
               Vertex and fragment programs often need parameters which are to do with the
               current render state, or particular values which may very well change over time,
               and often between objects which are being rendered. This feature allows you
               to set up a certain number of predefined parameter mappings that are kept up to
               date for you.
            </remarks>
            <param name="type">The type of automatic constant to set.</param>
            <param name="index">
               The location in the constant list to place this updated constant every time
               it is changed. Note that because of the nature of the types, we know how big the
               parameter details will be so you don't need to set that like you do for manual constants.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetAutoConstant(System.Int32,Axiom.Graphics.GpuProgramParameters.AutoConstantType,System.Int32)">
            <summary>
               Overloaded method.
            </summary>
            <param name="acType">The type of automatic constant to set.</param>
            <param name="index">
               The location in the constant list to place this updated constant every time
               it is changed. Note that because of the nature of the types, we know how big the
               parameter details will be so you don't need to set that like you do for manual constants.
            </param>
            <param name="extraInfo">If the constant type needs more information (like a light index) put it here.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Vector4)">
            <summary>
               Sends 4 packed floating-point values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 4 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Real)">
            <summary>
               Provides a way to pass in a single float
            </summary>
            <param name="index">Index of the contant register to start at.</param>
            <param name="value"></param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Vector3)">
            <summary>
               Sends 3 packed floating-point values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Matrix4)">
            <summary>
               Sends a multiple value constant floating-point parameter to the program.
            </summary>
            <remarks>
                This method is made virtual to allow GpuProgramManagers, or even individual
                GpuProgram implementations to supply their own implementation if need be.
                An example would be where a Matrix needs to be transposed to row-major format
                before passing to the hardware.
            </remarks>
            <param name="index">Index of the contant register.</param>
            <param name="mat">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Matrix4[],System.Int32)">
            <summary>
               Sends a multiple matrix values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="matrices">Values to set.</param>
            <param name="count">Number of matrices to set</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Core.ColorEx)">
            <summary>
               Sends 4 packed floating-point RGBA color values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="color">Structure containing 4 packed RGBA color values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Optimize the most common case of setting constant
               consisting of four floats
            </summary>
            <param name="index">Index of the contant register to start at.</param>
            <param name="f0">The floats.</param>
            <param name="f1">The floats.</param>
            <param name="f2">The floats.</param>
            <param name="f3">The floats.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,System.Single[])">
            <summary>
            Sets a multiple value constant floating-point parameter to the program.
            </summary>
            <param name="index">The logical constant index at which to start placing parameters 
            (each constant is a 4D float)</param>
            <param name="val">Pointer to the values to write, must contain 4*count floats</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,System.Double[])">
            <summary>
            Sets a multiple value constant floating-point parameter to the program.
            </summary>
            <param name="index">The logical constant index at which to start placing parameters 
            (each constant is a 4D float)</param>
            <param name="val">Pointer to the values to write, must contain 4*count floats</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,System.Int32[])">
            <summary>
               Sets an array of int values starting at the specified index.
            </summary>
            <param name="index">Index of the contant register to start at.</param>
            <param name="val">Array of ints.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetIntConstant(System.Int32,System.Int32)">
            <summary>
               Provides a way to pass in the technique pass number
            </summary>
            <param name="index">Index of the contant register to start at.</param>
            <param name="value">Value of the constant.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedAutoConstant(System.String,Axiom.Graphics.GpuProgramParameters.AutoConstantType)">
            <see cref="M:Axiom.Graphics.GpuProgramParameters.SetNamedAutoConstant(System.String,Axiom.Graphics.GpuProgramParameters.AutoConstantType,System.Int32)"/>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedAutoConstant(System.String,Axiom.Graphics.GpuProgramParameters.AutoConstantType,System.Int32)">
            <summary>
               Sets up a constant which will automatically be updated by the engine.
            </summary>
            <remarks>
               Vertex and fragment programs often need parameters which are to do with the
               current render state, or particular values which may very well change over time,
               and often between objects which are being rendered. This feature allows you
               to set up a certain number of predefined parameter mappings that are kept up to
               date for you.
            </remarks>
            <param name="name">
               Name of the param.
            </param>
            <param name="acType">
               The type of automatic constant to set.
            </param>
            <param name="extraInfo">
               Any extra information needed by the auto constant (i.e. light index, etc).
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Vector4)">
            <summary>
               Sends 4 packed floating-point values to the program.
            </summary>
            <param name="name">Name of the contant register.</param>
            <param name="val">Structure containing 4 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Vector3)">
            <summary>
               Sends 3 packed floating-point values to the program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Matrix4[],System.Int32)">
            <summary>
               Sends multiple matrices into a program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="matrices">Array of matrices.</param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Core.ColorEx)">
            <summary>
               Sends 4 packed floating-point RGBA color values to the program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="color">Structure containing 4 packed RGBA color values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.FindFloatAutoConstantEntry(System.Int32)">
            <summary>
            /** Finds an auto constant that's affecting a given logical parameter 
            index for floating-point values.
            </summary>
            <remarks>
            Only applicable for low-level programs.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.FindIntAutoConstantEntry(System.Int32)">
            <summary>
            /** Finds an auto constant that's affecting a given logical parameter 
            index for integer values.
            </summary>
            <remarks>
            Only applicable for low-level programs.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.FindAutoConstantEntry(System.String)">
            <summary>
            inds an auto constant that's affecting a given named parameter index.
            </summary>
            <remarks>
            Only applicable to high-level programs.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetFloatLogicalIndexForPhysicalIndex(System.Int32)">
            <summary>
            Retrieves the logical index relating to a physical index in the float
            buffer, for programs which support that (low-level programs and 
            high-level programs which use logical parameter indexes).
            </summary>
            <returns>int.MaxValue if not found</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetIntLogicalIndexForPhysicalIndex(System.Int32)">
            <summary>
            Retrieves the logical index relating to a physical index in the int
            buffer, for programs which support that (low-level programs and 
            high-level programs which use logical parameter indexes).
            </summary>
            <returns>int.MaxValue if not found</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetConstantDefinition(System.String)">
            <summary>
            Get a specific GpuConstantDefinition for a named parameter.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.FindNamedConstantDefinition(System.String,System.Boolean)">
            <summary>
            Find a constant definition for a named parameter.
            <remarks>
            This method returns null if the named parameter did not exist, unlike
            <see cref="M:Axiom.Graphics.GpuProgramParameters.GetConstantDefinition(System.String)"/> which is more strict; unless you set the 
            last parameter to true.
            </remarks>
            </summary>
            <param name="name">The name to look up</param>
            <param name="throwExceptionIfNotFound"> If set to true, failure to find an entry
            will throw an exception.</param>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.NamedConstants">
            <summary>
            Mapping from parameter names to def - high-level programs are expected to populate this
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.PassIterationNumberIndex">
            <summary>
            physical index for active pass iteration parameter real constant entry;
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasPassIterationNumber">
            <summary>
            Does this parameters object have a pass iteration number constant?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.AutoAddParamName">
            <summary>
            	Gets/Sets the auto add parameter name flag.
            </summary>
            <remarks>
            	Not all GPU programs make named parameters available after the high level
            	source is compiled.  GLSL is one such case.  If parameter names are not loaded
            	prior to the material serializer reading in parameter names in a script then
            	an exception is generated.  Set this to true to have names not found
            	in the map added to the map.
            	The index of the parameter name will be set to the end of the Float Constant List.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasAutoConstantType">
            <summary>
               Returns true if this instance contains any automatic constants.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasIntConstants">
            <summary>
               Returns true if int constants have been set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasFloatConstants">
            <summary>
               Returns true if floating-point constants have been set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.IntConstantCount">
            <summary>
               Gets the number of int contants values currently set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.FloatConstantCount">
            <summary>
               Gets the number of floating-point contant values currently set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.TransposeMatrices">
            <summary>
                Specifies whether matrices need to be transposed prior to
                being sent to the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.AutoConstantList">
            <summary>
               List of automatically updated parameters.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters">
            <summary>
            A group of manually updated parameters that are shared between many parameter sets.
            </summary>
            <remarks>
            Sometimes you want to set some common parameters across many otherwise
            different parameter sets, and keep them all in sync together. This class
            allows you to define a set of parameters that you can share across many
            parameter sets and have the parameters that match automatically be pulled
            from the shared set, rather than you having to set them on all the parameter
            sets individually.
            </remarks>
            <par>
            Parameters in a shared set are matched up with instances in a GpuProgramParameters
            structure by matching names. It is up to you to define the named parameters
            that a shared set contains, and ensuring the definition matches.
            </par>
            <note>
            Shared parameter sets can be named, and looked up using the GpuProgramManager.
            </note>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.AddConstantDefinition(System.String,Axiom.Graphics.GpuProgramParameters.GpuConstantType,System.Int32)">
            <summary>
            Add a new constant definition to this shared set of parameters.
            </summary>
            <param name="name"></param>
            <param name="constType"></param>
            <param name="arrraySize"></param>
            <remarks>
            Unlike GpuProgramParameters, where the parameter list is defined by the
            program being compiled, this shared parameter set is defined by the
            user. Only parameters which have been predefined here may be later
            updated.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.RemoveConstantDefinition(System.String)">
            <summary>
            Remove a constant definition from this shared set of parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.RemoveAllConstantDefinitions">
            <summary>
            Remove a constant definition from this shared set of parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.GetConstantDefinition(System.String)">
            <summary>
            Get a specific GpuConstantDefinition for a named parameter.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.MarkDirty">
            <summary>
            Mark the shared set as being dirty (values modified).
            </summary>
            <remarks>
            You do not need to call this yourself, set is marked as dirty whenever
            setNamedConstant or (non const) getFloatPointer et al are called.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.GetFloatPointer(System.Int32)">
            <summary>
            Get a pointer to the 'nth' item in the float buffer
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.GetIntPointer(System.Int32)">
            <summary>
            Get a pointer to the 'nth' item in the int buffer
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.Name">
            <summary>
            Get the name of this shared parameter set
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.Version">
            <summary>
            Get the version number of this shared parameter set, can be used to identify when
            changes have occurred.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.FrameLastUpdated">
            <summary>
             Not used when copying data, but might be useful to RS using shared buffers
             Get the frame in which this shared parameter set was last updated
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParameters.RenderSystemData">
            <summary>
             Internal method that the RenderSystem might use to store optional data.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinitionMap">
            <summary>
            Named Gpu constant lookup table
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.AutoConstantType">
            <summary>
               Parameters that are available via the engine and automatically calculated for use in GPU programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.WorldMatrix">
            <summary>
               Current world matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseWorldMatrix">
            <summary>
               Current world matrix, inverted.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TransposeWorldMatrix">
            <summary>
            Provides transpose of world matrix.
            Equivalent to RenderMonkey's "WorldTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTransposeWorldMatrix">
            <summary>
            The current world matrix, inverted &amp; transposed
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.WorldMatrixArray3x4">
            <summary>
               The current array of world matrices, as a 3x4 matrix, used for blending.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.WorldMatrixArray">
            <summary>
               The current array of world matrices, used for blending
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewMatrix">
            <summary>
               Current view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseViewMatrix">
            <summary>
               Current view matrix, inverted.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TransposeViewMatrix">
            <summary>
            Provides transpose of view matrix.
            Equivalent to RenderMonkey's "ViewTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTransposeViewMatrix">
            <summary>
            Provides inverse transpose of view matrix.
            Equivalent to RenderMonkey's "ViewInverseTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ProjectionMatrix">
            <summary>
               Current projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseProjectionMatrix">
            <summary>
            Provides inverse of projection matrix.
            Equivalent to RenderMonkey's "ProjectionInverse".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TransposeProjectionMatrix">
            <summary>
            Provides transpose of projection matrix.
            Equivalent to RenderMonkey's "ProjectionTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTransposeProjectionMatrix">
            <summary>
            Provides inverse transpose of projection matrix.
            Equivalent to RenderMonkey's "ProjectionInverseTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewProjMatrix">
            <summary>
               The current view &amp; projection matrices concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseViewProjMatrix">
            <summary>
            Provides inverse of concatenated view and projection matrices.
            Equivalent to RenderMonkey's "ViewProjectionInverse".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TransposeViewProjMatrix">
            <summary>
            Provides transpose of concatenated view and projection matrices.
            Equivalent to RenderMonkey's "ViewProjectionTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTransposeViewProjMatrix">
            <summary>
            Provides inverse transpose of concatenated view and projection matrices.
            Equivalent to RenderMonkey's "ViewProjectionInverseTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.WorldViewMatrix">
            <summary>
               Current world and view matrices concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseWorldViewMatrix">
            <summary>
            The current world &amp; view matrices concatenated, then inverted
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TransposeWorldViewMatrix">
            <summary>
            Provides transpose of concatenated world and view matrices.
            Equivalent to RenderMonkey's "WorldViewTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTransposeWorldViewMatrix">
            <summary>
            The current world &amp; view matrices concatenated, then inverted &amp; transposed
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.WorldViewProjMatrix">
            <summary>
               Current world, view, and projection matrics concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseWorldViewProjMatrix">
            <summary>
            Provides inverse of concatenated world, view and projection matrices.
            Equivalent to RenderMonkey's "WorldViewProjectionInverse".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TransposeWorldViewProjMatrix">
            <summary>
            Provides transpose of concatenated world, view and projection matrices.
            Equivalent to RenderMonkey's "WorldViewProjectionTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTransposeWorldViewProjMatrix">
            <summary>
            Provides inverse transpose of concatenated world, view and projection matrices.
            Equivalent to RenderMonkey's "WorldViewProjectionInverseTranspose".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.RenderTargetFlipping">
            <summary>
            render target related values
            -1 if requires texture flipping, +1 otherwise. It's useful when you bypassed
            projection matrix transform, still able use this value to adjust transformed y position.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.VertexWinding">
            <summary>
            -1 if the winding has been inverted (e.g. for reflections), +1 otherwise.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.FogColor">
            <summary>
            Fog colour
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.FogParams">
            <summary>
            Fog params: density, linear start, linear end, 1/(end-start)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SurfaceAmbientColor">
            <summary>
            Surface ambient colour, as set in Pass::setAmbient
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SurfaceDiffuseColor">
            <summary>
            Surface diffuse colour, as set in Pass::setDiffuse
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SurfaceSpecularColor">
            <summary>
            Surface specular colour, as set in Pass::setSpecular
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SurfaceEmissiveColor">
            <summary>
            Surface emissive colour, as set in Pass::setSelfIllumination
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SurfaceShininess">
            <summary>
            Surface shininess, as set in Pass::setShininess
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightCount">
            <summary>
            The number of active light sources (better than gl_MaxLights)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.AmbientLightColor">
            <summary>
            The ambient light colour set in the scene
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDiffuseColor">
            <summary>
            Light diffuse colour (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightSpecularColor">
            <summary>
            Light specular colour (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightAttenuation">
            <summary>
            Light attenuation parameters, Vector4(range, constant, linear, quadric)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SpotLightParams">
            <summary>
            Spotlight parameters, Vector4(innerFactor, outerFactor, falloff, isSpot)
            innerFactor and outerFactor are cos(angle/2)
            The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
            Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPosition">
            <summary>
            A light position in world space (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPositionObjectSpace">
            <summary>
            A light position in object space (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPositionViewSpace">
            <summary>
            A light position in view space (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDirection">
            <summary>
            A light direction in world space (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDirectionObjectSpace">
            <summary>
            A light direction in object space (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDirectionViewSpace">
            <summary>
            A light direction in view space (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDistanceObjectSpace">
            <summary>
            The distance of the light from the center of the object
            a useful approximation as an alternative to per-vertex distance
            calculations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPowerScale">
            <summary>
            Light power level, a single scalar as set in Light::setPowerScale  (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDiffuseColorPowerScaled">
            <summary>
            Light diffuse colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightSpecularColorPowerScaled">
            <summary>
            Light specular colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDiffuseColorArray">
            <summary>
            Array of light diffuse colours (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightSpecularColorArray">
            <summary>
            Array of light specular colours (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDiffuseColorPowerScaledArray">
            <summary>
            Array of light diffuse colours scaled by light power (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightSpecularColorPowerScaledArray">
            <summary>
            Array of light specular colours scaled by light power (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightAttenuationArray">
            <summary>
            Array of light attenuation parameters, Vector4(range, constant, linear, quadric) (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPositionArray">
            <summary>
            Array of light positions in world space (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPositionObjectSpaceArray">
            <summary>
            Array of light positions in object space (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPositionViewSpaceArray">
            <summary>
            Array of light positions in view space (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDirectionArray">
            <summary>
            Array of light directions in world space (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDirectionObjectSpaceArray">
            <summary>
            Array of light directions in object space (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDirectionViewSpaceArray">
            <summary>
            Array of light directions in view space (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightDistanceObjectSpaceArray">
            <summary>
            Array of distances of the lights from the center of the object
            a useful approximation as an alternative to per-vertex distance
            calculations. (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightPowerScaleArray">
            <summary>
            Array of light power levels, a single scalar as set in Light::setPowerScale 
            (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SpotLightParamsArray">
            <summary>
            Spotlight parameters array of Vector4(innerFactor, outerFactor, falloff, isSpot)
            innerFactor and outerFactor are cos(angle/2)
            The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights.
            Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively.
            (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.DerivedAmbientLightColor">
            <summary>
            The derived ambient light colour, with 'r', 'g', 'b' components filled with
            product of surface ambient colour and ambient light colour, respectively,
            and 'a' component filled with surface ambient alpha component.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.DerivedSceneColor">
            <summary>
            The derived scene colour, with 'r', 'g' and 'b' components filled with sum
            of derived ambient light colour and surface emissive colour, respectively,
            and 'a' component filled with surface diffuse alpha component.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.DerivedLightDiffuseColor">
            <summary>
            The derived light diffuse colour (index determined by setAutoConstant call),
            with 'r', 'g' and 'b' components filled with product of surface diffuse colour,
            light power scale and light diffuse colour, respectively, and 'a' component filled with surface
            diffuse alpha component.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.DerivedLightSpecularColor">
            <summary>
            The derived light specular colour (index determined by setAutoConstant call),
            with 'r', 'g' and 'b' components filled with product of surface specular colour
            and light specular colour, respectively, and 'a' component filled with surface
            specular alpha component.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.DerivedLightDiffuseColorArray">
            <summary>
            Array of derived light diffuse colours (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.DerivedLightSpecularColorArray">
            <summary>
            Array of derived light specular colours (count set by extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightNumber">
            <summary>
            The absolute light number of a local light index. Each pass may have
            a number of lights passed to it, and each of these lights will have
            an index in the overall light list, which will differ from the local
            light index due to factors like setStartLight and setIteratePerLight.
            This binding provides the global light index for a local index.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightCastsShadows">
            <summary>
            Returns (int) 1 if the  given light casts shadows, 0 otherwise (index set in extra param)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ShadowExtrusionDistance">
            <summary>
            The distance a shadow volume should be extruded when using
            finite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.CameraPosition">
            <summary>
            The current camera's position in world space
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.CameraPositionObjectSpace">
            <summary>
            The current camera's position in object space
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TextureViewProjMatrix">
            <summary>
            The view/projection matrix of the assigned texture projection frustum
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TextureViewProjMatrixArray">
            <summary>
            Array of view/projection matrices of the first n texture projection frustums
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TextureWorldViewProjMatrix">
            <summary>
            The view/projection matrix of the assigned texture projection frustum, 
            combined with the current world matrix
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TextureWorldViewProjMatrixArray">
            <summary>
            Array of world/view/projection matrices of the first n texture projection frustums
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SpotLightViewProjMatrix">
            <summary>
            The view/projection matrix of a given spotlight
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SpotLightWorldViewProjMatrix">
            <summary>
            The view/projection matrix of a given spotlight projection frustum, 
            combined with the current world matrix
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Custom">
            <summary>
            A custom parameter which will come from the renderable, using 'data' as the identifier
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time">
            <summary>
            provides current elapsed time
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time_0_X">
            <summary>
            Single float value, which repeats itself based on given as
            parameter "cycle time". Equivalent to RenderMonkey's "Time0_X".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.CosTime_0_X">
            <summary>
            Cosine of "Time0_X". Equivalent to RenderMonkey's "CosTime0_X".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SinTime_0_X">
            <summary>
            Sine of "Time0_X". Equivalent to RenderMonkey's "SinTime0_X".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TanTime_0_X">
            <summary>
            Tangent of "Time0_X". Equivalent to RenderMonkey's "TanTime0_X".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time_0_X_Packed">
            <summary>
            Vector of "Time0_X", "SinTime0_X", "CosTime0_X", 
            "TanTime0_X". Equivalent to RenderMonkey's "Time0_X_Packed".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time_0_1">
            <summary>
            Single float value, which represents scaled time value [0..1],
            which repeats itself based on given as parameter "cycle time".
            Equivalent to RenderMonkey's "Time0_1".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.CosTime_0_1">
            <summary>
            Cosine of "Time0_1". Equivalent to RenderMonkey's "CosTime0_1".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SinTime_0_1">
            <summary>
            Sine of "Time0_1". Equivalent to RenderMonkey's "SinTime0_1".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TanTime_0_1">
            <summary>
            Tangent of "Time0_1". Equivalent to RenderMonkey's "TanTime0_1".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time_0_1_Packed">
            <summary>
            Vector of "Time0_1", "SinTime0_1", "CosTime0_1",
            "TanTime0_1". Equivalent to RenderMonkey's "Time0_1_Packed".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time_0_2PI">
            <summary>
            Single float value, which represents scaled time value [0..2*Pi],
            which repeats itself based on given as parameter "cycle time".
            Equivalent to RenderMonkey's "Time0_2PI".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.CosTime_0_2PI">
            <summary>
            Cosine of "Time0_2PI". Equivalent to RenderMonkey's "CosTime0_2PI".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SinTime_0_2PI">
            <summary>
            Sine of "Time0_2PI". Equivalent to RenderMonkey's "SinTime0_2PI".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TanTime_0_2PI">
            <summary>
            Tangent of "Time0_2PI". Equivalent to RenderMonkey's "TanTime0_2PI".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.Time_0_2PI_Packed">
            <summary>
            Vector of "Time0_2PI", "SinTime0_2PI", "CosTime0_2PI",
            "TanTime0_2PI". Equivalent to RenderMonkey's "Time0_2PI_Packed".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.FrameTime">
            <summary>
            provides the scaled frame time, returned as a floating point value.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.FPS">
            <summary>
            provides the calculated frames per second, returned as a floating point value.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewportWidth">
            <summary>
            Current viewport width (in pixels) as floating point value.
            Equivalent to RenderMonkey's "ViewportWidth".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewportHeight">
            <summary>
            Current viewport height (in pixels) as floating point value.
            Equivalent to RenderMonkey's "ViewportHeight".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseViewportWidth">
            <summary>
            This variable represents 1.0/ViewportWidth. 
            Equivalent to RenderMonkey's "ViewportWidthInverse".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseViewportHeight">
            <summary>
            This variable represents 1.0/ViewportHeight.
            Equivalent to RenderMonkey's "ViewportHeightInverse".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewportSize">
            <summary>
            Packed of "ViewportWidth", "ViewportHeight", "ViewportWidthInverse",
            "ViewportHeightInverse".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewDirection">
            <summary>
            This variable provides the view direction vector (world space).
            Equivalent to RenderMonkey's "ViewDirection".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewSideVector">
            <summary>
            This variable provides the view side vector (world space).
            Equivalent to RenderMonkey's "ViewSideVector".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ViewUpVector">
            <summary>
            This variable provides the view up vector (world space).
            Equivalent to RenderMonkey's "ViewUpVector".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.FOV">
            <summary>
            This variable provides the field of view as a floating point value.
            Equivalent to RenderMonkey's "FOV".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.NearClipDistance">
            <summary>
            This variable provides the near clip distance as a floating point value.
            Equivalent to RenderMonkey's "NearClipPlane".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.FarClipDistance">
            <summary>
            This variable provides the far clip distance as a floating point value.
            Equivalent to RenderMonkey's "FarClipPlane".
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.PassNumber">
            <summary>
            provides the pass index number within the technique
            of the active material.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.PassIterationNumber">
            <summary>
            provides the current iteration number of the pass. The iteration
            number is the number of times the current render operation has
            been drawn for the active pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.AnimationParametric">
            <summary>
            Provides a parametric animation value [0..1], only available
            where the renderable specifically implements it.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TexelOffsets">
            <summary>
            Provides the texel offsets required by this rendersystem to map
            texels to pixels. Packed as 
            float4(absoluteHorizontalOffset, absoluteVerticalOffset, 
            horizontalOffset / viewportWidth, verticalOffset / viewportHeight)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.SceneDepthRange">
            <summary>
            Provides information about the depth range of the scene as viewed
            from the current camera. 
            Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ShadowSceneDepthRange">
            <summary>
            Provides information about the depth range of the scene as viewed
            from a given shadow camera. Requires an index parameter which maps
            to a light index relative to the current light list.
            Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.ShadowColor">
            <summary>
            Provides the fixed shadow colour as configured via SceneManager::setShadowColour;
            useful for integrated modulative shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TextureSize">
            <summary>
            Provides texture size of the texture unit (index determined by setAutoConstant
            call). Packed as float4(width, height, depth, 1)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.InverseTextureSize">
            <summary>
            Provides inverse texture size of the texture unit (index determined by setAutoConstant
            call). Packed as float4(1 / width, 1 / height, 1 / depth, 1)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.PackedTextureSize">
            <summary>
            Provides packed texture size of the texture unit (index determined by setAutoConstant
            call). Packed as float4(width, height, 1 / width, 1 / height)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.TextureMatrix">
            <summary>
            Provides the current transform matrix of the texture unit (index determined by setAutoConstant
            call), as seen by the fixed-function pipeline. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LODCameraPosition">
            <summary>
            Provides the position of the LOD camera in world space, allowing you 
            to perform separate LOD calculations in shaders independent of the rendering
            camera. If there is no separate LOD camera then this is the real camera
            position. See Camera::setLodCamera.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LODCameraPositionObjectSpace">
            <summary>
            Provides the position of the LOD camera in object space, allowing you 
            to perform separate LOD calculations in shaders independent of the rendering
            camera. If there is no separate LOD camera then this is the real camera
            position. See Camera::setLodCamera.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.LightCustom">
            <summary>
            Binds custom per-light constants to the shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantType.MVShadowTechnique">
            <summary>
            Multiverse specific shadow technique in use
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.ElementType">
            <summary>
            Defines the base element type of the auto constant
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.ElementType.Int">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.ElementType.Real">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.AutoConstantDataType">
            <summary>
            Defines the type of the extra data item used by the auto constant.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDataType.None">
            <summary>
            no data is required
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDataType.Int">
            <summary>
            the auto constant requires data of type int
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDataType.Real">
            <summary>
            the auto constant requires data of type real
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition">
            <summary>
            Structure defining an auto constant that's available for use in a parameters object.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition.AutoConstantType">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition.Name">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition.ElementCount">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition.ElementType">
            <summary>
            The type of the constant in the program
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition.DataType">
            <summary>
            The type of any extra data
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.AutoConstantDefinition.#ctor(Axiom.Graphics.GpuProgramParameters.AutoConstantType,System.String,System.Int32,Axiom.Graphics.GpuProgramParameters.ElementType,Axiom.Graphics.GpuProgramParameters.AutoConstantDataType)">
            <summary>
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuParamVariability.Global">
            <summary>
            No variation except by manual setting - the default
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuParamVariability.PerObject">
            <summary>
            Varies per object (based on an auto param usually), but not per light setup
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuParamVariability.Lights">
            <summary>
            Varies with light setup
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuParamVariability.PassIterationNumber">
            <summary>
            Varies with pass iteration number
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuParamVariability.All">
            <summary>
            Full mask (16-bit)
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuConstantType">
            <summary>
            Enumeration of the types of constant we may encounter in programs.
            </summary>
            <note>
            Low-level programs, by definition, will always use either
            float4 or int4 constant types since that is the fundamental underlying
            type in assembler.
            </note>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry">
            <summary>
               A structure for recording the use of automatic parameters.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.Type">
            <summary>
               The type of the parameter.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.PhysicalIndex">
            <summary>
               The target index.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.ElementCount">
            <summary>
            The number of elements per individual entry in this constant
            Used in case people used packed elements smaller than 4 (e.g. GLSL)
            and bind an auto which is 4-element packed to it
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.Data">
            <summary>
               Any additional info to go with the parameter.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.FData">
            <summary>
               Any additional info to go with the parameter.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.Variability">
            <summary>
            The Variability of this parameter (see <see>GpuParamVariability</see>)
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.#ctor(Axiom.Graphics.GpuProgramParameters.AutoConstantType,System.Int32,System.Int32,Axiom.Graphics.GpuProgramParameters.GpuParamVariability,System.Int32)">
            <summary>
               Default constructor.
            </summary>
            <param name="type">Type of auto param (i.e. WorldViewMatrix, etc)</param>
            <param name="index">Index of the param.</param>
            <param name="data">Any additional info to go with the parameter.</param>
            <param name="variability">Variability of parameter</param>
            <param name="elementCount"></param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.#ctor(Axiom.Graphics.GpuProgramParameters.AutoConstantType,System.Int32,System.Single,Axiom.Graphics.GpuProgramParameters.GpuParamVariability,System.Int32)">
            <summary>
               Default constructor.
            </summary>
            <param name="type">Type of auto param (i.e. WorldViewMatrix, etc)</param>
            <param name="index">Index of the param.</param>
            <param name="fdata">Any additional info to go with the parameter.</param>
            <param name="variability">Variability of parameter</param>
            <param name="elementCount"></param>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage">
            <summary>
            This class records the usage of a set of shared parameters in a concrete
            set of GpuProgramParameters.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.CopyDataList">
            <summary>
            list of physical mappings that we are going to bring in
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.CopyDataVersion">
            <summary>
            Version of shared params we based the copydata on
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.#ctor(Axiom.Graphics.GpuProgramParameters.GpuSharedParameters,Axiom.Graphics.GpuProgramParameters)">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.CopySharedParamsToTargetParams">
            <summary>
            Update the target parameters by copying the data from the shared
            parameters.
            </summary>
            <note>
            This method  may not actually be called if the RenderSystem
            supports using shared parameters directly in their own shared buffer; in
            which case the values should not be copied out of the shared area
            into the individual parameter set, but bound separately.
            </note>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.TargetParameters">
            <summary>
            Get's the target Gpu program parameters.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.RenderSystemData">
            <summary>
            Optional data the rendersystem might want to store
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuSharedParametersUsage.Name">
            <summary>
            Get the name of the shared parameter set
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.GpuProgramParameters.GpuLogicalBufferStruct" -->
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuLogicalBufferStruct.Map">
            <summary>
            Map from logical index to physical buffer location
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuLogicalBufferStruct.BufferSize">
            Shortcut to know the buffer size needs
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition">
            <summary>
            Information about predefined program constants.
            </summary>
            <note>
            Only available for high-level programs but is referenced generically
            by GpuProgramParameters
            </note>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.ConstantType">
            <summary>
            Data type.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition._physIndex">
            <summary>
            Physical start index in buffer (either float or int buffer)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.LogicalIndex">
            <summary>
            Logical index - used to communicate this constant to the rendersystem
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.ElementSize">
            <summary>
            Number of raw buffer slots per element
            (some programs pack each array element to float4, some do not)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.ArraySize">
            <summary>
            Length of array
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.Variability">
            <summary>
            How this parameter varies (bitwise combination of GpuParamVariability)
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.IsFloatConst(Axiom.Graphics.GpuProgramParameters.GpuConstantType)">
            <summary>
            </summary>
            <returns>
            true when the curent ConstantType is a float based type
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.IsSamplerConst(Axiom.Graphics.GpuProgramParameters.GpuConstantType)">
            <summary>
            </summary>
            <returns>
            true when the curent ConstantType is an int based type
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.GetElementSize(Axiom.Graphics.GpuProgramParameters.GpuConstantType,System.Boolean)">
            <summary>
            Get the element size of a given type, including whether to pad the 
            elements into multiples of 4 (e.g. SM1 and D3D does, GLSL doesn't)
            </summary>
            <param name="ctype"></param>
            <param name="padToMultiplesOf4"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.#ctor">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.IsFloat">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition.IsSampler">
            <summary>
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuLogicalIndexUse.PhysicalIndex">
            <summary>
            Physical buffer index
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuLogicalIndexUse.CurrentSize">
            <summary>
            Current physical size allocation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuLogicalIndexUse.Variability">
            <summary>
            How the contents of this slot vary
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants">
            <summary>
            class collecting together the information for named constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.FloatBufferSize">
            <summary>
            Total size of the float buffer required
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.IntBufferSize">
            <summary>
            Total size of the int buffer required
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.Map">
            <summary>
            Dictionary of parameter names to GpuConstantDefinition
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.GenerateAllConstantDefinitionArrayEntries">
            <summary>
            Indicates whether all array entries will be generated and added to the definitions map
            </summary>
            <remarks>
            Normally, the number of array entries added to the definitions map is capped at 16
            to save memory. Setting this value to <code>true</code> allows all of the entries
            to be generated and added to the map.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.GenerateConstantDefinitionArrayEntries(System.String,Axiom.Graphics.GpuProgramParameters.GpuConstantDefinition)">
            <summary>
            Generate additional constant entries for arrays based on a base definition.
            </summary>
            <param name="paramName"></param>
            <param name="baseDef"></param>
            <remarks>
            Array uniforms will be added just with their base name with no array
            suffix. This method will add named entries for array suffixes too
            so individual array entries can be addressed. Note that we only
            individually index array elements if the array size is up to 16
            entries in size. Anything larger than that only gets a [0] entry
            as well as the main entry, to save cluttering up the name map. After
            all, you can address the larger arrays in a bulk fashion much more
            easily anyway.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.Save(System.String)">
            <summary>
            Saves constant definitions to a file, compatible with GpuProgram::setManualNamedConstantsFile.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GpuNamedConstants.Load(System.IO.Stream)">
            <summary>
            Loads constant definitions from a stream, compatible with GpuProgram::setManualNamedConstantsFile.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.GpuNamedConstantsSerializer">
            <summary>
            Simple class for loading / saving GpuNamedConstants
            </summary>
        </member>
        <member name="T:Axiom.Serialization.Serializer">
            <summary>
            Summary description for Serializer.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Serializer.ChunkOverheadSize">
            <summary>
            	Chunk ID + size (short + long).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Serializer.version">
            <summary>
            	Version string of this serializer.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Serializer.currentChunkLength">
            <summary>
            	Length of the chunk that is currently being processed.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.IgnoreCurrentChunk(System.IO.BinaryReader)">
            <summary>
            	Skips past a particular chunk.
            </summary>
            <remarks>
            	Only really used during development, when logic for handling particular chunks is not yet complete.
            </remarks>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadBytes(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of floats and copies them into the destination pointer.
            </summary>
            <param name="reader"></param>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteBytes(System.IO.BinaryWriter,System.Int32,System.IntPtr)">
            <summary>
            	Writes a specified number of bytes.
            </summary>
            <param name="writer"></param>
            <param name="count">Number of values to write.</param>
            <param name="src">Pointer that holds the values.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFloats(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of floats and copies them into the destination pointer.
            </summary>
            <param name="reader"></param>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteFloats(System.IO.BinaryWriter,System.Int32,System.IntPtr)">
            <summary>
            	Writes a specified number of floats.
            </summary>
            <param name="writer"></param>
            <param name="count">Number of values to write.</param>
            <param name="src">Pointer that holds the values.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFloats(System.IO.BinaryReader,System.Int32,System.IntPtr,System.Single[])">
            <summary>
            	Reads a specified number of floats and copies them into the destination pointer.
            </summary>
            <remarks>This overload will also copy the values into the specified destination array.</remarks>
            <param name="reader"></param>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
            <param name="destArray">A float array that is to have the values copied into it at the same time as 'dest'.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadInts(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of integers and copies them into the destination pointer.
            </summary>
            <param name="reader"></param>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteInts(System.IO.BinaryWriter,System.Int32,System.IntPtr)">
            <summary>
            	Writes a specified number of integers.
            </summary>
            <param name="writer"></param>
            <param name="count">Number of values to write.</param>
            <param name="src">Pointer that holds the values.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadShorts(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of shorts and copies them into the destination pointer.
            </summary>
            <param name="reader"></param>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteShorts(System.IO.BinaryWriter,System.Int32,System.IntPtr)">
            <summary>
            	Writes a specified number of shorts.
            </summary>
            <param name="writer"></param>
            <param name="count">Number of values to write.</param>
            <param name="src">Pointer that holds the values.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadString(System.IO.BinaryReader)">
            <summary>
            	Reads from the stream up to the first endline character.
            </summary>
            <returns>A string formed from characters up to the first '\n' character.</returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteString(System.IO.BinaryWriter,System.String)">
            <summary>
            	Writes the string to the stream including the endline character.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadString(System.IO.BinaryReader,System.Char)">
            <summary>
            	Reads from the stream up to the specified delimiter character.
            </summary>
            <param name="reader"></param>
            <param name="delimiter">The character that signals the end of the string.</param>
            <returns>A string formed from characters up to the first instance of the specified delimeter.</returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteString(System.IO.BinaryWriter,System.String,System.Char)">
            <summary>
            	Writes the string to the stream including the specified delimiter character.
            </summary>
            <param name="str"></param>
            <param name="delimiter">The character that signals the end of the string.</param>
            <param name="writer"></param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadQuat(System.IO.BinaryReader)">
            <summary>
               Reads and returns a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteQuat(System.IO.BinaryWriter,Axiom.Math.Quaternion)">
            <summary>
               Reads and returns a Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadVector3(System.IO.BinaryReader)">
            <summary>
               Reads and returns a Vector3 structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteVector3(System.IO.BinaryWriter,Axiom.Math.Vector3)">
            <summary>
               Writes a Vector3 structure.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadVector4(System.IO.BinaryReader)">
            <summary>
               Reads and returns a Vector4 structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteVector4(System.IO.BinaryWriter,Axiom.Math.Vector4)">
            <summary>
               Writes a Vector4 structure.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFileChunk(System.IO.BinaryReader)">
            <summary>
            	Reads a chunk ID and chunk size.
            </summary>
            <returns>The chunk ID at the current location.</returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteChunk(System.IO.BinaryWriter,Axiom.Serialization.MeshChunkID,System.Int32)">
            <summary>
            	Writes a chunk ID and chunk size.  This would be more accurately named
                WriteChunkHeader, but this name is the counter of ReadChunk.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteChunk(System.IO.BinaryWriter,Axiom.Serialization.SkeletonChunkID,System.Int32)">
            <summary>
            	Writes a chunk ID and chunk size.  This would be more accurately named
                WriteChunkHeader, but this name is the counter of ReadChunk.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFileHeader(System.IO.BinaryReader)">
            <summary>
            	Reads a file header and checks the version string.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.WriteFileHeader(System.IO.BinaryWriter,System.String)">
            <summary>
            	Writes a file header and version string.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.Seek(System.IO.BinaryReader,System.Int64,System.IO.SeekOrigin)">
            <summary>
            	Skips to a particular part of the binary stream.
            </summary>
            <param name="reader"></param>
            <param name="length">Number of bytes to skip.</param>
            <param name="origin"></param>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.OffsetArray`1">
            <summary>
            This class emulates the behaviour of a vector&lt;T&gt;
            allowing T* access as IntPtr of a specified element
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.FloatConstantList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.IntConstantList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.Panel">
            <summary>
            	GuiElement representing a flat, single-material (or transparent) panel which can contain other elements.
            </summary>
            <remarks>
            	This class subclasses OverlayElementContainer because it can contain other elements. Like other
            	containers, if hidden it's contents are also hidden, if moved it's contents also move etc. 
            	The panel itself is a 2D rectangle which is either completely transparent, or is rendered 
            	with a single material. The texture(s) on the panel can be tiled depending on your requirements.
            	<p/>
            	This component is suitable for backgrounds and grouping other elements. Note that because
            	it has a single repeating material it cannot have a discrete border (unless the texture has one and
            	the texture is tiled only once). For a bordered panel, see it's subclass BorderPanel.
            	<p/>
            	Note that the material can have all the usual effects applied to it like multiple texture
            	layers, scrolling / animated textures etc. For multiple texture layers, you have to set 
            	the tiling level for each layer.
            </remarks>
        </member>
        <member name="T:Axiom.Overlays.OverlayElementContainer">
            <summary>
            	A 2D element which contains other OverlayElement instances.
            </summary>
            <remarks>
            	This is a specialization of OverlayElement for 2D elements that contain other
            	elements. These are also the smallest elements that can be attached directly
            	to an Overlay.
            	<p/>
            	OverlayElementContainers should be managed using OverlayElementManager. This class is responsible for
            	instantiating elements, and also for accepting new types of element
            	from plugins etc.
            </remarks>
        </member>
        <member name="T:Axiom.Overlays.OverlayElement">
            <summary>
            	Abstract definition of a 2D element to be displayed in an Overlay.
            </summary>
            <remarks>
            	This class abstracts all the details of a 2D element which will appear in
            	an overlay. In fact, not all OverlayElement instances can be directly added to an
            	Overlay, only those which are OverlayElementContainer instances (derived from this class) are able to be added,
            	however they can contain any OverlayElement however. This is done to enforce some level of grouping of widgets.
            	<br/>
            	OverlayElements should be managed using OverlayElementManager. This class is responsible for
            	instantiating / deleting elements, and also for accepting new types of element
            	from plugins etc.
            	<br/>
            	Note that positions / dimensions of 2D screen elements are expressed as parametric
            	values (0.0 - 1.0) because this makes them resolution-independent. However, most
            	screen resolutions have an aspect ratio of 1.3333:1 (width : height) so note that
            	in physical pixels 0.5 is wider than it is tall, so a 0.5x0.5 panel will not be
            	square on the screen (but it will take up exactly half the screen in both dimensions).
            </remarks>
        </member>
        <member name="T:Axiom.Scripting.IScriptableObject">
            <summary>
            An interface to provide access to object properties through strings
            </summary>
        </member>
        <member name="M:Axiom.Scripting.IScriptableObject.SetParameters(Axiom.Collections.NameValuePairList)">
            <summary>
            Set multiple properties at once using a <see cref="T:Axiom.Collections.NameValuePairList"/>
            </summary>
            <param name="parameters">the collection of parameters</param>
        </member>
        <member name="P:Axiom.Scripting.IScriptableObject.Properties">
            <summary>
            The property collection available
            </summary>
        </member>
        <member name="P:Axiom.Scripting.IScriptableObject.Item(System.String)">
            <summary>
            provides access to each property
            </summary>
            <param name="index">name of the property</param>
            <returns>the property value</returns>
        </member>
        <member name="M:Axiom.Scripting.ScriptableObject.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Scripting.ScriptableObject.SetParameters(Axiom.Collections.NameValuePairList)">
            <summary>
            Set multiple properties using a <see cref="T:Axiom.Collections.NameValuePairList"/>
            </summary>
            <param name="parameters">the list of properties to set</param>
        </member>
        <member name="P:Axiom.Scripting.ScriptableObject.Commands">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Scripting.ScriptableObject.Properties">
            <summary>
            a list of properties accessible through though a string interface
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.CopyFromTemplate(Axiom.Overlays.OverlayElement)">
            <summary>
               Copys data from the template element to this element to clone it.
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Hide">
            <summary>
               Hides an element if it is currently visible.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Initialize">
            <summary>
               Initialize the OverlayElement.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.NotifyParent(Axiom.Overlays.OverlayElementContainer,Axiom.Overlays.Overlay)">
            <summary>
               Internal method for notifying the gui element of it's parent and ultimate overlay.
            </summary>
            <param name="parent">Parent of this element.</param>
            <param name="overlay">Overlay this element belongs to.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.NotifyZOrder(System.Int32)">
            <summary>
            Internal method to notify the element when Zorder of parent overlay
            has changed.
            </summary>
            <param name="zOrder">The z order.</param>
            <remarks>
            Overlays have explicit Z orders. OverlayElements do not, they inherit the
            ZOrder of the overlay, and the Zorder is incremented for every container
            nested within this to ensure that containers are displayed behind contained
            items. This method is used internally to notify the element of a change in
            final zorder which is used to render the element.
            </remarks>
            <returns>
            Return the next zordering number availble. For single elements, this
            is simply zOrder + 1, but for containers, they increment it once for each
            child (more if those children are also containers).
            </returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.NotifyWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            Notifies the world transforms.
            </summary>
            <param name="xform">The xform.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.NotifyViewport">
            <summary>
            Notifies the viewport.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.PositionsOutOfDate">
            <summary>
               Tells this element to recaculate it's position.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.SetDimensions(System.Single,System.Single)">
            <summary>
            Sets the dimensions.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.SetParam(System.String,System.String)">
            <summary>
               Sets param values from script values.  Subclasses can define their own params in addition to what
               this base class already defines.
            </summary>
            <param name="param"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.SetPosition(System.Single,System.Single)">
            <summary>
            Sets the position of this element.
            </summary>
            <param name="left">The left.</param>
            <param name="top">The top.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Show">
            <summary>
               Shows this element if it was previously hidden.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Update">
            <summary>
               Internal method to update the element based on transforms applied.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Contains(System.Single,System.Single)">
            <summary>
            Returns true if xy is within the constraints of the component
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.FindElementAt(System.Single,System.Single)">
            <summary>
            Returns true if xy is within the constraints of the component
            </summary>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdateFromParent">
            <summary>
               Updates this elements transform based on it's parent.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenLeft(System.Single)">
            <summary>
            Sets the left of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="left"></param>
            <ogreequivilent>_setLeft</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenTop(System.Single)">
            <summary>
            Sets the top of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="top"></param>
            <ogreequivilent>_setTop</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenWidth(System.Single)">
            <summary>
            Sets the width of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="width"></param>
            <ogreequivilent>_setWidth</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenHeight(System.Single)">
            <summary>
            Sets the height of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="height"></param>
            <ogreequivilent>_setHeight</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenPosition(System.Single,System.Single)">
            <summary>
            Sets the left and top of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <ogreequivilent>_setPosition</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenDimensions(System.Single,System.Single)">
            <summary>
            Sets the width and height of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <ogreequivilent>_setDimensions</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdatePositionGeometry">
            <summary>
               Internal method which is triggered when the positions of the element get updated,
               meaning the element should be rebuilding it's mesh positions. Abstract since
               subclasses must implement this.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdateTextureGeometry">
            <summary>
            Internal method which is triggered when the UVs of the element get updated,
            meaning the element should be rebuilding it's mesh UVs. Abstract since
            subclasses must implement this.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
               Internal method to put the contents onto the render queue.
            </summary>
            <param name="queue">Current render queue.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetWorldOrientation">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
               Implementation of IRenderable.
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.UserData">
            <summary>
            Usefuel to hold custom userdata.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.SourceTemplate">
            <summary>
            Gets the SourceTemplate for this element
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Color">
            <summary>
               Sets the color on elements that support it.
            </summary>
            <remarks>
               Note that not all elements support this, but it is still a relevant base class property.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.DerivedLeft">
            <summary>
               Gets the 'left' position as derived from own left and that of parents.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.DerivedTop">
            <summary>
               Gets the 'top' position as derived from own top and that of parents.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Enabled">
            <summary>
               Gets/Sets whether or not this element is enabled.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Height">
            <summary>
               Gets/Sets the height of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.HorizontalAlignment">
            <summary>
               Gets/Sets the horizontal origin for this element.
            </summary>
            <remarks>
               By default, the horizontal origin for a OverlayElement is the left edge of the parent container
               (or the screen if this is a root element). You can alter this by using this property, which is
               especially useful when you want to use pixel-based metrics (see MetricsMode) since in this
               mode you can't use relative positioning.
               <p/>
               For example, if you were using Pixels metrics mode, and you wanted to place a 30x30 pixel
               crosshair in the center of the screen, you would use Center with a 'left' property of -15.
               <p/>
               Note that neither Center nor Right alter the position of the element based
               on it's width, you have to alter the 'left' to a negative number to do that; all this
               does is establish the origin. This is because this way you can align multiple things
               in the center and right with different 'left' offsets for maximum flexibility.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.IsContainer">
            <summary>
               Gets whether or not this element is a container type.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.IsCloneable">
            <summary>
               Gets/Sets whether or not this element can be cloned.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.IsVisible">
            <summary>
               Returns whether or not this element is currently visible.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Left">
            <summary>
               Gets/Sets the left position of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.MaterialName">
            <summary>
               Gets/Sets the name of the material in use by this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.MetricsMode">
            <summary>
               Tells this element how to interpret the position and dimension values it is given.
            </summary>
            <remarks>
               By default, OverlayElements are positioned and sized according to relative dimensions
               of the screen. This is to ensure portability between different resolutions when you
               want things to be positioned and sized the same way across all resolutions. However,
               sometimes you want things to be sized according to fixed pixels. In order to do this,
               you can call this method with the parameter Pixels. Note that if you then want
               to place your element relative to the center, right or bottom of it's parent, you will
               need to use the HorizontalAlignment and VerticalAlignment properties.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Name">
            <summary>
               Gets the name of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.ClippingRegion">
            <summary>
            Gets the clipping region of the element
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Parent">
            <summary>
               Gets the parent container of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Text">
             <summary>
                Sets the caption on elements that support it.
             </summary>
             <remarks>
                Not all elements support this, but it is still a relevant base class property.
             </remarks>
            <ogreequivilent>getCaption</ogreequivilent>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Top">
            <summary>
               Gets/Sets the top position of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.VerticalAlignment">
            <summary>
               Sets the vertical origin for this element.
            </summary>
            <remarks>
               By default, the vertical origin for a OverlayElement is the top edge of the parent container
               (or the screen if this is a root element). You can alter this by using this property, which is
               especially useful when you want to use pixel-based metrics (see MetricsMode) since in this
               mode you can't use relative positioning.
               <p/>
               For example, if you were using Pixels metrics mode, and you wanted to place a 30x30 pixel
               crosshair in the center of the screen, you would use Center with a 'top' property of -15.
               <p/>
               Note that neither Center or Bottom alter the position of the element based
               on it's height, you have to alter the 'top' to a negative number to do that; all this
               does is establish the origin. This is because this way you can align multiple things
               in the center and bottom with different 'top' offsets for maximum flexibility.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Width">
            <summary>
               Gets/Sets the width of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.ZOrder">
            <summary>
               Gets the z ordering of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.RenderOperation">
             <summary>
            
             </summary>
             <param name="value"></param>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.NumWorldTransforms">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.UseIdentityProjection">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.UseIdentityView">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.WorldOrientation">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.WorldPosition">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.MetricsModeAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.MetricsModeAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.HorizontalAlignmentAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.HorizontalAlignmentAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.VerticalAlignmentAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.VerticalAlignmentAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.TopAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.TopAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.LeftAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.LeftAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.WidthAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.WidthAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.HeightAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.HeightAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.VisibleAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.VisibleAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.CaptionAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.CaptionAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.MaterialAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.MaterialAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.#ctor(System.String)">
            <summary>
               Don't use directly, create through GuiManager.CreateElement.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.AddChild(Axiom.Overlays.OverlayElement)">
            <summary>
               Adds another OverlayElement to this container.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.AddChildElement(Axiom.Overlays.OverlayElement)">
            <summary>
               Adds another OverlayElement to this container.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.AddChildContainer(Axiom.Overlays.OverlayElementContainer)">
            <summary>
               Add a nested container to this container.
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.RemoveChild(System.String)">
            <summary>
            Removes a child element by its name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.GetChild(System.String)">
            <summary>
               Gets the named child of this container.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.PositionsOutOfDate">
            <summary>
               Tell the object and its children to recalculate their positions.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementContainer.Children">
            <summary>
            Gets the children OverlayElements as a Key-Value collection
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementContainer.IsContainer">
            <summary>
               This is most certainly a container.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementContainer.IsChildrenProcessEvents">
            <summary>
              Should this container pass events to their children 
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.SetTiling(System.Single,System.Single,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.UpdatePositionGeometry">
            <summary>
               Internal method for setting up geometry, called by GuiElement.Update
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.UpdateTextureGeometry">
            <summary>
               Called to update the texture coords when layers change.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.Panel.IsTransparent">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.Panel.MaterialName">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.TilingAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.TilingAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.TransparentAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.TransparentAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.UVCoordinatesAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.UVCoordinatesAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="T:Axiom.Media.CodecManager">
            <summary>
               Manages registering/fulfilling requests for codecs that handle various types of media.
            </summary>
        </member>
        <member name="F:Axiom.Media.CodecManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Media.CodecManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Media.CodecManager.codecs">
            <summary>
               List of registered media codecs.
            </summary>
        </member>
        <member name="M:Axiom.Media.CodecManager.RegisterCodecs">
            <summary>
                Register all default IL image codecs.
            </summary>
        </member>
        <member name="M:Axiom.Media.CodecManager.RegisterCodec(Axiom.Media.ICodec)">
            <summary>
               Registers a new codec that can handle a particular type of media files.
            </summary>
            <param name="codec"></param>
        </member>
        <member name="M:Axiom.Media.CodecManager.GetCodec(System.String)">
            <summary>
               Gets the codec registered for the passed in file extension.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.CodecManager.IsCodecAviable(System.String)">
            <summary>
            Checks whether a codec is aviable or not.
            </summary>
            <param name="extension">codec to check for</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.CodecManager.UnregisterCodec(Axiom.Media.ICodec)">
            <summary>
             URegisters a new codec that can handle a particular type of media files.
            </summary>
            <param name="codec">codec to unrerigster</param>
        </member>
        <member name="P:Axiom.Media.CodecManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Media.ICodec">
            <summary>
               Interface describing an object that can handle a form of media, be it
               a image, sound, video, etc.
            </summary>
        </member>
        <member name="M:Axiom.Media.ICodec.Decode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Codes the data from the input chunk into the output chunk.
            </summary>
            <param name="input">Input stream (encoded data).</param>
            <param name="output">Output stream (decoded data).</param>
            <param name="args">Variable number of extra arguments.</param>
            <returns>
               An object that holds data specific to the media format which this codec deal with.
               For example, an image codec might return a structure that has image related details,
               such as height, width, etc.
            </returns>
        </member>
        <member name="M:Axiom.Media.ICodec.Encode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Encodes the data in the input stream and saves the result in the output stream.
            </summary>
            <param name="input">Input stream (decoded data).</param>
            <param name="output">Output stream (encoded data).</param>
            <param name="args">Variable number of extra arguments.</param>
        </member>
        <member name="M:Axiom.Media.ICodec.EncodeToFile(System.IO.Stream,System.String,System.Object)">
            <summary>
                Encodes data to a file.
            </summary>
            <param name="input">Stream containing data to write.</param>
            <param name="fileName">Filename to output to.</param>
            <param name="codecData">Extra data to use in order to describe the codec data.</param>
        </member>
        <member name="P:Axiom.Media.ICodec.Type">
            <summary>
               Gets the type of data that this codec is meant to handle, typically a file extension.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.BaseCollection">
            <summary>
            	Serves as a basis for strongly typed collections in the math lib.
            </summary>
            <remarks>
            	Can't wait for Generics in .Net Framework 2.0!   
            </remarks>
        </member>
        <member name="F:Axiom.Math.Collections.BaseCollection.objectList">
            <summary></summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.#ctor">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Add(System.Object)">
            <summary>
            	Adds an item to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Clear">
            <summary>
            	Clears all objects from the collection.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Remove(System.Object)">
            <summary>
            	Removes the item from the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Reset">
            <summary>
            	Resets the in progress enumerator.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.MoveNext">
            <summary>
            	Moves to the next item in the enumeration if there is one.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.Item(System.Int32)">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.IsSynchronized">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.SyncRoot">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.Current">
            <summary>
            	Returns the current object in the enumeration.
            </summary>
        </member>
        <member name="T:Axiom.Math.Sphere">
            <summary>
            	A standard sphere, used mostly for bounds checking.
            </summary>
            <remarks>
            	A sphere in math texts is normally represented by the function
            	x^2 + y^2 + z^2 = r^2 (for sphere's centered on the origin). We store spheres
            	simply as a center point and a radius.
            </remarks>
        </member>
        <member name="M:Axiom.Math.Sphere.#ctor">
            <summary>
            	Creates a unit sphere centered at the origin.
            </summary>
        </member>
        <member name="M:Axiom.Math.Sphere.#ctor(Axiom.Math.Vector3,Axiom.Math.Real)">
            <summary>
            Creates an arbitrary spehere.
            </summary>
            <param name="center">Center point of the sphere.</param>
            <param name="radius">Radius of the sphere.</param>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Tests for intersection between this sphere and another sphere.
            </summary>
            <param name="sphere">Other sphere.</param>
            <returns>True if the spheres intersect, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Returns whether or not this sphere interects a box.
            </summary>
            <param name="box"></param>
            <returns>True if the box intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.Plane)">
            <summary>
            	Returns whether or not this sphere interects a plane.
            </summary>
            <param name="plane"></param>
            <returns>True if the plane intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.Vector3)">
            <summary>
            	Returns whether or not this sphere interects a Vector3.
            </summary>
            <param name="vector"></param>
            <returns>True if the vector intersects, false otherwise.</returns>
        </member>
        <member name="P:Axiom.Math.Sphere.Center">
            <summary>
            	Gets/Sets the center of the sphere.
            </summary>
        </member>
        <member name="P:Axiom.Math.Sphere.Radius">
            <summary>
            	Gets/Sets the radius of the sphere.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureBindingType">
            <summary>
            The type of unit to bind the texture settings to.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureBindingType.Fragment">
            <summary>
             Regular fragment processing unit - the default.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureBindingType.Vertex">
            <summary>
            Vertex processing unit - indicates this unit will be used for a vertex texture fetch.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.UVWAddressing">
            <summary>
            Texture addressing mode for each texture coordinate.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureUnitState">
            <summary>
            	Class representing the state of a single texture unit during a Pass of a
            	Technique, of a Material.
            </summary>
            <remarks> 	
            	Texture units are pipelines for retrieving texture data for rendering onto
            	your objects in the world. Using them is common to both the fixed-function and 
            	the programmable (vertex and fragment program) pipeline, but some of the 
            	settings will only have an effect in the fixed-function pipeline (for example, 
            	setting a texture rotation will have no effect if you use the programmable
            	pipeline, because this is overridden by the fragment program). The effect
            	of each setting as regards the 2 pipelines is commented in each setting.
            	<p/>
            	When I use the term 'fixed-function pipeline' I mean traditional rendering
            	where you do not use vertex or fragment programs (shaders). Programmable 
            	pipeline means that for this pass you are using vertex or fragment programs.
            </remarks>
            TODO: Destroy controllers
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.MaxAnimationFrames">
            <summary>
               Maximum amount of animation frames allowed.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.parent">
            <summary>
               The parent Pass that owns this TextureUnitState.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texCoordSet">
            <summary>
               Index of the texture coordinate set to use for texture mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texAddressingMode">
            <summary>
               Addressing mode to use for texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texBorderColor">
            <summary>
               Border color to use when texture addressing mode is set to Border
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorBlendMode">
            <summary>
               Reference to a class containing the color blending operation params for this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.alphaBlendMode">
            <summary>
               Reference to a class containing the alpha blending operation params for this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorBlendFallbackSrc">
            <summary>
               Fallback source blending mode, for use if the desired mode is not available.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorBlendFallbackDest">
            <summary>
               Fallback destination blending mode, for use if the desired mode is not available.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorOp">
            <summary>
               Operation to use (add, modulate, etc.) for color blending between stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isBlank">
            <summary>
               Is this a blank layer (i.e. no textures, or texture failed to load)?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isCubic">
            <summary>
               Is this a series of 6 2D textures to make up a cube?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.numFrames">
            <summary>
               Number of frames for this layer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.animDuration">
            <summary>
               Duration (in seconds) of the animated texture (if any).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.currentFrame">
            <summary>
               Index of the current frame of animation (always 0 for single texture stages).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.frames">
            <summary>
               Store names of textures for animation frames.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.name">
            <summary>
                Optional name for the texture unit state
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.textureNameAlias">
            <summary>
                Optional alias for texture frames
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.recalcTexMatrix">
            <summary>
               Flag the determines if a recalc of the texture matrix is required, usually set after a rotate or
               other transformations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.rotate">
            <summary>
               Rotation value of the texture transformation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texMatrix">
            <summary>
               4x4 texture matrix which gets updated based on various transformations made to this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.effectList">
            <summary>
               List of effects to apply during this texture stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.textureType">
            <summary>
               Type of texture this is.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.desiredFormat">
            <summary>
            the desired pixel format when load the texture
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.textureSrcMipmaps">
            <summary>
            how many mipmaps have been requested for the texture
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isAlpha">
            <summary>
            whether this texture is requested to be loaded as alpha if single channel
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.hwGamma">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.minFilter">
            <summary>
               Texture filtering - minification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.magFilter">
            <summary>
               Texture filtering - magnification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.mipFilter">
            <summary>
               Texture filtering - mipmapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isDefaultFiltering">
            <summary>
               Is the filtering level the default?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.animController">
            <summary>
                Reference to an animation controller for this texture unit.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.environMap">
            <summary>
                Reference to the environment mapping type for this texunit.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.maxAnisotropy">
            <summary>
               Anisotropy setting for this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isDefaultAniso">
            <summary>
               Is anisotropy the default?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.#ctor(Axiom.Graphics.Pass)">
            <summary>
            	Default constructor.
            </summary>
            <param name="parent">Parent Pass of this TextureUnitState.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.#ctor(Axiom.Graphics.Pass,System.String)">
            <summary>
            	Name based constructor.
            </summary>
            <param name="parent">Parent Pass of this texture stage.</param>
            <param name="textureName">Name of the texture for this texture stage.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.#ctor(Axiom.Graphics.Pass,System.String,System.Int32)">
            <summary>
            	Constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureAddressingMode(Axiom.Graphics.TextureAddressing)">
            <summary>
            Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
            </summary>
            <remarks>
            The default is TAM_WRAP i.e. the texture repeats over values of 1.0.
            This is a shortcut method which sets the addressing mode for all
            coordinates at once; you can also call the more specific method
            to set the addressing mode per coordinate.
            This applies for both the fixed-function and programmable pipelines.
            </remarks>
            <param name="tam"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureAddressingMode(Axiom.Graphics.TextureAddressing,Axiom.Graphics.TextureAddressing,Axiom.Graphics.TextureAddressing)">
            <summary>
            Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
            </summary>
            <remarks>
            The default is TAM_WRAP i.e. the texture repeats over values of 1.0.
            This applies for both the fixed-function and programmable pipelines.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureAddressingMode(Axiom.Graphics.UVWAddressing)">
            <summary>
            Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
            </summary>
            <remarks>
            The default is TAM_WRAP i.e. the texture repeats over values of 1.0.
            This applies for both the fixed-function and programmable pipelines.
            </remarks>
            <param name="uvw"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetProjectiveTexturing(System.Boolean,Axiom.Core.Frustum)">
            <summary>
               Enables or disables projective texturing on this texture unit.
            </summary>
            <remarks>
               <p>
               Projective texturing allows you to generate texture coordinates 
               based on a Frustum, which gives the impression that a texture is
               being projected onto the surface. Note that once you have called
               this method, the texture unit continues to monitor the Frustum you 
               passed in and the projection will change if you can alter it. It also
               means that the Frustum object you pass remains in existence for as long
               as this TextureUnitState does.
               </p>
               <p>
               This effect cannot be combined with other texture generation effects, 
               such as environment mapping. It also has no effect on passes which 
               have a vertex program enabled - projective texturing has to be done
               in the vertex program instead.
               </p>
            </remarks>
            <param name="enable">
               Whether to enable / disable
            </param>
            <param name="projectionSettings">
               The Frustum which will be used to derive the projection parameters.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.GetEffect(System.Int32)">
            <summary>
               Gets the texture effect at the specified index.
            </summary>
            <param name="index">Index of the texture effect to retrieve.</param>
            <returns>The TextureEffect at the specified index.</returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RemoveAllEffects">
            <summary>
               Removes all effects from this texture stage.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RemoveEffect(Axiom.Graphics.TextureEffect)">
            <summary>
               Removes the specified effect from the list of effects being applied during this
               texture stage.
            </summary>
            <param name="effect">Effect to remove.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOpMultipassFallback(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)">
            <summary>
               Sets the multipass fallback operation for this layer, if you used TextureUnitState.SetColorOperationEx
               and not enough multitexturing hardware is available.
            </summary>
            <remarks>
               Because some effects exposed using TextureUnitState.SetColorOperationEx are only supported under
               multitexturing hardware, if the hardware is lacking the system must fallback on multipass rendering,
               which unfortunately doesn't support as many effects. This method is for you to specify the fallback
               operation which most suits you.
               <p/>
               You'll notice that the interface is the same as the Material.SetSceneBlending method; this is
               because multipass rendering IS effectively scene blending, since each layer is rendered on top
               of the last using the same mechanism as making an object transparent, it's just being rendered
               in the same place repeatedly to get the multitexture effect.
               <p/>
               If you use the simpler (and hence less flexible) TextureUnitState.SetColorOperation method you
               don't need to call this as the system sets up the fallback for you.
               <p/>
               This option has no effect in the programmable pipeline, because there is no multipass fallback
               and multitexture blending is handled by the fragment shader.
            </remarks>
            <param name="src">How to apply the source color during blending.</param>
            <param name="dest">How to affect the destination color during blending.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetCubicTextureName(System.String,System.Boolean)">
            <summary>
               Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube.
            </summary>
            <remarks>
               Cubic textures are made up of 6 separate texture images. Each one of these is an orthoganal view of the
               world with a FOV of 90 degrees and an aspect ratio of 1:1. You can generate these from 3D Studio by
               rendering a scene to a reflection map of a transparent cube and saving the output files.
               <p/>
               Cubic maps can be used either for skyboxes (complete wrap-around skies, like space) or as environment
               maps to simulate reflections. The system deals with these 2 scenarios in different ways:
               <ol>
               <li>
               <p>
               For cubic environment maps, the 6 textures are combined into a single 'cubic' texture map which
               is then addressed using 3D texture coordinates. This is required because you don't know what
               face of the box you're going to need to address when you render an object, and typically you
               need to reflect more than one face on the one object, so all 6 textures are needed to be
               'active' at once. Cubic environment maps are enabled by calling this method with the forUVW
               parameter set to true, and then calling <code>SetEnvironmentMap(true)</code>.
               </p>
               <p>
               Note that not all cards support cubic environment mapping.
               </p>
               </li>
               <li>
               <p>
               For skyboxes, the 6 textures are kept separate and used independently for each face of the skybox.
               This is done because not all cards support 3D cubic maps and skyboxes do not need to use 3D
               texture coordinates so it is simpler to render each face of the box with 2D coordinates, changing
               texture between faces.
               </p>
               <p>
               Skyboxes are created by calling SceneManager.SetSkyBox.
               </p>
               </li>
               </ol>
               <p/>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="textureName">
               The basic name of the texture e.g. brickwall.jpg, stonefloor.png. There must be 6 versions
               of this texture with the suffixes _fr, _bk, _up, _dn, _lf, and _rt (before the extension) which
               make up the 6 sides of the box. The textures must all be the same size and be powers of 2 in width &amp; height.
               If you can't make your texture names conform to this, use the alternative method of the same name which takes
               an array of texture names instead.
            </param>
            <param name="forUVW">
               Set to true if you want a single 3D texture addressable with 3D texture coordinates rather than
               6 separate textures. Useful for cubic environment mapping.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetCubicTextureName(System.String[],System.Boolean)">
            <summary>
               Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube.
            </summary>
            <remarks>
               Cubic textures are made up of 6 separate texture images. Each one of these is an orthoganal view of the
               world with a FOV of 90 degrees and an aspect ratio of 1:1. You can generate these from 3D Studio by
               rendering a scene to a reflection map of a transparent cube and saving the output files.
               <p/>
               Cubic maps can be used either for skyboxes (complete wrap-around skies, like space) or as environment
               maps to simulate reflections. The system deals with these 2 scenarios in different ways:
               <ul>
               <li>
               <p>
               For cubic environment maps, the 6 textures are combined into a single 'cubic' texture map which
               is then addressed using 3D texture coordinates. This is required because you don't know what
               face of the box you're going to need to address when you render an object, and typically you
               need to reflect more than one face on the one object, so all 6 textures are needed to be
               'active' at once. Cubic environment maps are enabled by calling this method with the forUVW
               parameter set to true, and then calling <code>SetEnvironmentMap(true)</code>.
               </p>
               <p>
               Note that not all cards support cubic environment mapping.
               </p>
               </li>
               <li>
               <p>
               For skyboxes, the 6 textures are kept separate and used independently for each face of the skybox.
               This is done because not all cards support 3D cubic maps and skyboxes do not need to use 3D
               texture coordinates so it is simpler to render each face of the box with 2D coordinates, changing
               texture between faces.
               </p>
               <p>
               Skyboxes are created by calling SceneManager.SetSkyBox.
               </p>
               </li>
               </ul>
               <p/>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="textureNames">
               6 versions of this texture with the suffixes _fr, _bk, _up, _dn, _lf, and _rt (before the extension) which
               make up the 6 sides of the box. The textures must all be the same size and be powers of 2 in width &amp; height.
               If you can't make your texture names conform to this, use the alternative method of the same name which takes
               an array of texture names instead.
            </param>
            <param name="forUVW">
               Set to true if you want a single 3D texture addressable with 3D texture coordinates rather than
               6 separate textures. Useful for cubic environment mapping.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperation(Axiom.Graphics.LayerBlendOperation)">
            <summary>
            	Determines how this texture layer is combined with the one below it (or the diffuse color of
            	the geometry if this is layer 0).
            </summary>
            <remarks>
               This method is the simplest way to blend tetxure layers, because it requires only one parameter,
               gives you the most common blending types, and automatically sets up 2 blending methods: one for
               if single-pass multitexturing hardware is available, and another for if it is not and the blending must
               be achieved through multiple rendering passes. It is, however, quite limited and does not expose
               the more flexible multitexturing operations, simply because these can't be automatically supported in
               multipass fallback mode. If want to use the fancier options, use 
               <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)"/>,
               but you'll either have to be sure that enough multitexturing units will be available, or you should
               explicitly set a fallback using <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOpMultipassFallback(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)"/>.
               <p/>
               The default method is LayerBlendOperation.Modulate for all layers.
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="operation">One of the LayerBlendOperation enumerated blending types.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)">
            <summary>
               For setting advanced blending options.
            </summary>
            <remarks>
               This is an extended version of the <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOperation(Axiom.Graphics.LayerBlendOperation)"/> method which allows
               extremely detailed control over the blending applied between this and earlier layers.
               See the IMPORTANT note below about the issues between mulitpass and multitexturing that
               using this method can create.
               <p/>
               Texture color operations determine how the final color of the surface appears when
               rendered. Texture units are used to combine color values from various sources (ie. the
               diffuse color of the surface from lighting calculations, combined with the color of
               the texture). This method allows you to specify the 'operation' to be used, ie. the
               calculation such as adds or multiplies, and which values to use as arguments, such as
               a fixed value or a value from a previous calculation.
               <p/>
               The defaults for each layer are:
               <ul>
               <li>op = Modulate</li>
               <li>source1 = Texture</li>
               <li>source2 = Current</li>
               </ul>
               ie. each layer takes the color results of the previous layer, and multiplies them
               with the new texture being applied. Bear in mind that colors are RGB values from
               0.0 - 1.0 so multiplying them together will result in values in the same range,
               'tinted' by the multiply. Note however that a straight multiply normally has the
               effect of darkening the textures - for this reason there are brightening operations
               like ModulateX2. See the LayerBlendOperation and LayerBlendSource enumerated
               types for full details.
               <p/>
               Because of the limitations on some underlying APIs (Direct3D included)
               the Texture argument can only be used as the first argument, not the second.
               <p/>
               The final 3 parameters are only required if you decide to pass values manually
               into the operation, i.e. you want one or more of the inputs to the color calculation
               to come from a fixed value that you supply. Hence you only need to fill these in if
               you supply <code>Manual</code> to the corresponding source, or use the 
               <code>BlendManual</code> operation.
               <p/>
               The engine tries to use multitexturing hardware to blend texture layers
               together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a
               GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object
               multiple times with different textures. This is both less efficient and there is a smaller
               range of blending operations which can be performed. For this reason, if you use this method
               you MUST also call <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOpMultipassFallback(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)"/> to specify which effect you
               want to fall back on if sufficient hardware is not available.
               <p/>
               If you wish to avoid having to do this, use the simpler <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOperation(Axiom.Graphics.LayerBlendOperation)"/> method
               which allows less flexible blending options but sets up the multipass fallback automatically,
               since it only allows operations which have direct multipass equivalents.
               <p/>
               This has no effect in the programmable pipeline.
            </remarks>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first color to the operation e.g. texture color.</param>
            <param name="source2">The source of the second color to the operation e.g. current surface color.</param>
            <param name="arg1">Manually supplied color value (only required if source1 = Manual).</param>
            <param name="arg2">Manually supplied color value (only required if source2 = Manual)</param>
            <param name="blendFactor">
               Manually supplied 'blend' value - only required for operations
               which require manual blend e.g. LayerBlendOperationEx.BlendManual
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first color to the operation e.g. texture color.</param>
            <param name="source2">The source of the second color to the operation e.g. current surface color.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,Axiom.Core.ColorEx)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first color to the operation e.g. texture color.</param>
            <param name="source2">The source of the second color to the operation e.g. current surface color.</param>
            <param name="arg1">Manually supplied color value (only required if source1 = Manual).</param>		
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAlphaOperation(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,System.Single,System.Single,System.Single)">
            <summary>
               Sets the alpha operation to be applied to this texture.
            </summary>
            <remarks>
               This works in exactly the same way as SetColorOperation, except
               that the effect is applied to the level of alpha (i.e. transparency)
               of the texture rather than its color. When the alpha of a texel (a pixel
               on a texture) is 1.0, it is opaque, wheras it is fully transparent if the
               alpha is 0.0. Please refer to the SetColorOperation method for more info.
            </remarks>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first alpha value to the operation e.g. texture alpha.</param>
            <param name="source2">The source of the second alpha value to the operation e.g. current surface alpha.</param>
            <param name="arg1">Manually supplied alpha value (only required if source1 = LayerBlendSource.Manual).</param>
            <param name="arg2">Manually supplied alpha value (only required if source2 = LayerBlendSource.Manual).</param>
            <param name="blendFactor">Manually supplied 'blend' value - only required for operations
               which require manual blend e.g. LayerBlendOperationEx.BlendManual.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAlphaOperation(Axiom.Graphics.LayerBlendOperationEx)">
            <summary>
               Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetEnvironmentMap(System.Boolean)">
            <summary>
               Overloaded method.
            </summary>
            <param name="enable"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetEnvironmentMap(System.Boolean,Axiom.Graphics.EnvironmentMap)">
            <summary>
               Turns on/off texture coordinate effect that makes this layer an environment map.
            </summary>
            <remarks>
               Environment maps make an object look reflective by using the object's vertex normals relative
               to the camera view to generate texture coordinates.
               <p/>
               The vectors generated can either be used to address a single 2D texture which
               is a 'fish-eye' lens view of a scene, or a 3D cubic environment map which requires 6 textures
               for each side of the inside of a cube. The type depends on what texture you set up - if you use the
               setTextureName method then a 2D fisheye lens texture is required, whereas if you used setCubicTextureName
               then a cubic environemnt map will be used.
               <p/>
               This effect works best if the object has lots of gradually changing normals. The texture also
               has to be designed for this effect - see the example spheremap.png included with the sample
               application for a 2D environment map; a cubic map can be generated by rendering 6 views of a
               scene to each of the cube faces with orthoganal views.
               <p/>
               Enabling this disables any other texture coordinate generation effects.
               However it can be combined with texture coordinate modification functions, which then operate on the
               generated coordinates rather than static model texture coordinates.
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="enable">True to enable, false to disable.</param>
            <param name="envMap">
               If set to true, instead of being based on normals the environment effect is based on
               vertex positions. This is good for planar surfaces.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.GetFrameTextureName(System.Int32)">
            <summary>
               Gets the name of the texture associated with a frame.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="frame">Index of the frame to retreive the texture name for.</param>
            <returns>The name of the texture at the specified frame index.</returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.GetTextureFiltering(Axiom.Graphics.FilterType)">
            <summary>
               Gets the texture filtering for the given type.
            </summary>
            <param name="type">Type of filtering options to retreive.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAnimatedTextureName(System.String,System.Int32,System.Single)">
            <summary>
                Sets the names of the texture images for an animated texture.
            </summary>
            <remarks>
                Animated textures are just a series of images making up the frames of the animation. All the images
                must be the same size, and their names must have a frame number appended before the extension, e.g.
                if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_1.jpg" and "wall_2.jpg".
                <p/>
                You can change the active frame on a texture layer by setting the CurrentFrame property.
                <p/>
                Note: If you can't make your texture images conform to the naming standard layed out here, you
                can call the alternative SetAnimatedTextureName method which takes an array of names instead.
            </remarks>
            <param name="name">The base name of the series of textures to use.</param>
            <param name="numFrames">Number of frames to be used for this animation.</param>
            <param name="duration">
                Total length of the animation sequence.  When set to 0, automatic animation does not occur.
                In that scenario, the values can be changed manually by setting the CurrentFrame property.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAnimatedTextureName(System.String[],System.Int32,System.Single)">
            <summary>
                Sets the names of the texture images for an animated texture.
            </summary>
            <remarks>
                Animated textures are just a series of images making up the frames of the animation. All the images
                must be the same size, and their names must have a frame number appended before the extension, e.g.
                if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_1.jpg" and "wall_2.jpg".
                <p/>
                You can change the active frame on a texture layer by setting the CurrentFrame property.
            </remarks>
            <param name="names">An array containing the array names to use for the animation.</param>
            <param name="numFrames">Number of frames to be used for this animation.</param>
            <param name="duration">
                Total length of the animation sequence.  When set to 0, automatic animation does not occur.
                In that scenario, the values can be changed manually by setting the CurrentFrame property.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScroll(System.Single,System.Single)">
            <summary>
               Sets the translation offset of the texture, ie scrolls the texture.
            </summary>
            <remarks>
               This method sets the translation element of the texture transformation, and is easier to use than setTextureTransform if
               you are combining translation, scaling and rotation in your texture transformation. Again if you want
               to animate these values you need to use a Controller
               <p/>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The amount the texture should be moved horizontally (u direction).</param>
            <param name="v">The amount the texture should be moved vertically (v direction).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScrollU(System.Single)">
            <summary>
               Same as in SetTextureScroll, but sets only U value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The amount the texture should be moved horizontally (u direction).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScrollV(System.Single)">
            <summary>
               Same as in SetTextureScroll, but sets only V value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="v">The amount the texture should be moved vertically (v direction).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetScrollAnimation(System.Single,System.Single)">
            <summary>
            	Sets up an animated scroll for the texture layer.
            </summary>
            <remarks>
               Useful for creating constant scrolling effects on a texture layer (for varying scrolls, <see cref="M:Axiom.Graphics.TextureUnitState.SetTransformAnimation(Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)"/>).
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="uSpeed">The number of horizontal loops per second (+ve=moving right, -ve = moving left).</param>
            <param name="vSpeed">The number of vertical loops per second (+ve=moving up, -ve= moving down).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetRotateAnimation(System.Single)">
            <summary>
            	Sets up an animated texture rotation for this layer.
            </summary>
            <remarks>
               Useful for constant rotations (for varying rotations, <see cref="M:Axiom.Graphics.TextureUnitState.SetTransformAnimation(Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)"/>).
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="speed">The number of complete counter-clockwise revolutions per second (use -ve for clockwise)</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTransformAnimation(Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Sets up a general time-relative texture modification effect.
            </summary>
            <remarks>
               This can be called multiple times for different values of <paramref name="transType"/>, but only the latest effect
               applies if called multiple time for the same <paramref name="transType"/>.
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="transType">The type of transform, either translate (scroll), scale (stretch) or rotate (spin).</param>
            <param name="waveType">The shape of the wave, see <see cref="T:Axiom.Controllers.WaveformType"/> enum for details</param>
            <param name="baseVal">The base value for the function (range of output = {base, base + amplitude}).</param>
            <param name="frequency">The speed of the wave in cycles per second.</param>
            <param name="phase">The offset of the start of the wave, e.g. 0.5 to start half-way through the wave.</param>
            <param name="amplitude">Scales the output so that instead of lying within [0..1] it lies within [0..(1 * amplitude)] for exaggerated effects.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScale(System.Single,System.Single)">
            <summary>
               Sets the scaling factor of the texture.
            </summary>
            <remarks>
               This method sets the scale element of the texture transformation, and is easier to use than
               setTextureTransform if you are combining translation, scaling and rotation in your texture transformation. Again if you want
               to animate these values you need to use a Controller (see ControllerManager and it's methods for
               more information).
               <p/>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The value by which the texture is to be scaled horizontally.</param>
            <param name="v">The value by which the texture is to be scaled vertically.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScaleU(System.Single)">
            <summary>
               Same as in SetTextureScale, but sets only U value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The value by which the texture is to be scaled horizontally.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScaleV(System.Single)">
            <summary>
               Same as in SetTextureScale, but sets only V value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="v">The value by which the texture is to be scaled vertically.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureFiltering(Axiom.Graphics.TextureFiltering)">
            <summary>
               Set the texture filtering for this unit, using the simplified interface.
            </summary>
            <remarks>
               You also have the option of specifying the minification, magnification 
               and mip filter individually if you want more control over filtering 
               options. See the SetTextureFiltering overloads for details. 
               <p/>
               Note: This option applies in both the fixed function and programmable pipeline.
            </remarks>
            <param name="filter">
               The high-level filter type to use.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureFiltering(Axiom.Graphics.FilterType,Axiom.Graphics.FilterOptions)">
            <summary>
               Set a single filtering option on this texture unit.
            </summary>
            <param name="type">
               The filtering type to set.
            </param>
            <param name="options">
               The filtering options to set.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureFiltering(Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions)">
            <summary>
               Set a the detailed filtering options on this texture unit.
            </summary>
            <param name="minFilter">
               The filtering to use when reducing the size of the texture. Can be Point, Linear or Anisotropic.
            </param>
            <param name="magFilter">
               The filtering to use when increasing the size of the texture. Can be Point, Linear or Anisotropic.
            </param>
            <param name="mipFilter">
               The filtering to use between mipmap levels. Can be None (no mipmap), Point or Linear (trilinear).
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureName(System.String,Axiom.Graphics.TextureType,System.Int32,System.Boolean)">
            <summary>
               Sets this texture layer to use a single texture, given the name of the texture to use on this layer.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="name">Name of the texture.</param>
            <param name="type">Type of texture this is.</param>
            <param name="mipmaps"></param>
            <param name="alpha"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureName(System.String)">
            <summary>
               Sets this texture layer to use a single texture, given the name of the texture to use on this layer.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="name">Name of the texture.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureName(System.String,Axiom.Graphics.TextureType,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureRotate(System.Single)">
            <summary>
               Sets the counter-clockwise rotation factor applied to texture coordinates.
            </summary>
            <remarks>
               This sets a fixed rotation angle - if you wish to animate this, see the
               <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureRotator(Axiom.Graphics.TextureUnitState,System.Single)"/> method.
               <p/>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="degrees">The angle of rotation in degrees (counter-clockwise).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RecalcTextureMatrix">
            <summary>
            	Used to update the texture matrix if need be.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.AddEffect(Axiom.Graphics.TextureEffect)">
            <summary>
            	Generic method for setting up texture effects.
            </summary>
            <remarks>
               Allows you to specify effects directly by using the TextureEffectType enumeration. The
               arguments that go with it depend on the effect type. Only one effect of
               each type can be applied to a texture layer.
               <p/>
               This method is used internally, but it is better generally for applications to use the
               more intuitive specialized methods such as SetEnvironmentMap and SetScroll.
            </remarks>
            <param name="effect"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RemoveEffect(Axiom.Graphics.TextureEffectType)">
            <summary>
            	Removes effects of the specified type from this layers effect list.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.CreateAnimationController">
            <summary>
                Creates an animation controller if needed for this texture unit.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.CreateEffectController(Axiom.Graphics.TextureEffect)">
            <summary>
            	Used internally to create a new controller for this layer given the requested effect.
            </summary>
            <param name="effect"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.Load">
            <summary>
               Internal method for loading this texture stage as part of Material.Load.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.Unload">
            <summary>
               Internal method for unloading this object as part of Material.Unload.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.NotifyNeedsRecompile">
            <summary>
               Notifies the parent that it needs recompilation.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.ApplyTextureAliases(System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>
            Applies texture names to Texture Unit State with matching texture name aliases.
            If no matching aliases are found then the TUS state does not change.
            </summary>
            <remarks>
            Cubic, 1d, 2d, and 3d textures are determined from current state of the Texture Unit.
            Assumes animated frames are sequentially numbered in the name.
            If matching texture aliases are found then true is returned.
            </remarks>
            <param name="aliasList">is a map container of texture alias, texture name pairs</param>
            <param name="apply">set true to apply the texture aliases else just test to see if texture alias matches are found.</param>
            <returns>True if matching texture aliases were found in the Texture Unit State.</returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.CopyTo(Axiom.Graphics.TextureUnitState)">
            <summary>
            	Used to clone a texture layer.  Mainly used during a call to Clone on a Material.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.Clone(Axiom.Graphics.Pass)">
            <summary>
            	Used to clone a texture layer.  Mainly used during a call to Clone on a Material or Pass.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.Parent">
            	Gets the number of frames for a texture.
            <summary>
               Gets a reference to the Pass that owns this TextureUnitState.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsLoaded">
            <summary>
               Returns true if the resource for this texture layer have been loaded.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureCoordSet">
            <summary>
            	Gets/Sets the texture coordinate set to be used by this texture layer.
            </summary>
            <remarks>
            	Default is 0 for all layers. Only change this if you have provided multiple texture coords per
            	vertex.
            	<p/>
            	Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureAddressingMode">
            <summary>
            Gets the texture addressing mode for a given coordinate, 
            i.e. what happens at uv values above 1.0.
            </summary>
            <remarks>
               The default is <code>TextureAddressing.Wrap</code> i.e. the texture repeats over values of 1.0.
               This applies for both the fixed-function and programmable pipelines.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureBorderColor">
            <summary>
               Gets/Sets the texture border color, which is used to fill outside the 0-1 range of
               texture coordinates when the texture addressing mode is set to Border.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorBlendMode">
            <summary>
            	Gets a structure that describes the layer blending mode parameters.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.AlphaBlendMode">
            <summary>
            	Gets a structure that describes the layer blending mode parameters.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorBlendFallbackSource">
            <summary>
               Gets/Sets the multipass fallback for color blending operation source factor.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorBlendFallbackDest">
            <summary>
               Gets/Sets the multipass fallback for color blending operation destination factor.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsBlank">
            <summary>
               Gets/Sets wether this texture layer is currently blank.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsCubic">
            <summary></summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.NumFrames">
            <summary></summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.CurrentFrame">
            <summary>
            	Gets/Sets the active frame in an animated or multi-image texture.
            </summary>
            <remarks>
            	An animated texture (or a cubic texture where the images are not combined for 3D use) is made up of
            	a number of frames. This method sets the active frame.
            	<p/>
            	Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.Name">
            <summary>
               Get/Set the name of this texture unit state
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureNameAlias">
            <summary>
               Get/Set the alias for this texture unit state.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureName">
            <summary>
            	Gets/Sets the name of the texture for this texture pass.
            </summary>
            <remarks>
               This will either always be a single name for this layer,
               or will be the name of the current frame for an animated
               or otherwise multi-frame texture.
               <p/>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureScrollU">
            <summary>
               U coord of the texture transformation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureScrollV">
            <summary>
               V coord of the texture transformation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureAnimU">
            <summary>
               U coord of the texture scroll animation
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureAnimV">
            <summary>
               V coord of the texture scroll animation
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ScaleU">
            <summary>
               U scale value of the texture transformation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ScaleV">
            <summary>
               V scale value of the texture transformation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureMatrix">
            <summary>
            	Gets/Sets the Matrix4 that represents transformation to the texture in this layer.
            </summary>
            <remarks>
               Texture coordinates can be modified on a texture layer to create effects like scrolling
               textures. A texture transform can either be applied to a layer which takes the source coordinates
               from a fixed set in the geometry, or to one which generates them dynamically (e.g. environment mapping).
               <p/>
               It's obviously a bit impractical to create scrolling effects by calling this method manually since you
               would have to call it every frame with a slight alteration each time, which is tedious. Instead
               you can use the ControllerManager class to create a Controller object which will manage the
               effect over time for you. See <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureUVScroller(Axiom.Graphics.TextureUnitState,System.Single)"/> and it's sibling methods for details.<BR/>
               In addition, if you want to set the individual texture transformations rather than concatenating them
               yourself, use <see cref="M:Axiom.Graphics.TextureUnitState.SetTextureScroll(System.Single,System.Single)"/>, <see cref="M:Axiom.Graphics.TextureUnitState.SetTextureScroll(System.Single,System.Single)"/> and <see cref="M:Axiom.Graphics.TextureUnitState.SetTextureRotate(System.Single)"/>. 
               <p/>
               This has no effect in the programmable pipeline.
            </remarks>
            <seealso cref="T:Axiom.Controllers.Controller`1"/><seealso cref="T:Axiom.Controllers.ControllerManager"/>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.NumEffects">
            <summary>
               Gets the number of effects currently tied to this texture stage.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureType">
            <summary>
               Gets the type of texture this unit has.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.DesiredFormat">
            <summary>
            The desired pixel format when load the texture.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.MipmapCount">
            <summary>
            How many mipmaps have been requested for the texture.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsAlpha">
            <summary>
            Whether this texture is requested to be loaded as alpha if single channel.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsHardwareGammaEnabled">
            <summary>
            Whether this texture will be set up so that on sampling it, 
            hardware gamma correction is applied.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureAnisotropy">
            <summary>
               Gets/Sets the anisotropy level to be used for this texture stage.
            </summary>
            <remarks>
               This option applies in both the fixed function and the programmable pipeline.
            </remarks>
            <value>
               The maximal anisotropy level, should be between 2 and the maximum supported by hardware (1 is the default, ie. no anisotropy)
            </value>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.HasViewRelativeTexCoordGen">
            <summary>
               Returns true if this texture unit requires an updated view matrix
               to allow for proper texture matrix generation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.Is3D">
            <summary>
            Returns true if this texture layer uses a composit 3D cubic texture.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.BindingType">
            <summary>
            The type of unit these texture settings should be bound to
            </summary>
            <remarks>
            Some render systems, when implementing vertex texture fetch, separate
            the binding of textures for use in the vertex program versus those
            used in fragment programs. This setting allows you to target the
            vertex processing unit with a texture binding, in those cases. For
            rendersystems which have a unified binding for the vertex and fragment
            units, this setting makes no difference.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendModeEx">
            <summary>
            	Utility class for handling texture layer blending parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.op_Equality(Axiom.Graphics.LayerBlendModeEx,Axiom.Graphics.LayerBlendModeEx)">
            <summary>
            	Compares to blending modes for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.op_Inequality(Axiom.Graphics.LayerBlendModeEx,Axiom.Graphics.LayerBlendModeEx)">
            <summary>
            	Compares to blending modes for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.Clone">
            <summary>
            	Creates and returns a clone of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.Equals(System.Object)">
            <summary>
               Overide to use custom equality check.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.GetHashCode">
            <summary>
               Override.
            </summary>
            <remarks>
               Overriden to quash warnings, not necessarily needed right now.
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.TextureEffect">
            <summary>
            	Class used to define parameters for a texture effect.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureEffect.Clone">
            <summary>
            	Returns a clone of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetEventHandler">
            <summary>
               Delegate for RenderTarget update events.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetViewportEventHandler">
            <summary>
               Delegate for Viewport update events.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetEventArgs">
            <summary>
               Event arguments for render target updates.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetViewportEventArgs">
            <summary>
               Event arguments for viewport updates while processing a RenderTarget.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTarget">
            <summary>
            	A 'canvas' which can receive the results of a rendering operation.
            </summary>
            <remarks>
            	This abstract class defines a common root to all targets of rendering operations. A
            	render target could be a window on a screen, or another
            	offscreen surface like a render texture.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.height">
            <summary>
            Height of this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.width">
            <summary>
            Width of this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.colorDepth">
            <summary>
            Color depth of this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.priority">
            <summary>
            Indicates the priority of this render target.  Higher priority targets will get processed first.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.name">
            <summary>
            Unique name assigned to this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.active">
            <summary>
               Flag that states whether this target is active or not.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.autoUpdate">
            <summary>
                Is this render target updated automatically each frame?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.fsaa">
            <summary>
               Flag that states whether this target is FSAA.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetViewport(System.Int32)">
            <summary>
            Retrieves a pointer to the viewport with the given index.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetViewportByZOrder(System.Int32)">
            <summary>
             Retrieves a pointer to the viewport with the given zorder. 
            </summary>
            <remarks>
            throws if not found.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.HasViewportWithZOrder(System.Int32)">
            <summary>
            Checks if a viewport exists at the given ZOrder.
            </summary>
            <param name="zOrder"></param>
            <returns>true if and only if a viewport exists at the given ZOrder.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.AddViewport(Axiom.Core.Camera)">
            <summary>
                Adds a viewport to the rendering target.
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.AddViewport(Axiom.Core.Camera,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            	Adds a viewport to the rendering target.
            </summary>
            <remarks>
            	A viewport is the rectangle into which rendering output is sent. This method adds
            	a viewport to the render target, rendering from the supplied camera. The
            	rest of the parameters are only required if you wish to add more than one viewport
            	to a single rendering target. Note that size information passed to this method is
            	passed as a parametric, i.e. it is relative rather than absolute. This is to allow
            	viewports to automatically resize along with the target.
            </remarks>
            <param name="camera">The camera from which the viewport contents will be rendered (mandatory)</param>
            <param name="left">The relative position of the left of the viewport on the target, as a value between 0 and 1.</param>
            <param name="top">The relative position of the top of the viewport on the target, as a value between 0 and 1.</param>
            <param name="nwidth">The relative width of the viewport on the target, as a value between 0 and 1.</param>
            <param name="nheight">The relative height of the viewport on the target, as a value between 0 and 1.</param>
            <param name="zOrder">The relative order of the viewport with others on the target (allows overlapping
            	viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number
            	is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.RemoveViewport(System.Int32)">
            <summary>
            Removes a viewport at a given ZOrder.
            </summary>
            <param name="zOrder">
            The <see cref="P:Axiom.Core.Viewport.ZOrder"/> of the viewport to be removed.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.RemoveAllViewports">
            <summary>
            Removes all viewports on this target.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetStatistics(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Retieves details of current rendering performance.
            </summary>
            <param name="lastFPS">The number of frames per second (FPS) based on the last frame rendered.</param>
            <param name="avgFPS">
            The FPS rating based on an average of all the frames rendered 
            since rendering began (the call to Root.StartRendering).
            </param>
            <param name="bestFPS">The best FPS rating that has been achieved since rendering began.</param>
            <param name="worstFPS">The worst FPS rating seen so far</param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.ResetStatistics">
            <summary>
            Resets saved frame-rate statistices.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetCustomAttribute(System.String)">
            <summary>
            Gets a custom (maybe platform-specific) attribute.
            </summary>
            <remarks>
            This is a nasty way of satisfying any API's need to see platform-specific details.
            Its horrid, but D3D needs this kind of info. At least it's abstracted.
            </remarks>
            <param name="attribute">The name of the attribute.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.AttachDepthBuffer(Axiom.Graphics.DepthBuffer)">
            <summary>
            Attaches a depth buffer to this target
            </summary>
            <param name="ndepthBuffer">The buffer to attach</param>
            <returns>false if couldn't attach</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget._DetachDepthBuffer">
            <summary>
            Detaches DepthBuffer without notifying it from the detach.
            Useful when called from the DepthBuffer while it iterates through attached
            RenderTargets <see cref="P:Axiom.Graphics.DepthBuffer.PoolId"/>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.Update">
            <summary>
            	Updates the window contents.
            </summary>
            <remarks>
            	The window is updated by telling each camera which is supposed
            	to render into this window to render it's view, and then
            	the window buffers are swapped via SwapBuffers()
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.Update(System.Boolean)">
            <summary>
            	Updates the window contents.
            </summary>
            <remarks>
            	The window is updated by telling each camera which is supposed
            	to render into this window to render it's view, and then
            	the window buffers are swapped via SwapBuffers() if requested.
            </remarks>
            <param name="swapBuffers">
            If set to true, the window will immediately
            swap it's buffers after update. Otherwise, the buffers are
            not swapped, and you have to call swapBuffers yourself sometime
            later. You might want to do this on some rendersystems which 
            pause for queued rendering commands to complete before accepting
            swap buffers calls - so you could do other CPU tasks whilst the 
            queued commands complete. Or, you might do this if you want custom
            control over your windows, such as for externally created windows.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.BeginUpdate">
            <summary>
            Method for manual management of rendering : fires 'preRenderTargetUpdate'
            and initializes statistics etc.
            </summary>
            <remarks>
            <ul>
            <li>BeginUpdate resets statistics and fires 'preRenderTargetUpdate'.</li>
            <li>UpdateViewport renders the given viewport (even if it is not autoupdated),
            fires preViewportUpdate and postViewportUpdate and manages statistics.</li>
            <li>UpdateAutoUpdatedViewports renders only viewports that are auto updated,
            fires preViewportUpdate and postViewportUpdate and manages statistics.</li>
            <li>EndUpdate() ends statistics calculation and fires postRenderTargetUpdate.</li>
            </ul>
            you can use it like this for example :
            <pre>
            renderTarget.BeginUpdate();
            renderTarget.UpdateViewport(1); // which is not auto updated
            renderTarget.UpdateViewport(2); // which is not auto updated
            renderTarget.UpdateAutoUpdatedViewports();
            renderTarget.EndUpdate();
            renderTarget.SwapBuffers(true);
            </pre>
            Please note that in that case, the zorder may not work as you expect,
            since you are responsible for calling UpdateViewport in the correct order.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.UpdateViewport(Axiom.Core.Viewport,System.Boolean)">
            <summary>
            Method for manual management of rendering - renders the given 
            viewport (even if it is not autoupdated)
            </summary>
            <remarks>
            This also fires preViewportUpdate and postViewportUpdate, and manages statistics.
            You should call it between <see cref="M:Axiom.Graphics.RenderTarget.BeginUpdate"/> and <see cref="M:Axiom.Graphics.RenderTarget.EndUpdate"/>.
            </remarks>
            <param name="viewport">The viewport you want to update, it must be bound to the rendertarget.</param>
            <param name="updateStatistics">Whether you want to update statistics or not.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.UpdateViewport(System.Int32,System.Boolean)">
            <summary>
            Method for manual management of rendering - renders the given 
            viewport (even if it is not autoupdated)
            </summary>
            <remarks>
            This also fires preViewportUpdate and postViewportUpdate, and manages statistics.
            You should call it between <see cref="M:Axiom.Graphics.RenderTarget.BeginUpdate"/> and <see cref="M:Axiom.Graphics.RenderTarget.EndUpdate"/>.
            </remarks>
            <param name="zorder">The zorder of the viewport to update.</param>
            <param name="updateStatistics">Whether you want to update statistics or not.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.UpdateAutoUpdatedViewports(System.Boolean)">
            <summary>
            Method for manual management of rendering - renders only viewports that are auto updated
            </summary>
            <remarks>
            This also fires preViewportUpdate and postViewportUpdate, and manages statistics.
            You should call it between <see cref="M:Axiom.Graphics.RenderTarget.BeginUpdate"/> and 
            <see cref="M:Axiom.Graphics.RenderTarget.EndUpdate"/>.
            </remarks>
            <param name="updateStatistics"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.EndUpdate">
            <summary>
            Method for manual management of rendering - finishes statistics calculation
            and fires 'postRenderTargetUpdate'.
            </summary>
            <remarks>
            You should call it after a <see cref="M:Axiom.Graphics.RenderTarget.BeginUpdate"/>
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.NotifyCameraRemoved(Axiom.Core.Camera)">
            <summary>
            Utility method to notify a render target that a camera has been removed, 
            incase it was referring to it as a viewer.
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetMetrics(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieve information about the render target.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.WriteContentsToFile(System.String)">
            <summary>
            Saves window contents to file (i.e. screenshot);
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.WriteContentsToTimestampedFile(System.String,System.String)">
            <summary>
            Writes the current contents of the render target to the (PREFIX)(time-stamp)(SUFFIX) file.
            </summary>
            <returns>the name of the file used.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.CopyContentsToMemory(Axiom.Media.PixelBox,Axiom.Graphics.RenderTarget.FrameBuffer)">
            <summary>
            Copies the current contents of the render target to a pixelbox. 
            </summary>
            <remarks>
            See <see cref="M:Axiom.Graphics.RenderTarget.SuggestPixelFormat"/> for a tip as to the best pixel format to
            extract into, although you can use whatever format you like and the 
            results will be converted.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.SuggestPixelFormat">
            <summary>
            Suggests a pixel format to use for extracting the data in this target, when calling 
            <see cref="M:Axiom.Graphics.RenderTarget.CopyContentsToMemory(Axiom.Media.PixelBox,Axiom.Graphics.RenderTarget.FrameBuffer)"/>.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.SwapBuffers(System.Boolean)">
             <summary>
            		Swaps the frame buffers to display the next frame.
             </summary>
             <remarks>
            		For targets that are double-buffered so that no
                 'in-progress' versions of the scene are displayed
                 during rendering. Once rendering has completed (to
            		an off-screen version of the window) the buffers
            		are swapped to display the new frame.
            	</remarks>
             <param name="waitForVSync">
            		If true, the system waits for the
            		next vertical blank period (when the CRT beam turns off
            		as it travels from bottom-right to top-left at the
            		end of the pass) before flipping. If false, flipping
            		occurs no matter what the beam position. Waiting for
            		a vertical blank can be slower (and limits the
            		framerate to the monitor refresh rate) but results
            		in a steadier image with no 'tearing' (a flicker
            		resulting from flipping buffers when the beam is
            		in the progress of drawing the last frame). 
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.dispose(System.Boolean)">
            <summary>
            Class level dispose method
            </summary>
            <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Height">
            <summary>
            Gets the height of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Width">
            <summary>
            Gets the width of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.ColorDepth">
            <summary>
            Gets the color depth of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.DepthBuffer">
            <summary>
            Gets the depthbuffer attached to this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Priority">
            <summary>
            Gets/Sets the priority of this render target.  Higher priority targets will get processed first.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Name">
            <summary>
            Gets the name of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.RequiresTextureFlipping">
            <summary>
                Signals whether textures should be flipping before this target
                is updated.  Required for render textures in some API's.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.IsActive">
            <summary>
               Gets/Sets whether this RenderTarget is active or not.  When inactive, it will be skipped
               during processing each frame.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.IsPrimary">
            <summary>
            Indicates whether this target is the primary window. The
            primary window is special in that it is destroyed when
            ogre is shut down, and cannot be destroyed directly.
            This is the case because it holds the context for vertex,
            index buffers and textures..
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.IsAutoUpdated">
            <summary>
               Gets/Sets whether this target should be automatically updated if Axiom's rendering
               loop or Root.UpdateAllRenderTargets is being used.
            </summary>
            <remarks>
            	By default, if you use Axiom's own rendering loop (Root.StartRendering)
            	or call Root.UpdateAllRenderTargets, all render targets are updated
            	automatically. This method allows you to control that behaviour, if 
            	for example you have a render target which you only want to update periodically.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.IsHardwareGammaEnabled">
            <summary>
            Indicates whether on rendering, linear color space is converted to 
            sRGB gamma colour space. This is the exact opposite conversion of
            what is indicated by <see cref="P:Axiom.Core.Texture.HardwareGammaEnabled"/>, and can only
            be enabled on creation of the render target. For render windows, it's
            enabled through the 'gamma' creation misc parameter. For textures, 
            it is enabled through the hwGamma parameter to the create call.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FSAA">
            <summary>
               Gets/Sets whether this RenderTarget is FSAA or not.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FSAAHint">
            <summary>
            Gets the FSAA hint 
            <see cref="M:Axiom.Core.Root.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)"/>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.NumViewports">
            <summary>
            Returns the number of viewports attached to this target.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.BeforeUpdate">
            <summary>
               Gets fired before this RenderTarget is going to update.  Handling this event is ideal
               in situation, such as RenderTextures, where before rendering the scene to the texture,
               you would like to show/hide certain entities to avoid rendering more than was necessary
               to reduce processing time.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.AfterUpdate">
            <summary>
               Gets fired right after this RenderTarget has been updated each frame.  If the scene has been modified
               in the BeforeUpdate event (such as showing/hiding objects), this event can be handled to set everything 
               back to normal.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.BeforeViewportUpdate">
            <summary>
               Gets fired before rendering the contents of each viewport attached to this RenderTarget.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.AfterViewportUpdate">
            <summary>
               Gets fired after rendering the contents of each viewport attached to this RenderTarget.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.ViewportAdded">
            <summary>
            Gets fired when a Viewport has been added to this RenderTarget.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.ViewportRemoved">
            <summary>
            Gets fired when a Viewport has been removed from this RenderTarget.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Statistics">
            <summary>
            Retieves details of current rendering performance.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.LastFPS">
            <summary>
            The number of frames per second (FPS) based on the last frame rendered.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.AverageFPS">
            <summary>
            The average frames per second (FPS) since call to Root.StartRendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.BestFPS">
            <summary>
            The best frames per second (FPS) since call to Root.StartRendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.WorstFPS">
            <summary>
            The worst frames per second (FPS) since call to Root.StartRendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.BestFrameTime">
            <summary>
            The best frame time
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.WorstFrameTime">
            <summary>
            The worst frame time
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.LastTriangleCount">
            <summary>
            The number of triangles rendered in the last Update() call. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.LastBatchCount">
            <summary>
            The number of triangles rendered in the last Update() call. 
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTarget.FrameStatistics">
            <summary>
            Holds all the current statistics for a RenderTarget
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.LastFPS">
            <summary>
            The number of Frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.AverageFPS">
            <summary>
            The average number of Frames per second since Root.StartRendering was called.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.BestFPS">
            <summary>
            The highest number of Frames per second since Root.StartRendering was called.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.WorstFPS">
            <summary>
            The lowest number of Frames per second since Root.StartRendering was called.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.BestFrameTime">
            <summary>
            The best frame time recorded since Root.StartRendering was called.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.WorstFrameTime">
            <summary>
            The worst frame time recorded since Root.StartRendering was called.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.TriangleCount">
            <summary>
            The number of triangles processed in the last call to Update()
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.FrameStatistics.BatchCount">
            <summary>
            The number of batches procecssed in the last call to Update()
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IDerivedPlaneProvider.DerivedPlane">
            <summary>
            	Get the derived plane as transformed by its parent node.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.MovablePlane">
            <summary>
            	Definition of a Plane that may be attached to a node, and the derived
            	details of it retrieved simply.
            </summary>
            <remarks>
            	This plane is not here for rendering purposes, it's to allow you to attach
            	planes to the scene in order to have them move and follow nodes on their
            	own, which is useful if you're using the plane for some kind of calculation,
            	e.g. reflection.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.derivedPlane">
            <summary>
            	Plane as transformed by it's parent node.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.lastTranslate">
            <summary>
            	Cached translation vector.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.lastRotate">
            <summary>
            	Cached rotation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.nullBB">
            <summary>
            	Bounding box.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.isDirty">
            <summary>
            	Flag for whether changes have been made to this planes position/rotation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.containedPlane">
            <summary>
            	Underlying plane representation.
            </summary>
            <remarks>
            	Ogre uses multiple inheritance for this purpose - bah! ;)
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.MovablePlane.#ctor(System.String)">
            <summary>
            	Constructor.
            </summary>
            <param name="name">Name of this plane.</param>
        </member>
        <member name="P:Axiom.Graphics.MovablePlane.D">
            <summary>
            	The plane's distance from the origin.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MovablePlane.Normal">
            <summary>
            	The direction the plane is facing.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MovablePlane.DerivedPlane">
            <summary>
            	Get the derived plane as transformed by its parent node.
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FontManager">
            <summary>
               Manages Font resources, parsing .fontdef files and generally organizing them.
            </summary>
            
            <ogre name="FontManager">
                <file name="OgreFontManager.h"   revision="1.10" lastUpdated="6/19/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreFontManager.cpp" revision="1.14" lastUpdated="6/19/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
            
        </member>
        <member name="T:Axiom.Core.ResourceManager">
             <summary>
            		Defines a generic resource handler.
             </summary>
             <remarks>
            		A resource manager is responsible for managing a pool of
            		resources of a particular type. It must index them, look
            		them up, load and destroy them. It may also need to stay within
            		a defined memory budget, and temporarily unload some resources
            		if it needs to stay within this budget.
            		<para/>
            		Resource managers use a priority system to determine what can
            		be unloaded, and a Least Recently Used (LRU) policy within
            		resources of the same priority.
                 Resources can be loaded using the generalized load interface,
                 and they can be unloaded and removed. In addition, each
                 subclass of ResourceManager will likely define custom 'load' methods
                 which take explicit parameters depending on the kind of resource
                 being created.
                 <para/>
                 Resources can be loaded and unloaded through the Resource class,
                 but they can only be removed (and thus eventually destroyed) using
                 their parent ResourceManager.
             </remarks>
            
             <ogre name="ResourceManager">
                 <file name="OgreResourceManager.h"   revision="1.17.2.1" lastUpdated="6/19/2006" lastUpdatedBy="Borrillis" />
                 <file name="OgreResourceManager.cpp" revision="1.17.2.2" lastUpdated="6/19/2006" lastUpdatedBy="Borrillis" />
             </ogre>
            
        </member>
        <member name="M:Axiom.Core.ResourceManager.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Create(System.String,System.String)">
            <overloads>
            <summary>
            	Creates a new blank resource, but does not immediately load it.
            </summary>
            <remarks>
            	Resource managers handle disparate types of resources. This method returns a pointer to a
            	valid new instance of the kind of resource managed here. The caller should  complete the
            	details of the returned resource and call ResourceManager.Load to load the resource. Note
            	that it is the CALLERS responsibility to destroy this object when it is no longer required
            	(after calling ResourceManager.Unload if it had been loaded).
                If you want to get at the detailed interface of this resource, you'll have to
                cast the result to the subclass you know you're creating.
            </remarks>
            <param name="name">The unique name of the resource</param>
            <param name="group"></param>
            <returns></returns>
            </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Create(System.String,System.String,Axiom.Collections.NameValuePairList)">
            <param name="group"></param>
            <param name="createParams">If any parameters are required to create an instance, they should be supplied here as name / value pairs</param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Create(System.String,System.String,System.Boolean,Axiom.Core.IManualResourceLoader,Axiom.Collections.NameValuePairList)">
            <param name="group"></param>
            <param name="isManual">
            Is this resource manually loaded? If so, you should really
            populate the loader parameter in order that the load process
            can call the loader back when loading is required.
            </param>
            <param name="loader">
            Pointer to a ManualLoader implementation which will be called
            when the Resource wishes to load (should be supplied if you set
            isManual to true). You can in fact leave this parameter null
            if you wish, but the Resource will never be able to reload if
            anything ever causes it to unload. Therefore provision of a proper
            ManualLoader instance is strongly recommended.
            </param>
            <param name="createParams">If any parameters are required to create an instance, they should be supplied here as name / value pairs</param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Load(System.String,System.String)">
            <overloads>
            <summary>
            Generic load method, used to create a Resource specific to this
            ResourceManager without using one of the specialised 'load' methods
            (containing per-Resource-type parameters).
            </summary>
            <param name="name">The name of the Resource</param>
            <param name="group">The resource group to which this resource will belong</param>
            <returns></returns>
            </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Load(System.String,System.String,Axiom.Collections.NameValuePairList)">
            <param name="name">The name of the Resource</param>
            <param name="group">The resource group to which this resource will belong</param>
            <param name="loadParams">
                Optional pointer to a list of name/value pairs
                containing loading parameters for this type of resource.
            </param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Load(System.String,System.String,System.Boolean,Axiom.Core.IManualResourceLoader,Axiom.Collections.NameValuePairList)">
            <param name="name">The name of the Resource</param>
            <param name="group">The resource group to which this resource will belong</param>
            <param name="isManual">
                Is the resource to be manually loaded? If so, you should
                provide a value for the loader parameter
            </param>
            <param name="loader">
                The manual loader which is to perform the required actions
                when this resource is loaded; only applicable when you specify true
                for the previous parameter
            </param>
            <param name="loadParams">
                Optional pointer to a list of name/value pairs
                containing loading parameters for this type of resource.
            </param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Unload(System.String)">
            <overloads>
            <summary>
            Unloads a single resource by name.
            </summary>
            <remarks>
            Unloaded resources are not removed, they simply free up their memory
            as much as they can and wait to be reloaded.
            <see>ResourceGroupManager</see> for unloading of resource groups.
            </remarks>
            </overloads>
            <param name="name">Name of the resource.</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Unload(System.UInt64)">
            <param name="handle">Handle of the resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Unload(Axiom.Core.Resource)">
            <summary>
            	Unloads a Resource from the managed resources list, calling it's Unload() method.
            </summary>
            <remarks>
            	This method removes a resource from the list maintained by this manager, and unloads it from
            	memory. It does NOT destroy the resource itself, although the memory used by it will be largely
            	freed up. This would allow you to reload the resource again if you wished.
            </remarks>
            <param name="resource"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.UnloadAll">
            <summary>
            Unloads all resources.
            </summary>
            <remarks>
            Unloaded resources are not removed, they simply free up their memory
            as much as they can and wait to be reloaded.
            <see>ResourceGroupManager</see> for unloading of resource groups.
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceManager.ReloadAll">
            <summary>Causes all currently loaded resources to be reloaded.</summary>
            <remarks>
            Unloaded resources are not removed, they simply free up their memory
            as much as they can and wait to be reloaded.
            <see>ResourceGroupManager</see> for unloading of resource groups.
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Remove(Axiom.Core.Resource)">
            <overloads>
            <summary>
            Remove a single resource.
            </summary>
            <remarks>
            Removes a single resource, meaning it will be removed from the list
            of valid resources in this manager, also causing it to be unloaded.
            <para/>
            The word 'Destroy' is not used here, since
            if any other pointers are referring to this resource, it will persist
            until they have finished with it; however to all intents and purposes
            it no longer exists and will likely get destroyed imminently.
            <para/>
            If you do have references to resources hanging around after the
            ResourceManager is destroyed, you may get problems on destruction of
            these resources if they were relying on the manager (especially if
            it is a plugin). If you find you get problems on shutdown in the
            destruction of resources, try making sure you release all your
            references before you shutdown OGRE.
            </remarks>
            </overloads>
            <param name="resource">The resource to remove</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Remove(System.String)">
            <param name="name">The name of the resource to remove</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Remove(System.UInt64)">
            <param name="handle">The Handle of the resource to remove</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.RemoveAll">
            <summary>
            Removes all resources.
            </summary>
            <remarks>
            Removes all resources, meaning they will be removed from the list
            of valid resources in this manager, also causing them to be unloaded.
            <para/>
            The word 'Destroy' is not used here, since
            if any other pointers are referring to this resource, it will persist
            until they have finished with it; however to all intents and purposes
            it no longer exists and will likely get destroyed imminently.
            <para/>
            If you do have references to resources hanging around after the
            ResourceManager is destroyed, you may get problems on destruction of
            these resources if they were relying on the manager (especially if
            it is a plugin). If you find you get problems on shutdown in the
            destruction of resources, try making sure you release all your
            references before you shutdown Axiom.
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceManager.ResourceExists(System.String)">
            <summary>Returns whether the named resource exists in this manager</summary>
            <param name="name">name of the resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.ResourceExists(System.UInt64)">
            <summary>Returns whether a resource with the given handle exists in this manager</summary>
            <param name="handle">handle of the resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.NotifyResourceTouched(Axiom.Core.Resource)">
            <summary>Notify this manager that a resource which it manages has been 'touched', ie used. </summary>
            <param name="res">the resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.NotifyResourceLoaded(Axiom.Core.Resource)">
            <summary> Notify this manager that a resource which it manages has been loaded. </summary>
            <param name="res">the resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.NotifyResourceUnloaded(Axiom.Core.Resource)">
            <summary>Notify this manager that a resource which it manages has been unloaded.</summary>
            <param name="res">the resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager._create(System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader,Axiom.Collections.NameValuePairList)">
            <summary>
            Create a new resource instance compatible with this manager (no custom
            parameters are populated at this point).
            </summary>
            <param name="name">The unique name of the resource</param>
            <param name="handle"></param>
            <param name="group">The name of the resource group to attach this new resource to</param>
            <param name="isManual">
                Is this resource manually loaded? If so, you should really
                populate the loader parameter in order that the load process
                can call the loader back when loading is required.
            </param>
            <param name="loader">
                A ManualLoader implementation which will be called
                when the Resource wishes to load (should be supplied if you set
                isManual to true). You can in fact leave this parameter null
                if you wish, but the Resource will never be able to reload if
                anything ever causes it to unload. Therefore provision of a proper
                ManualLoader instance is strongly recommended.
            </param>
            <param name="createParams">
                If any parameters are required to create an instance,
                they should be supplied here as name / value pairs. These do not need
                to be set on the instance (handled elsewhere), just used if required
                to differentiate which concrete class is created.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager._add(Axiom.Core.Resource)">
            <summary>
            Add a newly created resource to the manager
            </summary>
            <param name="res"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager._remove(Axiom.Core.Resource)">
            <summary>
            Remove a resource from this manager; remove it from the lists.
            </summary>
            <param name="res"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.checkUsage">
            <summary>
            	Makes sure we are still within budget.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.ParseScript(System.IO.Stream,System.String,System.String)">
            <summary>
            Parse a script file.
            </summary>
            <param name="stream">reference to a data stream which is the source of the script</param>
            <param name="groupName">
            The name of a resource group which should be used if any resources
            are created during the parse of this script.
            </param>
            <param name="fileName"></param>
        </member>
        <member name="P:Axiom.Core.ResourceManager.Resources">
            <summary>
            	A cached list of all resources in memory.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.resources">
            <summary>
            	A cached list of all resources and keys in memory.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.resourceHandleMap">
            <summary>
            	A cached list of all resources handles in memory.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.MemoryBudget">
            <summary>
            Get/Set a limit on the amount of memory all resource handlers may use.
            </summary>
            <remarks>
            If, when asked to load a new resource, the manager believes it will exceed this memory
            budget, it will temporarily unload a resource to make room for the new one. This unloading
            is not permanent and the Resource is not destroyed; it simply needs to be reloaded when
            next used.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ResourceManager.memoryUsage">
            <summary>
            	Gets/Sets the current memory usages by all resource managers.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.nextHandle">
            <summary>
                Gets the next available unique resource handle.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.ResourceType">
            <summary>
            Gets/Sets a string identifying the type of resource this manager handles.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.Item(System.String)">
            <summary>
               Gets a reference to the specified named resource.
            </summary>
            <param name="name">Name of the resource to retrieve.</param>
            <returns>A reference to a Resource with the given name or null.</returns>
            <ogre name="getByName" />
        </member>
        <member name="P:Axiom.Core.ResourceManager.Item(System.UInt64)">
            <summary>
            	Gets a resource with the given handle.
            </summary>
            <param name="handle">Handle of the resource to retrieve.</param>
            <returns>A reference to a Resource with the given handle or null.</returns>
            <ogre name="getByHandle" />
        </member>
        <member name="P:Axiom.Core.ResourceManager.ScriptPatterns">
            <summary>
            Gets the file patterns which should be used to find scripts for this class.
            </summary>
            <remarks>
            This method is called when a resource group is loaded if you use
            ResourceGroupManager::registerScriptLoader. Returns a list of file
            patterns, in the order they should be searched in.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ResourceManager.LoadingOrder">
            <summary>
            Gets the relative loading order of scripts of this type.
            </summary>
            <remarks>
            There are dependencies between some kinds of scripts, and to enforce
            this all implementors of this interface must define a loading order.
            Returns a value representing the relative loading order of these scripts
            compared to other script users, where higher values load later.
            </remarks>
        </member>
        <member name="M:Axiom.Fonts.FontManager.Initialize(System.Object[])">
            <summary>
            
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Fonts.FontManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.FontManager.parseAttribute(System.String,Axiom.Fonts.Font)">
            <summary>
               Parses an attribute of the font definitions.
            </summary>
            <param name="line"></param>
            <param name="font"></param>
        </member>
        <member name="M:Axiom.Fonts.FontManager.ParseScript(System.IO.Stream,System.String,System.String)">
            <summary>
               Parse a .fontdef script passed in as a chunk.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.FontManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.WireBoundingBox">
            <summary>
            Summary description for WireBoundingBox.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SimpleRenderable">
            <summary>
            Summary description for SimpleRenderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SimpleRenderable.dummyLightList">
            <summary>
               Empty light list to use when there is no parent for this renderable.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.#ctor(System.String)">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.NotifyCurrentCamera(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
             <summary>
            
             </summary>
             <param name="queue"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.GetSquaredViewDepth(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.BoundingBox">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.Material">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.NumWorldTransforms">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.UseIdentityProjection">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.UseIdentityView">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.WorldOrientation">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.WorldPosition">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.GetSquaredViewDepth(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
             <returns></returns>
        </member>
        <member name="P:Axiom.Core.WireBoundingBox.BoundingRadius">
            <summary>
               Get the local bounding radius of the wire bounding box.
            </summary>
        </member>
        <member name="T:Axiom.Core.Light">
            <summary>
               Representation of a dynamic light source in the scene.
            </summary>
            <remarks>
               Lights are added to the scene like any other object. They contain various
               parameters like type, position, attenuation (how light intensity fades with
               distance), color etc.
               <p/>
               The defaults when a light is created is pure white diffuse light, with no
               attenuation (does not decrease with distance) and a range of 1000 world units.
               <p/>
               Lights are created by using the SceneManager.CreateLight method. They can subsequently be
               added to a SceneNode if required to allow them to move relative to a node in the scene. A light attached
               to a SceneNode is assumed to have a base position of (0,0,0) and a direction of (0,0,1) before modification
               by the SceneNode's own orientation. If note attached to a SceneNode,
               the light's position and direction is as set using Position and Direction.
               <p/>
               Remember also that dynamic lights rely on modifying the color of vertices based on the position of
               the light compared to an object's vertex normals. Dynamic lighting will only look good if the
               object being lit has a fair level of tesselation and the normals are properly set. This is particularly
               true for the spotlight which will only look right on highly tessellated models.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Light.attenuationConst">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationLinear">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationQuad">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.derivedDirection">
            <summary>
            	Derived direction of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.derivedPosition">
            <summary>
            	Derived position of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.diffuse">
            <summary>
            	Diffuse color.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.direction">
            <summary>
               Direction of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.frustumClipVolumes">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.Light.lastParentOrientation">
            <summary>
            	Stored version of parent orientation.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.lastParentPosition">
            <summary>
            	Stored version of parent position.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.localTransformDirty">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.nearClipVolume">
            <summary>
            	Stored version of the last near clip volume tested.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.position">
            <summary>
               Position of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.range">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.specular">
            <summary>
            	Specular color.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.spotFalloff">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.spotInner">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.spotOuter">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.tempSquaredDist">
            <summary>
               Used for sorting.  Internal for "friend" access to SceneManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.type">
            <summary>
               Type of light.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.#ctor(System.String)">
            <summary>
            	Normal constructor. Should not be called directly, but rather the SceneManager.CreateLight method should be used.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Light.GetDerivedPosition(System.Boolean)">
            <summary>
            	Gets the derived position of this light.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.Update">
            <summary>
            	Updates this lights position.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.GetAs4DVector(System.Boolean)">
            <summary>
            	Gets the details of this light as a 4D vector.
            </summary>
            <remarks>
            	Getting details of a light as a 4D vector can be useful for
            	doing general calculations between different light types; for
            	example the vector can represent both position lights (w=1.0f)
            	and directional lights (w=0.0f) and be used in the same
            	calculations.
            </remarks>
            <returns>A 4D vector representation of the light.</returns>
        </member>
        <member name="M:Axiom.Core.Light.SetSpotlightRange(System.Single,System.Single)">
             <summary>
            
             </summary>
             <param name="innerAngle"></param>
             <param name="outerAngle"></param>
        </member>
        <member name="M:Axiom.Core.Light.SetSpotlightRange(System.Single,System.Single,System.Single)">
            <summary>
            	Sets the spotlight parameters in a single call.
            </summary>
            <param name="innerAngle"></param>
            <param name="outerAngle"></param>
            <param name="falloff"></param>
        </member>
        <member name="M:Axiom.Core.Light.SetAttenuation(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the attenuation parameters of the light in a single call.
            </summary>
            <param name="range"></param>
            <param name="constant"></param>
            <param name="linear"></param>
            <param name="quadratic"></param>
        </member>
        <member name="M:Axiom.Core.Light.GetNearClipVolume(Axiom.Core.Camera)">
            <summary>
            	Internal method for calculating the 'near clip volume', which is
            	the volume formed between the near clip rectangle of the
            	camera and the light.
            </summary>
            <remarks>
            	This volume is a pyramid for a point/spot light and
            	a cuboid for a directional light. It can used to detect whether
            	an object could be casting a shadow on the viewport. Note that
            	the reference returned is to a shared volume which will be
            	reused across calls to this method.
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Light.GetFrustumClipVolumes(Axiom.Core.Camera)">
            <summary>
            	Internal method for calculating the clip volumes outside of the
            	frustum which can be used to determine which objects are casting
            	shadow on the frustum as a whole.
            </summary>
            <remarks>
            	Each of the volumes is a pyramid for a point/spot light and
            	a cuboid for a directional light.
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Core.Light._customShadowCameraSetup">
            <summary>
            the custom shadow camera setup (null means use <see cref="T:Axiom.Core.SceneManager"/> global version).
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.ResetCustomShadowCameraSetup">
            <summary>
            Reset the shadow camera setup to the default.
            </summary>
            <seealso cref="T:Axiom.Core.IShadowCameraSetup"/>
        </member>
        <member name="M:Axiom.Core.Light.CompareTo(System.Object)">
            <summary>
               Used to compare this light to another light for sorting.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Light.Type">
            <summary>
            	Gets/Sets the type of light this is.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Position">
            <summary>
            	Gets/Sets the position of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Direction">
            <summary>
            	Gets/Sets the direction of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightInnerAngle">
            <summary>
            	Gets the inner angle of the spotlight.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightOuterAngle">
            <summary>
            	Gets the outer angle of the spotlight.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightFalloff">
            <summary>
            	Gets the spotlight falloff.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Diffuse">
            <summary>
            	Gets/Sets the diffuse color of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Specular">
            <summary>
            	Gets/Sets the specular color of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationRange">
            <summary>
            	Gets the attenuation range value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationConstant">
            <summary>
            	Gets the constant attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationLinear">
            <summary>
            	Gets the linear attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationQuadratic">
            <summary>
            	Gets the quadratic attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.DerivedDirection">
            <summary>
            	Gets the derived position of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.BoundingRadius">
            <summary>
               Local bounding radius of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.TempSquaredDist">
            <summary>
               Used for sorting.   *** Internal for "friend" access to SceneManager. ***
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.CustomShadowCameraSetup">
            <summary>
            this light's reference to the custom shadow camera to use when rendering texture shadows.
            (null means use <see cref="T:Axiom.Core.SceneManager"/> global version).
            </summary>
            <remarks>
            This changes the shadow camera setup for just this light, you can set
            the shadow camera setup globally using <see cref="P:Axiom.Core.SceneManager.ShadowCameraSetup"/>
            </remarks>
        </member>
        <member name="P:Axiom.Core.Light.AnimableValueNames">
            <summary>
                Part of the IAnimableObject interface.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.BoundingBox">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Light.TypeFlags">
            <summary>
            Get the 'type flags' for this <see cref="T:Axiom.Core.Light"/>.
            </summary>
            <seealso cref="P:Axiom.Core.MovableObject.TypeFlags"/>
        </member>
        <member name="T:Axiom.Core.BillboardSet">
            <summary>
            	A collection of billboards (faces which are always facing the camera) with the same (default) dimensions, material
            	and which are fairly close proximity to each other.
             </summary>
             <remarks>
            	Billboards are rectangles made up of 2 tris which are always facing the camera. They are typically used
            	for special effects like particles. This class collects together a set of billboards with the same (default) dimensions,
            	material and relative locality in order to process them more efficiently. The entire set of billboards will be
            	culled as a whole (by default, although this can be changed if you want a large set of billboards
            	which are spread out and you want them culled individually), individual Billboards have locations which are relative to the set (which itself derives it's
            	position from the SceneNode it is attached to since it is a SceneObject), they will be rendered as a single rendering operation,
            	and some calculations will be sped up by the fact that they use the same dimensions so some workings can be reused.
            	<p/>
            	A BillboardSet can be created using the SceneManager.CreateBillboardSet method. They can also be used internally
            	by other classes to create effects.
            </remarks>
        </member>
        <member name="F:Axiom.Core.BillboardSet.aab">
            <summary>Bounds of all billboards in this set</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.originType">
            <summary>Origin of each billboard</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.defaultParticleWidth">
            <summary>Default width/height of each billboard.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.materialName">
            <summary>Name of the material to use</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.material">
            <summary>Reference to the material to use</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.allDefaultSize">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.autoExtendPool">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.worldSpace">
            <summary>True if particles follow the object the
            ParticleSystem is attached to.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.cullIndividual">
            <summary>Indicates whether or not each billboard should be culled individually.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.billboardType">
            <summary>Type of billboard to render.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.commonDirection">
            <summary>Common direction for billboard oriented with type Common.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.commonUpVector">
            <summary>Common up vector for billboard oriented with type Perpendicular.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.boundingRadius">
            <summary>The local bounding radius of this object.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.fixedTextureCoords">
            <summary>
            	Are tex coords fixed?  If not they have been modified.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor(System.String,System.Int32)">
            <summary>
            	Public constructor.  Should not be created manually, must be created using a SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            	Public constructor.  Should not be created manually, must be created using a SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.BeginBillboards">
            <summary>
                Generate the vertices for all the billboards relative to the camera
                Also take the opportunity to update the vertex colours
                May as well do it here to save on loops elsewhere
             </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyBillboardResized">
            <summary>
            	Callback used by Billboards to notify their parent that they have been resized.
             </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyBillboardRotated">
            <summary>
            	Callback used by Billboards to notify their parent that they have been resized.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyBillboardTextureCoordsModified">
            <summary>
            	Notifies the billboardset that texture coordinates will be modified
            	for this set.
             </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.IncreasePool(System.Int32)">
            <summary>
            	Internal method for increasing pool size.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.IsBillboardVisible(Axiom.Core.Camera,Axiom.Core.Billboard)">
            <summary>
            	Determines whether the supplied billboard is visible in the camera or not.
             </summary>
            <param name="camera"></param>
            <param name="billboard"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateBillboardAxes(Axiom.Math.Vector3@,Axiom.Math.Vector3@)">
            <summary>
            	Overloaded method.
             </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateBillboardAxes(Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Core.Billboard)">
            <summary>
            	Generates billboard corners.
             </summary>
            <remarks>Billboard param only required for type OrientedSelf</remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetParametricOffsets(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            	Generate parametric offsets based on the origin.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateVertexOffsets(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Vector3[])">
            <summary>
            	Generates vertex offsets.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="destVec"></param>
            <remarks>
            	Takes in parametric offsets as generated from GetParametericOffsets, width and height values
            	and billboard x and y axes as generated from GenerateBillboardAxes.
            	Fills output array of 4 vectors with vector offsets
            	from origin for left-top, right-top, left-bottom, right-bottom corners.
            </remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(Axiom.Math.Vector3)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(Axiom.Math.Vector3,Axiom.Core.ColorEx)">
            <summary>
            	Creates a new billboard and adds it to this set.
            </summary>
            <param name="position"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBuffers">
            <summary>
                Allocate / reallocate vertex data
                Note that we allocate enough space for ALL the billboards in the pool, but only issue
                rendering operations for the sections relating to the active billboards
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.Clear">
            <summary>
            	Empties all of the active billboards from this set.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.UpdateBounds">
            <summary>
            	Update the bounds of the BillboardSet.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetSquaredViewDepth(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            	Generate the vertices for all the billboards relative to the camera
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.SetDefaultDimensions(System.Single,System.Single)">
            <summary>
            	Sets the default dimensions of the billboards in this set.
            </summary>
             <remarks>
            	All billboards in a set are created with these default dimensions. The set will render most efficiently if
            	all the billboards in the set are the default size. It is possible to alter the size of individual
            	billboards at the expense of extra calculation. See the Billboard class for more info.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.AutoExtend">
            <summary>
            	Tells the set whether to allow automatic extension of the pool of billboards.
             </summary>
             <remarks>
            	A BillboardSet stores a pool of pre-constructed billboards which are used as needed when
            	a new billboard is requested. This allows applications to create / remove billboards efficiently
            	without incurring construction / destruction costs (a must for sets with lots of billboards like
            	particle effects). This method allows you to configure the behaviour when a new billboard is requested
            	but the billboard pool has been exhausted.
            	<p/>
            	The default behaviour is to allow the pool to extend (typically this allocates double the current
            	pool of billboards when the pool is expended), equivalent to calling this property to
            	true. If you set the property to false however, any attempt to create a new billboard
            	when the pool has expired will simply fail silently, returning a null pointer.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.PoolSize">
            <summary>
            	Adjusts the size of the pool of billboards available in this set.
             </summary>
             <remarks>
            	See the BillboardSet.AutoExtend property for full details of the billboard pool. This method adjusts
            	the preallocated size of the pool. If you try to reduce the size of the pool, the set has the option
            	of ignoring you if too many billboards are already in use. Bear in mind that calling this method will
            	incur significant construction / destruction calls so should be avoided in time-critical code. The same
            	goes for auto-extension, try to avoid it by estimating the pool size correctly up-front.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BillboardOrigin">
            <summary>
            	Gets/Sets the point which acts as the origin point for all billboards in this set.
             </summary>
             <remarks>
            	This setting controls the fine tuning of where a billboard appears in relation to it's
            	position. It could be that a billboard's position represents it's center (e.g. for fireballs),
            	it could mean the center of the bottom edge (e.g. a tree which is positioned on the ground),
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.MaterialName">
            <summary>
            	Gets/Sets the name of the material to use for this billboard set.
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CullIndividual">
            <summary>
            	Sets whether culling tests billboards in this individually as well as in a group.
            </summary>
             <remarks>
            	Billboard sets are always culled as a whole group, based on a bounding box which
            	encloses all billboards in the set. For fairly localised sets, this is enough. However, you
            	can optionally tell the set to also cull individual billboards in the set, i.e. to test
            	each individual billboard before rendering. The default is not to do this.
            	<p/>
            	This is useful when you have a large, fairly distributed set of billboards, like maybe
            	trees on a landscape. You probably still want to group them into more than one
            	set (maybe one set per section of landscape), which will be culled coarsely, but you also
            	want to cull the billboards individually because they are spread out. Whilst you could have
            	lots of single-tree sets which are culled separately, this would be inefficient to render
            	because each tree would be issued as it's own rendering operation.
            	<p/>
            	By setting this property to true, you can have large billboard sets which
            	are spaced out and so get the benefit of batch rendering and coarse culling, but also have
            	fine-grained culling so unnecessary rendering is avoided.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BillboardType">
            <summary>
            	Gets/Sets the type of billboard to render.
            </summary>
             <remarks>
            	The default sort of billboard (Point), always has both x and y axes parallel to
            	the camera's local axes. This is fine for 'point' style billboards (e.g. flares,
            	smoke, anything which is symmetrical about a central point) but does not look good for
            	billboards which have an orientation (e.g. an elongated raindrop). In this case, the
            	oriented billboards are more suitable (OrientedCommon or OrientedSelf) since they retain an independant Y axis
            	and only the X axis is generated, perpendicular to both the local Y and the camera Z.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CommonDirection">
            <summary>
            	Use this to specify the common direction given to billboards of types OrientedCommon or PerpendicularCommon.
            </summary>
             <remarks>
            	Use OrientedCommon when you want oriented billboards but you know they are always going to
            	be oriented the same way (e.g. rain in calm weather). It is faster for the system to calculate
            	the billboard vertices if they have a common direction.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CommonUpVector">
            <summary>
            	Use this to determine the orientation given to billboards of types PerpendicularCommon or PerpendicularSelf.
            </summary>
             <remarks>
            	Billboards will be oriented with their Y axis coplanar with the up direction vector.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.Billboards">
            <summary>
            	Gets the list of active billboards.
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BoundingRadius">
            <summary>
               Local bounding radius of this billboard set.
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.NumWorldTransforms">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.UseIdentityProjection">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.UseIdentityView">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.WorldOrientation">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.WorldPosition">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.TypeFlags">
            <summary>
            Get the 'type flags' for this <see cref="T:Axiom.Core.BillboardSet"/>.
            </summary>
            <seealso cref="P:Axiom.Core.MovableObject.TypeFlags"/>
        </member>
        <member name="T:Axiom.Collections.SubMeshCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.SubMesh">SubMeshes</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositionTargetPass">
            <summary>
                Object representing one pass or operation in a composition sequence. This provides a 
                method to conviently interleave RenderSystem commands between Render Queues.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.parent">
            <summary>
                Parent technique
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.inputMode">
            <summary>
                Input mode
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.outputName">
            <summary>
                (local) output texture
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.passes">
            <summary>
                Passes
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.onlyInitial">
            <summary>
                This target pass is only executed initially after the effect
                has been enabled.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.visibilityMask">
            <summary>
                Visibility mask for this render
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.lodBias">
            <summary>
                LOD bias of this render
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.materialScheme">
            <summary>
                Material scheme name
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTargetPass.shadowsEnabled">
            <summary>
            Shadows option
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionTargetPass.CreatePass">
            <summary>
                Create a new pass, and return a pointer to it.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.InputMode">
            <summary>
                Input mode
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.OutputName">
            <summary>
                (local) output texture
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.Passes">
            <summary>
                Passes
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.OnlyInitial">
            <summary>
                This target pass is only executed initially after the effect
                has been enabled.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.VisibilityMask">
            <summary>
                Visibility mask for this render
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.LodBias">
            <summary>
                LOD bias of this render
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.MaterialScheme">
            <summary>
                Material scheme name
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.ShadowsEnabled">
            <summary>
            Get's or Set's  whether shadows are enabled in this target pass.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTargetPass.IsSupported">
            <summary>
                Determine if this target pass is supported on the current rendering device. 
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.RenderWindowCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Graphics.RenderWindow">RenderWindows</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Pose">
            <summary>
            A pose is a linked set of vertex offsets applying to one set of vertex data. 
            </summary>
            <remarks>
            	The target index referred to by the pose has a meaning set by the user
            	of this class; but for example when used by Mesh it refers to either the
            	Mesh shared geometry (0) or a SubMesh dedicated geometry (1+).
            	Pose instances can be referred to by keyframes in VertexAnimationTrack in
            	order to animate based on blending poses together.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Pose.target">
            <summary>Target geometry index</summary>
        </member>
        <member name="F:Axiom.Animating.Pose.name">
            Optional name
        </member>
        <member name="F:Axiom.Animating.Pose.vertexOffsetMap">
            <summary>Primary storage, sparse vertex use</summary>
        </member>
        <member name="F:Axiom.Animating.Pose.vertexBuffer">
            <summary>Derived hardware buffer, covers all vertices</summary>
        </member>
        <member name="M:Axiom.Animating.Pose.#ctor(System.UInt16,System.String)">
            <summary>Constructor</summary>
            <param name="target">The target vertexdata index (0 for shared, 1+ for 
            	dedicated at the submesh index + 1</param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Animating.Pose.AddVertex(System.Int32,Axiom.Math.Vector3)">
            <summary>Adds an offset to a vertex for this pose.</summary>
            <param name="index"> The vertex index</param>
            <param name="offset"> The position offset for this pose</param>
        </member>
        <member name="M:Axiom.Animating.Pose.RemoveVertex(System.Int32)">
            <summary>Remove a vertex offset.</summary>
        </member>
        <member name="M:Axiom.Animating.Pose.ClearVertexOffsets">
            <summary>Clear all vertex offsets.</summary>
        </member>
        <member name="M:Axiom.Animating.Pose.GetHardwareVertexBuffer(System.Int32)">
            <summary>Get a hardware vertex buffer version of the vertex offsets.</summary>
        </member>
        <member name="T:Axiom.Utilities.Contract">
            <summary>
            This class is used to enforce that preconditions are met for method calls
            using clear and consice semantics.
            </summary>
        </member>
        <member name="M:Axiom.Utilities.Contract.Requires(System.Boolean)">
            <summary>
            Requires that a condition evaluates to <c>true</c>.
            </summary>
            <param name="condition"></param>
            <exception cref="T:System.ArgumentException">Condition is <c>false</c>.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.Requires(System.Boolean,System.String)">
            <overloads>
            <param name="condition"></param>
            <param name="name">Name of the requirement, this should be something unique to make it easy to find.</param>
            </overloads>
        </member>
        <member name="M:Axiom.Utilities.Contract.Requires(System.Boolean,System.String,System.String)">
            <overloads>
            <param name="condition"></param>
            <param name="name">Name of the requirement, this should be something unique to make it easy to find.</param>
            <param name="message">Message if the condition isn't met</param>
            </overloads>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresNotNull``1(``0,System.String)">
            <summary>
            Requires that a value not be <c>null</c>.
            </summary>
            <param name="value"></param>
            <param name="name"></param>
            <exception cref="T:System.ArgumentNullException">Value is <c>null</c>.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresNotEmpty(System.String,System.String)">
            <summary>
            Requires that the string not be <c>null</c> and not zero length.
            </summary>
            <param name="str"></param>
            <param name="name"></param>
            <exception cref="T:System.ArgumentException">String is <c>null</c> or zero length.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresNotEmpty``1(System.Collections.Generic.ICollection{``0},System.String)">
            <summary>
            Requires that the collection not be <c>null</c> and has at least one element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="name"></param>
            <exception cref="T:System.ArgumentException">Collection is <c>null</c> or has no elements.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Axiom.Utilities.Contract.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImpl">
            <summary>
            Summary description for MeshSerializerImpl.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializerImpl.mesh">
            <summary>
            	Target mesh for importing/exporting.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializerImpl.isSkeletallyAnimated">
            <summary>
            	Is this mesh animated with a skeleton?
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.ExportMesh(Axiom.Core.Mesh,System.String)">
            <summary>
            	Exports a mesh to the file specified.
            </summary>
            <remarks>
            	This method takes an externally created Mesh object, and exports both it
            	to a .mesh file.
            </remarks>
            <param name="mesh">Reference to the mesh to export.</param>
            <param name="fileName">The destination file name.</param>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.GetDependencyInfo(System.IO.Stream,Axiom.Core.Mesh)">
            <summary>
            Multiverse Extension
            </summary>
            <param name="stream"></param>
            <param name="mesh"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.ImportMesh(System.IO.Stream,Axiom.Core.Mesh)">
            <summary>
            	Imports mesh data from a .mesh file.
            </summary>
            <param name="stream">A stream containing the .mesh data.</param>
            <param name="mesh">Mesh to populate with the data.</param>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.ReadDependencyInfo(System.IO.BinaryReader,Axiom.Serialization.DependencyInfo)">
            <summary>
            Multiuverse Extension
            </summary>
            <param name="reader"></param>
            <param name="depends"></param>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.ReadAttachmentPoint(System.IO.BinaryReader)">
            <summary>
               Reads attachment point information from the file.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImplv14">
            <summary>
            Summary description for MeshSerializerImpl.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImplv14.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImplv13">
            <summary>
            Summary description for MeshSerializerImpl.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImplv13.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImplv12">
            <summary>
                Mesh serializer for supporint OGRE 1.20 meshes.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImplv11">
            <summary>
                Mesh serializer for supporint OGRE 1.10 meshes.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializer">
            <summary>
            	Class for serialising mesh data to/from an OGRE .mesh file.
            </summary>
            <remarks>
            	This class allows exporters to write OGRE .mesh files easily, and allows the
            	OGRE engine to import .mesh files into instatiated OGRE Meshes.
            	<p/>
            	It's important to realize that this exporter uses OGRE terminology. In this context,
            	'Mesh' means a top-level mesh structure which can actually contain many SubMeshes, each
            	of which has only one Material. Modelling packages may refer to these differently, for
            	example in Milkshape, it says 'Model' instead of 'Mesh' and 'Mesh' instead of 'SubMesh',
            	but the theory is the same.
            </remarks>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializer.implementations">
            <summary>
            	Lookup table holding the various mesh serializer versions.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializer.currentVersion">
            <summary>
            	Current version string.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializer.ExportMesh(Axiom.Core.Mesh,System.String)">
            <summary>
            	Exports a mesh to the file specified.
            </summary>
            <param name="mesh">Reference to the mesh to export.</param>
            <param name="fileName">The destination filename.</param>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializer.ImportMesh(System.IO.Stream,Axiom.Core.Mesh)">
            <summary>
            	Imports mesh data from a .mesh file.
            </summary>
            <param name="stream">The stream holding the .mesh data. Must be initialised (pos at the start of the buffer).</param>
            <param name="mesh">Reference to the Mesh object which will receive the data. Should be blank already.</param>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerManager">
            <summary>
            Manages threaded compilation of scripts. This script loader forwards
            scripts compilations to a specific compiler instance.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerManager.GetTranslator(Axiom.Scripting.Compiler.AST.AbstractNode)">
            <summary>
            Retrieves a ScriptTranslator from the supported managers
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerManager._setCompilerEvents">
            <summary>
            Set events of this manager's compiler
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerManager._unsetCompilerEvents">
            <summary>
            Unset events of this manager's compiler
            </summary>
        </member>
        <member name="P:Axiom.Scripting.Compiler.ScriptCompilerManager.ScriptPatterns">
            <summary>
            A list of patterns loaded by this compiler manager
            </summary>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnImportFile">
            Returns the concrete node list from the given file
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnPreConversion">
            Allows for responding to and overriding behavior before a CST is translated into an AST
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnPostConversion">
            <summary>
            Allows vetoing of continued compilation after the entire AST conversion process finishes
            </summary>
            <remarks>
            Once the script is turned completely into an AST, including import
            and override handling, this function allows a listener to exit
            the compilation process.
            </remarks>
            <returns>
            True continues compilation, false aborts
            </returns>
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnCompileError">
            Called when an error occurred
        </member>
        <member name="E:Axiom.Scripting.Compiler.ScriptCompilerManager.OnCompilerEvent">
            <summary>
            Called when an event occurs during translation, return true if handled
            </summary>
            <remarks>
            This function is called from the translators when an event occurs that
            that can be responded to. Often this is overriding names, or it can be a request for
            custom resource creation.
            </remarks>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerManager.ImportFileHandler">
            Returns the concrete node list from the given file
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerManager.PreConversionHandler">
            Allows for responding to and overriding behavior before a CST is translated into an AST
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerManager.PostConversionHandler">
            <summary>
            Allows vetoing of continued compilation after the entire AST conversion process finishes
            </summary>
            <remarks>
            Once the script is turned completely into an AST, including import
            and override handling, this function allows a listener to exit
            the compilation process.
            </remarks>
            <returns>
            True continues compilation, false aborts
            </returns>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerManager.CompilerErrorHandler">
            Called when an error occurred
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerManager.TransationEventHandler">
            <summary>
            Called when an event occurs during translation, return true if handled
            </summary>
            <remarks>
            This function is called from the translators when an event occurs that
            that can be responded to. Often this is overriding names, or it can be a request for
            custom resource creation.
            </remarks>
            <param name="compiler">A reference to the compiler</param>
            <param name="evt">The event object holding information about the event to be processed</param>
            <param name="retval">A possible return value from handlers</param>
            <returns>True if the handler processed the event</returns>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptTranslatorManager">
            <summary>
            The ScriptTranslatorManager manages the lifetime and access to
            script translators. You register these managers with the
            ScriptCompilerManager tied to specific object types.
            Each manager may manage multiple types.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptTranslatorManager.GetTranslator(Axiom.Scripting.Compiler.AST.AbstractNode)">
            <summary>
            Returns a manager for the given object abstract node, or null if it is not supported
            </summary>
            <param name="node"></param>
            <returns>Returns a manager for the given object abstract node, or null if it is not supported</returns>
        </member>
        <member name="P:Axiom.Scripting.Compiler.ScriptTranslatorManager.TranslatorsCount">
            <summary>
            Returns the number of translators being managed
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.BuiltinScriptTranslatorManager">
            <summary>
            This class manages the builtin translators
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.ObjectAbstractNode">
            <summary>
            This specific abstract node represents a script object
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.ObjectAbstractNode.Clone">
            <see cref="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone"/>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.ObjectAbstractNode.Overrides">
            <summary>
            For use when processing object inheritance and overriding
            </summary>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.ObjectAbstractNode.Value">
            <see cref="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value"/>
        </member>
        <member name="T:Axiom.Overlays.Elements.TextArea">
            <summary>
            	Label type control that can be used to display text using a specified font.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.Elements.TextArea.colorBottom">
            Colors to use for the vertices
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.#ctor(System.String)">
            <summary>
               Basic constructor, internal since it should only be created by factories.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.CheckMemoryAllocation(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.Update">
            <summary>
               Override to update char sizing based on current viewport settings.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.UpdateColors">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.UpdateGeometry">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.UpdatePositionGeometry">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.CharHeight">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.Color">
            <summary>
               Gets/Sets the color value of the text when it is all the same color.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.ColorTop">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.ColorBottom">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.FontName">
            <summary>
               Gets/Sets the name of the font currently being used when rendering the text.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.MaterialName">
            <summary>
               Override to update geometry when new material is assigned.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.MetricsMode">
            <summary>
               Override to handle character spacing
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.SpaceWidth">
            <summary>
               
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.TextAlign">
            <summary>
               Alignment of text specifically.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.Text">
            <summary>
               Override to update string geometry.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.CharacterHeightAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.CharacterHeightAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.SpaceWidthAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.SpaceWidthAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.FontNameAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.FontNameAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.HorizontalAlignmentAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.HorizontalAlignmentAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.ColorAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.ColorAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.TopColorAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.TopColorAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.BottomColorAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.BottomColorAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="T:Axiom.Math.Collections.PlaneList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.PlaneBoundedVolumeList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTexture">
            <summary>
               Custom RenderTarget that allows for rendering a scene to a texture.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTexture.dispose(System.Boolean)">
            <summary>
            Ensures texture is destroyed.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramManager">
            <summary>
            	Summary description for GpuProgramManager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramManager._instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
            <remarks>
                Protected internal because this singleton will actually hold the instance of a subclass
                created by a render system plugin.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Create(System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Creates a new GpuProgram.
            </summary>
            <param name="name">
               Name of the program to create.
            </param>
            <param name="group"></param>
            <param name="type">
               Type of the program to create, i.e. vertex or fragment.
            </param>
            <param name="syntaxCode">
               Syntax of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <returns>
               A new instance of GpuProgram.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Create(System.String,System.String,Axiom.Graphics.GpuProgramType,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <summary>
               Creates a new GpuProgram.
            </summary>
            <param name="name">
               Name of the program to create.
            </param>
            <param name="group"></param>
            <param name="type">
               Type of the program to create, i.e. vertex or fragment.
            </param>
            <param name="syntaxCode">
               Syntax of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <param name="isManual"></param>
            <param name="loader"></param>
            <returns>
               A new instance of GpuProgram.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager._create(System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
            Internal method for created programs, must be implemented by subclasses
            </summary>
            <param name="name"> Name of the program to create.</param>
            <param name="handle">Handle of the program</param>
            <param name="group">resource group of the program</param>
            <param name="isManual">is this program manually created</param>
            <param name="loader">The ManualResourceLoader if this program is manually loaded</param>
            <param name="type">Type of the program to create, i.e. vertex or fragment.</param>
            <param name="syntaxCode">Syntax of the program, i.e. vs_1_1, arbvp1, etc.</param>
            <returns>A new instance of GpuProgram.</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.CreateProgram(System.String,System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Create a new, unloaded GpuProgram from a file of assembly.
            </summary>
            <remarks>
               Use this method in preference to the 'load' methods if you wish to define
               a GpuProgram, but not load it yet; useful for saving memory.
            </remarks>
            <param name="name">
               The name of the program.
            </param>
            <param name="group"></param>
            <param name="fileName">
               The file to load.
            </param>
            <param name="type"></param>
            <param name="syntaxCode">
               Name of the syntax to use for the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <returns>
               An unloaded GpuProgram instance.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.CreateProgramFromString(System.String,System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Create a new, unloaded GpuProgram from a string of assembly code.
            </summary>
            <remarks>
               Use this method in preference to the 'load' methods if you wish to define
               a GpuProgram, but not load it yet; useful for saving memory.
            </remarks>
            <param name="name">
               The name of the program.
            </param>
            <param name="group"></param>
            <param name="source">
               The asm source of the program to create.
            </param>
            <param name="type"></param>
            <param name="syntaxCode">
               Name of the syntax to use for the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <returns>An unloaded GpuProgram instance.</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.CreateParameters">
            <summary>
               Creates a new GpuProgramParameters instance which can be used to bind parameters 
               to your programs.
            </summary>
            <remarks>
               Program parameters can be shared between multiple programs if you wish.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.IsSyntaxSupported(System.String)">
            <summary>
               Returns whether a given syntax code (e.g. "ps_1_3", "fp20", "arbvp1") is supported. 
            </summary>
            <param name="syntaxCode"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Load(System.String,System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Loads a GPU program from a file of assembly.
            </summary>
            <remarks>
               This method creates a new program of the type specified as the second parameter.
               As with all types of ResourceManager, this class will search for the file in
               all resource locations it has been configured to look in.
            </remarks>
            <param name="name">
               Identifying name of the program to load.
            </param>
            <param name="group"></param>
            <param name="fileName">
               The file to load.
            </param>
            <param name="type">
               Type of program to create.
            </param>
            <param name="syntaxCode">
               Syntax code of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.LoadFromString(System.String,System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Loads a GPU program from a string containing the assembly source.
            </summary>
            <remarks>
               This method creates a new program of the type specified as the second parameter.
               As with all types of ResourceManager, this class will search for the file in
               all resource locations it has been configured to look in.
            </remarks>
            <param name="name">
               Name used to identify this program.
            </param>
            <param name="group"></param>
            <param name="source">
               Source code of the program to load.
            </param>
            <param name="type">
               Type of program to create.
            </param>
            <param name="syntaxCode">
               Syntax code of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.GetByName(System.String)">
            <summary>
                Gets a GpuProgram with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.dispose(System.Boolean)">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferStream">
            <summary>
                This class is intended to allow a clean stream interface for writing to hardware buffers.
                An instance of this would be returned by one of the HardwareBuffer.Lock methods, which would
                allow easily and safely writing to a hardware buffer without having to use unsafe code.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.position">
            <summary>
            	Current position (as a byte offset) into the stream.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.data">
            <summary>
                Pointer to the raw data we will be writing to.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.owner">
            <summary>
                Reference to the hardware buffer who owns this stream.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.tmp">
            <summary>
                Temp array.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.#ctor(Axiom.Graphics.HardwareBuffer,System.IntPtr)">
            <summary>
                Constructor.
            </summary>
            <param name="owner">Reference to the hardware buffer who owns this stream.</param>
            <param name="data">Pointer to the raw data we will be writing to.</param>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Write(System.Array,System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="val"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Seek(System.Int64)">
            <summary>
                Moves the "cursor" position within the buffer.
            </summary>
            <param name="offset">Offset (in bytes) to move from the current position.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
                Moves the "cursor" position within the buffer.
            </summary>
            <param name="offset">Number of bytes to move.</param>
            <param name="origin">How to treat the offset amount.</param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.BufferStream.Length">
            <summary>
                Length (in bytes) of this stream.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.BufferStream.Position">
            <summary>
                Current position of the stream.
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FontType">
            <summary>
            	Possible font sources for use in the engine.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FontType.TrueType">
            <summary>System truetype fonts, as well as supplementary .ttf files.</summary>
        </member>
        <member name="F:Axiom.Fonts.FontType.Image">
            <summary>Character image map created by an artist.</summary>
        </member>
        <member name="T:Axiom.Fonts.Font">
            <summary>
            	This class is simply a way of getting a font texture into the engine and
            	to easily retrieve the texture coordinates required to accurately render them.
            	Fonts can either be loaded from precreated textures, or the texture can be generated
            	using a truetype font. You can either create the texture manually in code, or you
            	can use an XML font script to define it (probably more practical since you can reuse
            	the definition more easily)
            </summary>
            <remarks>	
            This class extends both Resource and ManualResourceLoader since it is
            both a resource in it's own right, but it also provides the manual load
            implementation for the Texture it creates.
            </remarks>
            
            <ogre name="Font">
                <file name="OgreFont.h"   revision="1.14" lastUpdated="5/22/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreFont.cpp" revision="1.32.2.2" lastUpdated="5/22/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
            
        </member>
        <member name="T:Axiom.Core.Resource">
            <summary>
            	Abstract class representing a loadable resource (e.g. textures, sounds etc)
            </summary>
            <remarks>
            	Resources are generally passive constructs, handled through the
            	ResourceManager abstract class for the appropriate subclass.
            	The main thing is that Resources can be loaded or unloaded by the
            	ResourceManager to stay within a defined memory budget. Therefore,
            	all Resources must be able to load, unload (whilst retainin enough
            	info about themselves to be reloaded later), and state how big they are.
            <para/>
            	Subclasses must implement:
            	1. A constructor, with at least a mandatory name param.
            		This constructor must set name and optionally size.
            	2. The Load() and Unload() methods - size must be set after Load()
            		Each must check &amp; update the isLoaded flag.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.#ctor">
            <summary>
            Protected unnamed constructor to prevent default construction.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String)">
            <overloads>
            <summary>
            Standard constructor.
            </summary>
            <param name="parent">ResourceManager that is creating this resource</param>
            <param name="name">The unique name of the resource</param>
            <param name="handle"></param>
            <param name="group">The name of the resource group to which this resource belongs</param>
            </overloads>
        </member>
        <member name="M:Axiom.Core.Resource.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <param name="group"></param>
            <param name="isManual">
                Is this resource manually loaded? If so, you should really
                populate the loader parameter in order that the load process
                can call the loader back when loading is required.
            </param>
            <param name="loader">
                An IManualResourceLoader implementation which will be called
                when the Resource wishes to load (should be supplied if you set
                isManual to true). You can in fact leave this parameter null
                if you wish, but the Resource will never be able to reload if
                anything ever causes it to unload. Therefore provision of a proper
                IManualResourceLoader instance is strongly recommended.
            </param>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="handle"></param>
        </member>
        <member name="M:Axiom.Core.Resource.preLoad">
            <summary>
            Internal hook to perform actions before the load process, but
            after the resource has been marked as 'Loading'.
            </summary>
            <remarks>
            Mutex will have already been acquired by the loading thread.
            Also, this call will occur even when using a <see>IManualResourceLoader</see>
            (when <see>load()</see> is not actually called)
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.postLoad">
            <summary>
            Internal hook to perform actions after the load process, but
            before the resource has been marked as 'Loaded'.
            </summary>
            <remarks>
            Mutex will have already been acquired by the loading thread.
            Also, this call will occur even when using a <see>IManualResourceLoader</see>
            (when <see>load()</see> is not actually called)
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.preUnload">
            <summary>
            Internal hook to perform actions before the unload process, but
            after the resource has been marked as 'Unloading'.
            </summary>
            <remarks>
            Mutex will have already been acquired by the unloading thread.
            Also, this call will occur even when using a <see>IManualResourceLoader</see>
            (when <see>unload()</see> is not actually called)
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.postUnload">
            <summary>
            Internal hook to perform actions after the unload process, but
            before the resource has been marked as 'Unloaded'.
            </summary>
            <remarks>
            Mutex will have already been acquired by the unloading thread.
            Also, this call will occur even when using a <see>IManualResourceLoader</see>
            (when <see>unload()</see> is not actually called)
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.Prepare">
            <summary>
            Prepares the resource for load, if it is not already.
            </summary>
            <see cref="M:Axiom.Core.Resource.Prepare(System.Boolean)"/>
        </member>
        <member name="M:Axiom.Core.Resource.Prepare(System.Boolean)">
            <summary>
            Prepares the resource for load, if it is not already.
            </summary>
            <remarks>
            One can call prepare() before load(), but this is not required as load() will call prepare() 
            itself, if needed.  When OGRE_THREAD_SUPPORT==1 both load() and prepare() 
            are thread-safe.  When OGRE_THREAD_SUPPORT==2 however, only prepare() 
            is thread-safe.  The reason for this function is to allow a background 
            thread to do some of the loading work, without requiring the whole render
            system to be thread-safe.  The background thread would call
            prepare() while the main render loop would later call load().  So long as
            prepare() remains thread-safe, subclasses can arbitrarily split the work of
            loading a resource between load() and prepare().  It is best to try and
            do as much work in prepare(), however, since this will leave less work for
            the main render thread to do and thus increase FPS.
            </remarks>
            <param name="background">Whether this is occurring in a background thread</param>
        </member>
        <member name="M:Axiom.Core.Resource.EscalateLoading">
            <summary>
            Escalates the loading of a background loaded resource.
            </summary>
            <remarks>
            If a resource is set to load in the background, but something needs
            it before it's been loaded, there could be a problem. If the user
            of this resource really can't wait, they can escalate the loading
            which basically pulls the loading into the current thread immediately.
            If the resource is already being loaded but just hasn't quite finished
            then this method will simply wait until the background load is complete.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.Load">
            <summary>
            	Loads the resource, if not loaded already.
            </summary>
            <remarks>
            If the resource is loaded from a file, loading is automatic. If not,
            if for example this resource gained it's data from procedural calls
            rather than loading from a file, then this resource will not reload
            on it's own
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.Load(System.Boolean)">
            <summary>
            Loads the resource, if not loaded already.
            </summary>
            <remarks>
            If the resource is loaded from a file, loading is automatic. If not,
            if for example this resource gained it's data from procedural calls
            rather than loading from a file, then this resource will not reload
            on it's own.
            </remarks>
            <param name="background">Indicates whether the caller of this method is
            the background resource loading thread.</param>
        </member>
        <member name="M:Axiom.Core.Resource.Unload">
            <summary>
            	Unloads the resource data, but retains enough info. to be able to recreate it
            	on demand.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Reload">
            <summary>
            Reloads the resource, if it is already loaded.
            </summary>
            <remarks>
            Calls unload() and then load() again, if the resource is already
            loaded. If it is not loaded already, then nothing happens.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Resource.Touch">
            <summary>
            	Indicates this resource has been used.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.calculateSize">
            <summary>
            Calculate the size of a resource; this will only be called after 'load'
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Resource.load">
            <summary>
            Internal implementation of the 'load' action, only called if this
            resource is not being loaded from a ManualResourceLoader.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.unload">
            <summary>
            Internal implementation of the 'unload' action; called regardless of
            whether this resource is being loaded from a ManualResourceLoader.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Creator">
            <summary>
            the manager which created this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Name">
            <summary>
            	Name of this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Group">
            <summary>
            Gets the group which this resource is a member of
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.IsLoaded">
            <summary>
            	Has this resource been loaded yet?
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.IsLoading">
            <summary>
            	Has this resource been loaded yet?
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.IsManuallyLoaded">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Size">
            <summary>
            	Size (in bytes) that this resource takes up in memory.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.LastAccessed">
            <summary>
            	Timestamp of the last time this resource was accessed.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Handle">
            <summary>
            	Unique handle of this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Origin">
            <summary>
            Origin of this resource (e.g. script name) - optional
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.loader">
            <summary>
            Optional manual loader; if provided, data is loaded from here instead of a file
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.LoadingState">
            <summary>
            Returns whether the resource is currently in the process of	background loading.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.IsBackgroundLoaded">
            <summary>
            Returns whether this Resource has been earmarked for background loading.
            </summary>
            <remarks>
            This option only makes sense when you have built Axiom with
            thread support (AXIOM_THREAD_SUPPORT). If a resource has been marked
            for background loading, then it won't load on demand like normal
            when load() is called. Instead, it will ignore request to load()
            except if the caller indicates it is the background loader. Any
            other users of this resource should check isLoaded(), and if that
            returns false, don't use the resource and come back later.
            <para/>
            Note that setting this only	defers the normal on-demand loading
            behaviour of a resource, it	does not actually set up a thread to make
            sure the resource gets loaded in the background. You should use
            ResourceBackgroundLoadingQueue to manage the actual loading
            (which will set this property itself).
            </remarks>
        </member>
        <member name="P:Axiom.Core.Resource.IsReloadable">
            <summary>
             Is the Resource reloadable?
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.IManualResourceLoader">
            <summary>
            Interface describing a manual resource loader.
            </summary>
            <remarks>
            Resources are usually loaded from files; however in some cases you
            want to be able to set the data up manually instead. This provides
            some problems, such as how to reload a Resource if it becomes
            unloaded for some reason, either because of memory constraints, or
            because a device fails and some or all of the data is lost.
            <para/>
            This interface should be implemented by all classes which wish to
            provide manual data to a resource. They provide a pointer to themselves
            when defining the resource (via the appropriate ResourceManager),
            and will be called when the Resource tries to load.
            They should implement the loadResource method such that the Resource
            is in the end set up exactly as if it had loaded from a file,
            although the implementations will likely differ	between subclasses
            of Resource, which is why no generic algorithm can be stated here.
            <para/>
            The loader must remain valid for the entire life of the resource,
            so that if need be it can be called upon to re-load the resource
            at any time.
            </remarks>
            <ogre name="ManualResourceLoader">
                <file name="OgreResource.h"   revision="1.16.2.1" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre>
        </member>
        <member name="M:Axiom.Core.IManualResourceLoader.LoadResource(Axiom.Core.Resource)">
            <summary>
            Called when a resource wishes to load.
            </summary>
            <param name="resource">The resource which wishes to load</param>
        </member>
        <member name="F:Axiom.Fonts.Font.maxBearingY">
            <summary>
             Max distance to baseline of this (truetype) font
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._fontType">
            <summary>
               Type of font, either imag based or TrueType.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._source">
            <summary>
               Source of the font (either an image name or a TrueType font).
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._ttfSize">
            <summary>
               Size of the truetype font, in points.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._ttfResolution">
            <summary>
               Resolution (dpi) of truetype font.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._material">
            <summary>
               Material create for use on entities by this font.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._texture">
            <summary>
               Material create for use on entities by this font.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font._antialiasColor">
            <summary>
               For TrueType fonts only.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.Font.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String)">
            <summary>
            	Constructor, should be called through FontManager.Create().
            </summary>
        </member>
        <member name="M:Axiom.Fonts.Font.StrBBox(System.String,System.Single,Axiom.Graphics.RenderWindow)">
            <summary>Returns the size in pixels of a box that could contain the whole string.</summary>
        </member>
        <member name="M:Axiom.Fonts.Font.GetGlyphTexCoords(System.UInt32,Axiom.Math.Real@,Axiom.Math.Real@,Axiom.Math.Real@,Axiom.Math.Real@)">
            <summary>
            	Retrieves the texture coordinates for the specifed character in this font.
            </summary>
            <param name="c"></param>
            <param name="u1"></param>
            <param name="u2"></param>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:Axiom.Fonts.Font.SetGlyphTexCoords(System.UInt32,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Sets the texture coordinates of a glyph.
            </summary>
            <param name="c"></param>
            <param name="u1"></param>
            <param name="v1"></param>
            <param name="u2"></param>
            <param name="v2"></param>
            <remarks>
            You only need to call this if you're setting up a font loaded from a texture manually.
            </remarks>
        </member>
        <member name="M:Axiom.Fonts.Font.SetGlyphTexCoords(System.UInt32,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Sets the texture coordinates of a glyph.
            </summary>
            <param name="c"></param>
            <param name="u1"></param>
            <param name="v1"></param>
            <param name="u2"></param>
            <param name="v2"></param>
            <param name="aspect"></param>
            <remarks>
            You only need to call this if you're setting up a font loaded from a texture manually.
            <para>
            Also sets the aspect ratio (width / height) of this character. textureAspect
            is the width/height of the texture (may be non-square)
            </para>
            </remarks>
        </member>
        <member name="M:Axiom.Fonts.Font.GetGlyphAspectRatio(System.Char)">
            <summary>
            	Finds the aspect ratio of the specified character in this font.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Fonts.Font.Type">
            <summary>
               Type of font.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.Source">
            <summary>
               Source of the font (either an image name or a truetype font)
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.TrueTypeSize">
            <summary>
               Size of the truetype font, in points.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.TrueTypeResolution">
            <summary>
               Resolution (dpi) of truetype font.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.Material">
            <summary>
               Gets a reference to the material being used for this font.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.texture">
            <summary>
               Gets a reference to the material being used for this font.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.AntialiasColor">
            <summary>
               Sets whether or not the color of this font is antialiased as it is generated
               from a TrueType font.
            </summary>
            <remarks>
               This is valid only for a TrueType font. If you are planning on using 
               alpha blending to draw your font, then it is a good idea to set this to
               false (which is the default), otherwise the darkening of the font will combine
               with the fading out of the alpha around the edges and make your font look thinner
               than it should. However, if you intend to blend your font using a color blending
               mode (add or modulate for example) then it's a good idea to set this to true, in
               order to soften your font edges.
            </remarks>
        </member>
        <member name="T:Axiom.Core.RenderQueueEvent">
            <summary>
            	Delegate for speicfying the method signature for a render queue event.
            </summary>
        </member>
        <member name="T:Axiom.Core.FindVisibleObjectsEvent">
            <summary>
            Delegate for FindVisibleObject events
            </summary>
            <param name="manager"></param>
            <param name="stage"></param>
            <param name="view"></param>
        </member>
        <member name="T:Axiom.Core.SceneManager">
            <summary>
            	Manages the organization and rendering of a 'scene' i.e. a collection
            	of objects and potentially world geometry.
            </summary>
            <remarks>
            	This class defines the interface and the basic behaviour of a
            	'Scene Manager'. A SceneManager organizes the culling and rendering of
            	the scene, in conjunction with the <see cref="T:Axiom.Graphics.RenderQueue"/>. This class is designed
            	to be extended through subclassing in order to provide more specialized
            	scene organization structures for particular needs. The default
            	SceneManager culls based on a hierarchy of node bounding boxes, other
            	implementations can use an octree (<see name="OctreeSceneManager"/>), a BSP
            	tree (<see name="BspSceneManager"/>), and many other options. New SceneManager
            	implementations can be added at runtime by plugins, see <see cref="T:Axiom.Core.SceneManagerEnumerator"/>
            	for the interfaces for adding new SceneManager types.
              <p/>
            	There is a distinction between 'objects' (which subclass <see cref="T:Axiom.Core.MovableObject"/>,
            	and are movable, discrete objects in the world), and 'world geometry',
            	which is large, generally static geometry. World geometry tends to
            	influence the SceneManager organizational structure (e.g. lots of indoor
            	static geometry might result in a spatial tree structure) and as such
            	world geometry is generally tied to a given SceneManager implementation,
            	whilst MovableObject instances can be used with any SceneManager.
            	Subclasses are free to define world geometry however they please.
             <p/>
            	Multiple SceneManager instances can exist at one time, each one with
            	a distinct scene. Which SceneManager is used to render a scene is
            	dependent on the <see cref="T:Axiom.Core.Camera"/>, which will always call back the SceneManager
            	which created it to render the scene.
             </remarks>
            TODO: Thoroughly review node removal/cleanup.
            TODO: Review of method visibility/virtuality to ensure consistency.
            
        </member>
        <member name="F:Axiom.Core.SceneManager._activeCompositorChain">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.localLightList">
            <summary>
               Local light list for use during rendering passes.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.normalizeNormals">
            <summary>
               Whether normals are currently being normalized.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.ambientColor">
            <summary>The ambient color, cached from the RenderSystem</summary>
            <remarks>Default to a semi-bright white (gray) light to prevent being null</remarks>
        </member>
        <member name="F:Axiom.Core.SceneManager.animationList">
            <summary>A list of animations for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.animationStateList">
            <summary>A list of animation states for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.autoParamDataSource">
            <summary>
               Utility class for updating automatic GPU program params.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.autoTrackingSceneNodes">
            <summary>
            	Active list of nodes tracking other nodes.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.cameraInProgress">
            <summary>A reference to the current camera being used for rendering.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.cameraList">
            <summary>A list of the valid cameras for this scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.defaultRootNode">
            <summary>
            	If set, only this scene node (and children) will be rendered.
            	If null, root node is used.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.displayNodes">
            <summary>Flag indicating whether SceneNodes will be rendered as a set of 3 axes.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.findVisibleObjects">
            <summary>
                Find visible objects?
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.finiteExtrusionParams">
            <summary>
            	Program parameters for finite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.fullScreenQuad">
            <summary>
            	Full screen rectangle to use for rendering stencil shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.hasCameraChanged">
            <summary>Denotes whether or not the camera has been changed.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.illuminationStage">
            <summary>
            	Current stage of rendering.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.infiniteExtrusionParams">
            <summary>
            	Program parameters for infinite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.lightsAffectingFrustum">
            <summary>
            	List of lights in view that could cast shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.name">
            <summary>  The instance name of this scene manager.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.optionList">
            <summary>Hashtable of options that can be used by this or any other scene manager.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.regionList">
            <summary>
               A list of the Regions.
               TODO: Is there any point to having this region list?
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.renderingMainGroup">
            <summary>
            True when the main priority group is rendering.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.renderingNoShadowQueue">
            <summary>
            True when calling RenderSolidObjects with the noShadow queue.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.renderQueue">
            <summary>A queue of objects for rendering.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.specialCaseRenderQueueList">
            <summary>
            A List of RenderQueues to either Include or Exclude in the rendering sequence.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.rootSceneNode">
            <summary>The root of the scene graph heirarchy.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.sceneNodeList">
            <summary>A list of scene nodes (includes all in the scene graph).</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterAABBQuery">
            <summary>
            	AxisAlignedBox region query to find shadow casters within the attenuation range of a directional light.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterList">
            <summary>
            	Current list of shadow casters within the view of the camera.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterPlainBlackPass">
            <summary>
            	A pass designed to let us render shadow colour on white for texture shadows
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterQueryListener">
            <summary>
            	Listener to use when finding shadow casters for a light within a scene.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterSphereQuery">
            <summary>
            	Sphere region query to find shadow casters within the attenuation range of a point/spot light.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowColor">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowDebugPass">
            <summary>
            	Pass to use for rendering debug shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowDirLightExtrudeDist">
            <summary>
            	Explicit extrusion distance for directional lights.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowFarDistance">
            <summary>
            	Farthest distance from the camera at which to render shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowFarDistanceSquared">
            <summary>
            	shadowFarDistance ^ 2
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowIndexBuffer">
            <summary>
            	buffer to use for indexing shadow geometry required for certain techniques.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowIndexBufferSize">
            <summary>
            	The maximum size of the index buffer used to render shadow primitives.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowMaterialInitDone">
            <summary>
            	For the RenderTextureShadowCasterQueueGroupObjects and
            	RenderTextureShadowReceiverQueueGroupObjects methods.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowModulativePass">
            <summary>
            	Pass to use while rendering the full screen quad for modulative shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowReceiverPass">
            <summary>
            	A pass designed to let us render shadow receivers for texture shadows
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowStencilPass">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTechnique">
            <summary>
            	Current shadow technique in use in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCameras">
            <summary>
                Current list of shadow texture cameras.  There is one camera
                for each shadow texture.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCasterMaterial">
            <summary>
            	The material file to be use for shadow casters, if any
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCount">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomCasterFPParams">
            <summary>
            	The parameters of the pixel program that renders custom shadow casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomCasterFragmentProgram">
            <summary>
            	The name of the pixel program that renders custom shadow casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomCasterPass">
            <summary>
            	The pass that renders custom texture casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomCasterVertexProgram">
            <summary>
            	The name of the vertex program that renders custom shadow casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomCasterVPParams">
            <summary>
            	The parameters of the vertex program that renders custom shadow casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomReceiverFPParams">
            <summary>
            	The parameters of the pixel program that renders custom shadow casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomReceiverFragmentProgram">
            <summary>
            	The name of the pixel program that renders custom shadow receivers, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomReceiverPass">
            <summary>
            	The material file to be use for shadow receivers, if any
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomReceiverVertexProgram">
            <summary>
            	The name of the vertex program that renders custom shadow receivers, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCustomReceiverVPParams">
            <summary>
            	The parameters of the vertex program that renders custom shadow casters, or null
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureFadeEnd">
            <summary>
            	As a proportion e.g. 0.9
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureFadeStart">
            <summary>
            	As a proportion e.g. 0.6
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureFormat">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureOffset">
            <summary>
            	Proportion of texture offset in view direction e.g. 0.4
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureReceiverMaterial">
            <summary>
            	The material file to be use for shadow receivers, if any
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextures">
            <summary>
            	Current list of shadow textures.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureSelfShadow">
            <summary>
                The default implementation of texture shadows uses a fixed-function
               	color texture projection approach for maximum compatibility, and
                as such cannot support self-shadowing. However, if you decide to
                implement a more complex shadowing technique using
                ShadowTextureCasterMaterial and ShadowTextureReceiverMaterial
                there is a possibility you may be able to support
                self-shadowing (e.g by implementing a shader-based shadow map). In
                this case you might want to enable this option.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureSize">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowUseInfiniteFarPlane">
            <summary>
            	Whether we should override far distance when using stencil volumes
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.showDebugShadows">
            <summary>
            	If true, shadow volumes will be visible in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.showBoundingBoxes">
            <summary>Flag that specifies whether scene nodes will have their bounding boxes rendered as a wire frame.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.staticGeometryList">
             <summary>
            		The list of static geometry instances maintained by
                 the scene manager
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.suppressRenderStateChanges">
            <summary>
                Suppress render state changes?
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.suppressShadows">
            <summary>
                Suppress shadows?
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.targetRenderSystem">
            <summary>A reference to the current active render system..</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.visibilityMask">
             <summary>
            		Used by compositing layer
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSceneNode">
            <summary>
            	Creates an instance of a SceneNode.
            </summary>
            <remarks>
               Note that this does not add the SceneNode to the scene hierarchy.
            	This method is for convenience, since it allows an instance to
            	be created for which the SceneManager is responsible for
            	allocating and releasing memory, which is convenient in complex
            	scenes.
            	<p/>
                To include the returned SceneNode in the scene, use the AddChild
            	method of the SceneNode which is to be it's parent.
            	<p/>
                Note that this method takes no parameters, and the node created is unnamed (it is
                actually given a generated name, which you can retrieve if you want).
                If you wish to create a node with a specific name, call the alternative method
                which takes a name parameter.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSceneNode(System.String)">
            <summary>
            	Creates an instance of a SceneNode with a given name.
            </summary>
            <remarks>
            	Note that this does not add the SceneNode to the scene hierarchy.
            	This method is for convenience, since it allows an instance to
            	be created for which the SceneManager is responsible for
            	allocating and releasing memory, which is convenient in complex
            	scenes.
            	<p/>
            	To include the returned SceneNode in the scene, use the AddChild
            	method of the SceneNode which is to be it's parent.
            	<p/>
            	Note that this method takes a name parameter, which makes the node easier to
            	retrieve directly again later.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAnimation(System.String,System.Single)">
            <summary>
            	Creates an animation which can be used to animate scene nodes.
            </summary>
            <remarks>
            	An animation is a collection of 'tracks' which over time change the position / orientation
            	of Node objects. In this case, the animation will likely have tracks to modify the position
            	/ orientation of SceneNode objects, e.g. to make objects move along a path.
            	<p/>
            	You don't need to use an Animation object to move objects around - you can do it yourself
            	using the methods of the Node in your application. However, when you need relatively
            	complex scripted animation, this is the class to use since it will interpolate between
            	keyframes for you and generally make the whole process easier to manage.
            	<p/>
            	A single animation can affect multiple Node objects (each AnimationTrack affects a single Node).
            	In addition, through animation blending a single Node can be affected by multiple animations,
            	although this is more useful when performing skeletal animation (see Skeleton.CreateAnimation).
            </remarks>
            <param name="name"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAnimationState(System.String)">
            <summary>
            	Create an AnimationState object for managing application of animations.
            </summary>
            <remarks>
            	<para>
            	You can create Animation objects for animating SceneNode obejcts using the
            	CreateAnimation method. However, in order to actually apply those animations
            	you have to call methods on Node and Animation in a particular order (namely
            	Node.ResetToInitialState and Animation.Apply). To make this easier and to
            	help track the current time position of animations, the AnimationState object
            	is provided.
            	</para>
            	<para>
            	So if you don't want to control animation application manually, call this method,
            	update the returned object as you like every frame and let SceneManager apply
            	the animation state for you.
            	</para>
            	<para>
            	Remember, AnimationState objects are disabled by default at creation time.
            	Turn them on when you want them using their Enabled property.
            	</para>
            	<para>
            	Note that any SceneNode affected by this automatic animation will have it's state
            	reset to it's initial position before application of the animation. Unless specifically
            	modified using Node.SetInitialState the Node assumes it's initial state is at the
            	origin. If you want the base state of the SceneNode to be elsewhere, make your changes
            	to the node using the standard transform methods, then call SetInitialState to
            	'bake' this reference position into the node.
            	</para>
            </remarks>
            <param name="animationName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateBillboardSet(System.String)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateBillboardSet(System.String,System.Int32)">
            <summary>
            	Creates a billboard set which can be uses for particles, sprites, etc.
            </summary>
            <param name="name"></param>
            <param name="poolSize"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateCamera(System.String)">
            <summary>
            	Creates a camera to be managed by this scene manager.
            </summary>
            <remarks>
            	This camera can be added to the scene at a later time using
            	the AttachObject method of the SceneNode class.
             </remarks>
             <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,System.String)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="meshName">The name of the mesh to load.  Will be loaded if not already.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,Axiom.Core.Mesh)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="mesh">The mesh to use.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,Axiom.Core.PrefabEntity)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="prefab">The name of the mesh to load.  Will be loaded if not already.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateLight(System.String)">
            <summary>
            	Creates a light that will be managed by this scene manager.
            </summary>
            <remarks>
            	Lights can either be in a fixed position and independent of the
            	scene graph, or they can be attached to SceneNodes so they derive
            	their position from the parent node. Either way, they are created
            	using this method so that the SceneManager manages their
            	existence.
            </remarks>
            <param name="name">Name of the light to create.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateMovableText(System.String,System.String,System.String)">
            <summary>
                Create MovableText, 3D floating text which can me moved around your scene
            </summary>
            <param name="name">
                The name to be given to the object (must be unique).
            </param>
            <param name="caption">
            The text tyo display
            </param>
            <param name="fontName">
            The font to use for the text, must be already loaded as a resource.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetMovableText(System.String)">
            <summary>
                Retrieves the named MovableText.
            </summary>
            <param name="name">
                The name of the object to retrieve.
            </param>
            <returns>
                An instance of MovablText.
            </returns>
            <exception cref="T:Axiom.Core.AxiomException">
                Thrown if the names does not exists in the collection.
            </exception>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateManualObject(System.String)">
            <summary>
                Create a ManualObject, an object which you populate with geometry
                manually through a GL immediate-mode style interface.
            </summary>
            <param name="name">
                The name to be given to the object (must be unique).
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetManualObject(System.String)">
            <summary>
                Retrieves the named ManualObject.
            </summary>
            <param name="name">
                The name of the object to retrieve.
            </param>
            <returns>
                An instance of ManualObject.
            </returns>
            <exception cref="T:Axiom.Core.AxiomException">
                Thrown if the names does not exists in the collection.
            </exception>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateOverlay(System.String,System.Int32)">
            <summary>
            	Creates a new Overlay.
            </summary>
            <remarks>
            	<p>
            	Overlays can be used to render heads-up-displays (HUDs), menu systems,
            	cockpits and any other 2D or 3D object you need to appear above the
            	rest of the scene. See the Overlay class for more information.
            	</p>
            	<p>
            	NOTE: after creation, the Overlay is initially hidden. You can create
            	as many overlays as you like ready to be displayed whenever. Just call
            	Overlay.Show to display the overlay.
            	</p>
            </remarks>
            <param name="name">The name to give the overlay, must be unique.</param>
            <param name="zorder">The zorder of the overlay relative to it's peers, higher zorders appear on top of lower ones.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ClearScene">
            <summary>
            	Empties the entire scene, inluding all SceneNodes, Entities, Lights,
            	BillboardSets etc. Cameras are not deleted at this stage since
            	they are still referenced by viewports, which are not destroyed during
            	this process.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroySceneNode(System.String)">
            <summary>
               Destroys and removes a node from the scene.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroySceneNode(Axiom.Core.SceneNode)">
            <summary>
               Destroys and removes a node from the scene.
            </summary>
            <param name="node">A SceneNode</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroySceneNode(Axiom.Core.SceneNode,System.Boolean)">
            <summary>
            Internal method to destroy and remove a node from the scene.
            Do not remove from parent by option.
            </summary>
            <param name="node"></param>
            <param name="removeFromParent"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAnimation(System.String)">
            <summary>
            	Destroys an Animation.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAnimationState(System.String)">
            <summary>
            	Destroys an AnimationState.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllAnimations">
            <summary>
            	Removes all animations created using this SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllAnimationStates">
            <summary>
            	Removes all AnimationStates created using this SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllOverlays">
            <summary>
            	Destroys all the overlays.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyOverlay(System.String)">
            <summary>
            	Destroys the named Overlay.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetCamera(System.String)">
            <summary>
                Retreives the camera with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetLight(System.String)">
            <summary>
                Retreives the light with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetBillboardSet(System.String)">
            <summary>
                Retreives the BillboardSet with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetAnimation(System.String)">
            <summary>
                Retreives the animation with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetAnimationState(System.String)">
            <summary>
                Retreives the AnimationState with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetOverlay(System.String)">
            <summary>
            	Gets a the named Overlay, previously created using CreateOverlay.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetMaterial(System.String)">
            <summary>
                Returns the material with the specified name.
            </summary>
            <param name="name">Name of the material to retrieve.</param>
            <returns>A reference to a Material.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetMaterial(System.UInt64)">
            <summary>
                Returns the material with the specified handle.
            </summary>
            <param name="handle">Handle of the material to retrieve.</param>
            <returns>A reference to a Material.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetRenderQueue">
            <summary>
            	Retrieves the internal render queue.
            </summary>
            <returns>
            	The render queue in use by this scene manager.
            	Note: The queue is created if it doesn't already exist.
            </returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.InitRenderQueue">
            <summary>
            	Internal method for initializing the render queue.
            </summary>
            <remarks>
            	Subclasses can use this to install their own <see cref="T:Axiom.Graphics.RenderQueue"/> implementation.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetSceneNode(System.String)">
            <summary>
                Retreives the scene node with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetEntity(System.String)">
            <summary>
                Retreives the scene node with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetSuggestedViewpoint(System.Boolean)">
            <summary>
                Asks the SceneManager to provide a suggested viewpoint from which the scene should be viewed.
            </summary>
            <remarks>
                Typically this method returns the origin unless a) world geometry has been loaded using
                <see cref="M:Axiom.Core.SceneManager.LoadWorldGeometry(System.String)"/> and b) that world geometry has suggested 'start' points.
                If there is more than one viewpoint which the scene manager can suggest, it will always suggest
                the first one unless the random parameter is true.
            </remarks>
            <param name="random">
                If true, and there is more than one possible suggestion, a random one will be used. If false
                the same one will always be suggested.
            </param>
            <returns>Optimal ViewPoint defined by the scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.LoadWorldGeometry(System.String)">
            <summary>
            	Loads the source of the 'world' geometry, i.e. the large, mainly static geometry
            	making up the world e.g. rooms, landscape etc.
            </summary>
            <remarks>
            	Depending on the type of SceneManager (subclasses will be specialized
            	for particular world geometry types) you have requested via the Root or
            	SceneManagerEnumerator classes, you can pass a filename to this method and it
            	will attempt to load the world-level geometry for use. If you try to load
            	an inappropriate type of world data an exception will be thrown. The default
            	SceneManager cannot handle any sort of world geometry and so will always
            	throw an exception. However subclasses like BspSceneManager can load
            	particular types of world geometry e.g. "q3dm1.bsp".
            </remarks>
            <param name="fileName"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ManualRender(Axiom.Graphics.RenderOperation,Axiom.Graphics.Pass,Axiom.Core.Viewport,Axiom.Math.Matrix4,Axiom.Math.Matrix4,Axiom.Math.Matrix4,System.Boolean)">
            <summary>
            	Manual rendering method, for advanced users only.
            </summary>
            <remarks>
            	This method allows you to send rendering commands through the pipeline on
            	demand, bypassing any normal world processing. You should only use this if you
            	really know what you're doing; the engine does lots of things for you that you really should
            	let it do. However, there are times where it may be useful to have this manual interface,
            	for example overlaying something on top of the scene.
            	<p/>
            	Because this is an instant rendering method, timing is important. The best
            	time to call it is from a RenderTarget event handler.
            	<p/>
            	Don't call this method a lot, it's designed for rare (1 or 2 times per frame) use.
            	Calling it regularly per frame will cause frame rate drops!
            </remarks>
            <param name="op">A RenderOperation object describing the rendering op.</param>
            <param name="pass">The Pass to use for this render.</param>
            <param name="vp">Reference to the viewport to render to.</param>
            <param name="worldMatrix">The transform to apply from object to world space.</param>
            <param name="viewMatrix">The transform to apply from object to view space.</param>
            <param name="projMatrix">The transform to apply from view to screen space.</param>
            <param name="doBeginEndFrame">
            	If true, BeginFrame() and EndFrame() are called, otherwise not.
            	You should leave this as false if you are calling this within the main render loop.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindLightsAffectingFrustum(Axiom.Core.Camera)">
            <summary>
            	Internal method for locating a list of lights which could be affecting the frustum.
            </summary>
            <remarks>
            	Custom scene managers are encouraged to override this method to make use of their
            	scene partitioning scheme to more efficiently locate lights, and to eliminate lights
            	which may be occluded by word geometry.
            </remarks>
            <param name="camera">Camera to find lights within it's view.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindShadowCastersForLight(Axiom.Core.Light,Axiom.Core.Camera)">
            <summary>
            	Internal method for locating a list of shadow casters which
            	could be affecting the frustum for a given light.
            </summary>
            <remarks>
            	Custom scene managers are encouraged to override this method to add optimizations,
            	and to add their own custom shadow casters (perhaps for world geometry)
            </remarks>
            <param name="light"></param>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.InitShadowVolumeMaterials">
            <summary>
            	Internal method for setting up materials for shadows.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DeriveShadowCasterPass(Axiom.Graphics.Pass)">
            <summary>
            	Internal method for turning a regular pass into a shadow caster pass.
            </summary>
            <remarks>
            	This is only used for texture shadows, basically we're trying to
            	ensure that objects are rendered solid black.
            	This method will usually return the standard solid black pass for
            	all fixed function passes, but will merge in a vertex program
            	and fudge the AutpoParamDataSource to set black lighting for
            	passes with vertex programs.
            </remarks>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.DeriveShadowReceiverPass(Axiom.Graphics.Pass)">
            <summary>
            	Internal method for turning a regular pass into a shadow receiver pass.
            </summary>
            <remarks>
            	This is only used for texture shadows, basically we're trying to
            	ensure that objects are rendered with a projective texture.
            	This method will usually return a standard single-texture pass for
            	all fixed function passes, but will merge in a vertex program
            	for passes with vertex programs.
            </remarks>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderShadowVolumesToStencil(Axiom.Core.Light,Axiom.Core.Camera)">
            <summary>
            	Internal method for rendering all the objects for a given light into the stencil buffer.
            </summary>
            <param name="light">The light source.</param>
            <param name="camera">The camera being viewed from.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetShadowVolumeStencilState(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Internal utility method for setting stencil state for rendering shadow volumes.
            </summary>
            <param name="secondPass">Is this the second pass?</param>
            <param name="zfail">Should we be using the zfail method?</param>
            <param name="twoSided">Should we use a 2-sided stencil?</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderSingleShadowVolumeToStencil(Axiom.Graphics.ShadowRenderable,System.Boolean,System.Boolean,Axiom.Core.Collections.LightList,System.Boolean)">
            <summary>
            	Render a single shadow volume to the stencil buffer.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetPass(Axiom.Graphics.Pass,System.Boolean,System.Boolean)">
            <summary>Internal method for setting up the renderstate for a rendering pass.</summary>
            <param name="pass">The Pass details to set.</param>
            <param name="evenIfSuppressed">
               Sets the pass details even if render state
               changes are suppressed; if you are using this to manually set state
               when render state changes are suppressed, you should set this to true.
            </param>
            <param name="shadowDerivation">
               If false, disables the derivation of shadow passes from original passes
            </param>
            <returns>
            	A Pass object that was used instead of the one passed in, can
            	happen when rendering shadow passes
            </returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetPass(Axiom.Graphics.Pass)">
            <summary>
            	If only the first parameter is supplied
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetPass(Axiom.Graphics.Pass,System.Boolean)">
            <summary>
            	If only the first two parameters are supplied
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSkyboxPlane(Axiom.Core.BoxPlane,System.Single,Axiom.Math.Quaternion,System.String)">
            <summary>
            	Utility method for creating the planes of a skybox.
            </summary>
            <param name="plane"></param>
            <param name="distance"></param>
            <param name="orientation"></param>
            <param name="groupName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSkyDomePlane(Axiom.Core.BoxPlane,System.Single,System.Single,System.Single,Axiom.Math.Quaternion,System.String)">
             <summary>
            
             </summary>
             <param name="plane"></param>
             <param name="curvature"></param>
             <param name="tiling"></param>
             <param name="distance"></param>
             <param name="orientation"></param>
             <param name="groupName"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.UseRenderableViewProjection(Axiom.Graphics.IRenderable)">
            <summary>
            	Protected method used by RenderVisibleObjects to deal with renderables
            	which override the camera's own view / projection materices.
            </summary>
            <param name="renderable"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.OnRenderQueueStarted(Axiom.Core.RenderQueueGroupID,System.String)">
            <summary>
            	Used to first the QueueStarted event.
            </summary>
            <returns>True if the queue should be skipped.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.OnRenderQueueEnded(Axiom.Core.RenderQueueGroupID,System.String)">
            <summary>
            	Used to first the QueueEnded event.
            </summary>
            <returns>True if the queue should be repeated.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAABBRegionQuery">
            <summary>
            	Creates a <see cref="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a AxisAlignedBox region.
            </remarks>
            <returns>A specialized implementation of AxisAlignedBoxRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAABBRegionQuery(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a AxisAlignedBox region.
            </remarks>
            <param name="box">AxisAlignedBox to use for the region query.</param>
            <returns>A specialized implementation of AxisAlignedBoxRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAABBRegionQuery(Axiom.Math.AxisAlignedBox,System.UInt32)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a AxisAlignedBox region.
            </remarks>
            <param name="box">AxisAlignedBox to use for the region query.</param>
            <param name="mask">Custom user defined flags to use for the query.</param>
            <returns>A specialized implementation of AxisAlignedBoxRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateRayQuery">
            <summary>
               Creates a query to return objects found along the ray.
            </summary>
            <returns>A specialized implementation of RaySceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateRayQuery(Axiom.Math.Ray)">
            <summary>
               Creates a query to return objects found along the ray.
            </summary>
            <param name="ray">Ray to use for the intersection query.</param>
            <returns>A specialized implementation of RaySceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateRayQuery(Axiom.Math.Ray,System.UInt32)">
            <summary>
               Creates a query to return objects found along the ray.
            </summary>
            <param name="ray">Ray to use for the intersection query.</param>
            <param name="mask"></param>
            <returns>A specialized implementation of RaySceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSphereRegionQuery">
            <summary>
            	Creates a <see cref="T:Axiom.Core.SphereRegionSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a spherical region.
            </remarks>
            <returns>A specialized implementation of SphereRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSphereRegionQuery(Axiom.Math.Sphere)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.SphereRegionSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a spherical region.
            </remarks>
            <param name="sphere">Sphere to use for the region query.</param>
            <returns>A specialized implementation of SphereRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSphereRegionQuery(Axiom.Math.Sphere,System.UInt32)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.SphereRegionSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a spherical region.
            </remarks>
            <param name="sphere">Sphere to use for the region query.</param>
            <param name="mask">Custom user defined flags to use for the query.</param>
            <returns>A specialized implementation of SphereRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreatePlaneBoundedVolumeQuery">
            <summary>
            	Creates a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a PlaneBoundedVolumes region.
            </remarks>
            <returns>A specialized implementation of PlaneBoundedVolumeListSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreatePlaneBoundedVolumeQuery(Axiom.Math.Collections.PlaneBoundedVolumeList)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a PlaneBoundedVolumes region.
            </remarks>
            <param name="volumes">PlaneBoundedVolumeList to use for the region query.</param>
            <returns>A specialized implementation of PlaneBoundedVolumeListSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreatePlaneBoundedVolumeQuery(Axiom.Math.Collections.PlaneBoundedVolumeList,System.UInt32)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/> for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager,
            	for querying for objects within a PlaneBoundedVolumes region.
            </remarks>
            <param name="volumes">PlaneBoundedVolumeList to use for the region query.</param>
            <param name="mask">Custom user defined flags to use for the query.</param>
            <returns>A specialized implementation of PlaneBoundedVolumeListSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateIntersectionQuery">
            <summary>
               Creates an IntersectionSceneQuery for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for locating
            	intersecting objects. See SceneQuery and IntersectionSceneQuery
            	for full details.
            </remarks>
            <returns>A specialized implementation of IntersectionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateIntersectionQuery(System.UInt32)">
            <summary>
               Creates an IntersectionSceneQuery for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for locating
            	intersecting objects. See SceneQuery and IntersectionSceneQuery
            	for full details.
            </remarks>
            <param name="mask">The query mask to apply to this query; can be used to filter out certain objects.</param>
            <returns>A specialized implementation of IntersectionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllCameras">
            <summary>
            	Removes all cameras from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllLights">
            <summary>
            	Removes all lights from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllEntities">
            <summary>
            	Removes all entities from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllBillboardSets">
            <summary>
            	Removes all billboardsets from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveCamera(Axiom.Core.Camera)">
            <summary>
            	Removes the specified camera from the scene.
            </summary>
            <remarks>
            	This method removes a previously added camera from the scene.
            </remarks>
            <param name="camera">Reference to the camera to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveCamera(System.String)">
            <summary>
            	Removes a camera from the scene with the specified name.
            </summary>
            <remarks>
            	This method removes a previously added camera from the scene.
            </remarks>
            <param name="name">Name of the camera to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveLight(Axiom.Core.Light)">
            <summary>
            	Removes the specified light from the scene.
            </summary>
            <remarks>
            	This method removes a previously added light from the scene.
            </remarks>
            <param name="light">Reference to the light to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveLight(System.String)">
            <summary>
            	Removes a light from the scene with the specified name.
            </summary>
            <remarks>
            	This method removes a previously added light from the scene.
            </remarks>
            <param name="name">Name of the light to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveBillboardSet(Axiom.Core.BillboardSet)">
            <summary>
            	Removes the specified BillboardSet from the scene.
            </summary>
            <remarks>
            	This method removes a previously added BillboardSet from the scene.
            </remarks>
            <param name="billboardSet">Reference to the BillboardSet to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveBillboardSet(System.String)">
            <summary>
            	Removes a BillboardSet from the scene with the specified name.
            </summary>
            <remarks>
            	This method removes a previously added BillboardSet from the scene.
            </remarks>
            <param name="name">Name of the BillboardSet to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveEntity(Axiom.Core.Entity)">
            <summary>
               Removes the specified entity from the scene.
            </summary>
            <param name="entity">Entity to remove from the scene.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveEntity(System.String)">
            <summary>
               Removes the entity with the specified name from the scene.
            </summary>
            <param name="name">Entity to remove from the scene.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetFog(Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the fogging mode applied to the scene.
            </summary>
            <remarks>
            	This method sets up the scene-wide fogging effect. These settings
            	apply to all geometry rendered, UNLESS the material with which it
            	is rendered has it's own fog settings (see Material.SetFog).
            </remarks>
            <param name="mode">Set up the mode of fog as described in the FogMode
            	enum, or set to FogMode.None to turn off.</param>
            <param name="color">The color of the fog. Either set this to the same
            	as your viewport background color, or to blend in with a skydome or skybox.</param>
            <param name="density">The density of the fog in Exp or Exp2.
            	mode, as a value between 0 and 1. The default is 0.001. </param>
            <param name="linearStart">Distance in world units at which linear fog starts to
            	encroach. Only applicable if mode is</param>
            <param name="linearEnd">Distance in world units at which linear fog becomes completely
            	opaque. Only applicable if mode is</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetFog(Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single)">
             <summary>
            
             </summary>
             <param name="mode"></param>
             <param name="color"></param>
             <param name="density"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="enable"></param>
            <param name="materialName"></param>
            <param name="distance"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single,System.Boolean,Axiom.Math.Quaternion,System.String)">
             <summary>
            		Enables / disables a 'sky box' i.e. a 6-sided box at constant
            		distance from the camera representing the sky.
             </summary>
             <remarks>
            		You could create a sky box yourself using the standard mesh and
            		entity methods, but this creates a plane which the camera can
            		never get closer or further away from - it moves with the camera.
            		(you could create this effect by creating a world box which
            		was attached to the same SceneNode as the Camera too, but this
            		would only apply to a single camera whereas this skybox applies
            		to any camera using this scene manager).
            		<p/>
            		The material you use for the skybox can either contain layers
            		which are single textures, or they can be cubic textures, i.e.
            		made up of 6 images, one for each plane of the cube. See the
            		TextureLayer class for more information.
             </remarks>
             <param name="enable">True to enable the skybox, false to disable it</param>
             <param name="materialName">The name of the material the box will use.</param>
             <param name="distance">Distance in world coordinates from the camera to each plane of the box. </param>
             <param name="drawFirst">
            		If true, the box is drawn before all other
            		geometry in the scene, without updating the depth buffer.
            		This is the safest rendering method since all other objects
            		will always appear in front of the sky. However this is not
            		the most efficient way if most of the sky is often occluded
            		by other objects. If this is the case, you can set this
            		parameter to false meaning it draws <em>after</em> all other
            		geometry which can be an optimisation - however you must
            		ensure that the distance value is large enough that no
            		objects will 'poke through' the sky box when it is rendered.
             </param>
             <param name="orientation">
            		Specifies the orientation of the box. By default the 'top' of the box is deemed to be
            		in the +y direction, and the 'front' at the -z direction.
            		You can use this parameter to rotate the sky if you want.
             </param>
            <param name="groupName"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single)">
             <summary>
            
             </summary>
             <param name="isEnabled"></param>
             <param name="materialName"></param>
             <param name="curvature"></param>
             <param name="tiling"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Axiom.Math.Quaternion,System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetShadowTextureSettings(System.UInt16,System.UInt16,Axiom.Media.PixelFormat)">
            <summary>
            	Sets the size and count of textures used in texture-based shadows.
            </summary>
            <remarks>
            	See ShadowTextureSize and ShadowTextureCount for details, this
            	method just allows you to change both at once, which can save on
            	reallocation if the textures have already been created.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneManager._defaultShadowCameraSetup">
            <summary>
            the default shadow camera setup used for all lights which don't have
            their own shadow camera setup.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.NotifyLightsDirty">
            <summary>
            Advance method to increase the lights dirty counter due lights changed.
            </summary>
            <remarks>
            Scene manager tracking lights that affecting the frustum, if changes
            detected (the changes includes light list itself and the light's position
            and attenuation range), then increase the lights dirty counter.
            <para />
            For some reason, you can call this method to force whole scene objects
            re-populate their light list. But near in mind, call to this method
            will harm performance, so should avoid if possible.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderScene(Axiom.Core.Camera,Axiom.Core.Viewport,System.Boolean)">
            <summary>
            	Prompts the class to send its contents to the renderer.
            </summary>
            <remarks>
            	This method prompts the scene manager to send the
            	contents of the scene it manages to the rendering
            	pipeline, possibly preceded by some sorting, culling
            	or other scene management tasks. Note that this method is not normally called
            	directly by the user application; it is called automatically
            	by the engine's rendering loop.
            </remarks>
            <param name="camera">Pointer to a camera from whose viewpoint the scene is to be rendered.</param>
            <param name="viewport">The target viewport</param>
            <param name="showOverlays">Whether or not any overlay objects should be rendered</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.UpdateSceneGraph(Axiom.Core.Camera)">
            <summary>
            	Internal method for updating the scene graph ie the tree of SceneNode instances managed by this class.
            </summary>
            <remarks>
            	This must be done before issuing objects to the rendering pipeline, since derived transformations from
            	parent nodes are not updated until required. This SceneManager is a basic implementation which simply
            	updates all nodes from the root. This ensures the scene is up to date but requires all the nodes
            	to be updated even if they are not visible. Subclasses could trim this such that only potentially visible
            	nodes are updated.
            </remarks>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindVisibleObjects(Axiom.Core.Camera,System.Boolean)">
            <summary>
            	Internal method which parses the scene to find visible objects to render.
            </summary>
            <remarks>
            	If you're implementing a custom scene manager, this is the most important method to
            	override since it's here you can apply your custom world partitioning scheme. Once you
            	have added the appropriate objects to the render queue, you can let the default
            	SceneManager objects RenderVisibleObjects handle the actual rendering of the objects
            	you pick.
            	<p/>
            	Any visible objects will be added to a rendering queue, which is indexed by material in order
            	to ensure objects with the same material are rendered together to minimise render state changes.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.ApplySceneAnimations">
            <summary>
            	Internal method for applying animations to scene nodes.
            </summary>
            <remarks>
            	Uses the internally stored AnimationState objects to apply animation to SceneNodes.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllCameras">
            <summary>
                Destroy all cameras managed by this SceneManager
            <remarks>
                Method added with MovableObject Factories.
            </remarks>
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateShadowTextures(System.UInt16,System.UInt16,Axiom.Media.PixelFormat)">
            <summary>
            Internal method for creating shadow textures (texture-based shadows).
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.PrepareShadowTextures(Axiom.Core.Camera,Axiom.Core.Viewport)">
            <summary>
            Internal method for preparing shadow textures ready for use in a regular render
            </summary>
            <param name="camera"></param>
            <param name="viewPort"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetViewport(Axiom.Core.Viewport)">
            <summary>
            	Internal method for setting the destination viewport for the next render.
            </summary>
            <param name="viewport"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderSingleObject(Axiom.Graphics.IRenderable,Axiom.Graphics.Pass,System.Boolean,Axiom.Core.Collections.LightList)">
            <summary>
            	Internal utility method for rendering a single object.
            </summary>
            <param name="renderable">The renderable to issue to the pipeline.</param>
            <param name="pass">The pass which is being used.</param>
            <param name="doLightIteration">If true, this method will issue the renderable to
            the pipeline possibly multiple times, if the pass indicates it should be
            done once per light.</param>
            <param name="manualLightList">Only applicable if 'doLightIteration' is false, this
            method allows you to pass in a previously determined set of lights
            which will be used for a single render of this object.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderSolidObjects(System.Collections.SortedList,System.Boolean,Axiom.Core.Collections.LightList)">
            <summary>
            	Renders a set of solid objects.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTransparentObjects(System.Collections.Generic.List{Axiom.Graphics.RenderablePass},System.Boolean,Axiom.Core.Collections.LightList)">
            <summary>
            	Renders a set of transparent objects.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderAdditiveStencilShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of additive stencil shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderModulativeStencilShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of modulative stencil shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTextureShadowCasterQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group rendering only shadow casters.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderModulativeTextureShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of modulative texture shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderAdditiveTextureShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of additive texture shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTextureShadowReceiverQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group rendering only shadow receivers.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ValidatePassForRendering(Axiom.Graphics.Pass)">
            <summary>
            	Internal method to validate whether a Pass should be allowed to render.
            </summary>
            <remarks>
            	Called just before a pass is about to be used for rendering a group to
            	allow the SceneManager to omit it if required. A return value of false
            	skips this pass.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.ValidateRenderableForRendering(Axiom.Graphics.Pass,Axiom.Graphics.IRenderable)">
            <summary>
            	Internal method to validate whether a Renderable should be allowed to render.
            </summary>
            <remarks>
            	Called just before a pass is about to be used for rendering a Renderable to
            	allow the SceneManager to omit it if required. A return value of false
            	skips it.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render the objects in a given queue group.
            </summary>
            <param name="group">Group containing the objects to render.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderBasicQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group in the ordinary way
            </summary>
            <param name="group">Group containing the objects to render.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTransparentShadowCasterObjects(System.Collections.Generic.List{Axiom.Graphics.RenderablePass},System.Boolean,Axiom.Core.Collections.LightList)">
            <summary>
            	Render those objects in the transparent pass list which have shadow casting forced on
            </summary>
            <remarks>
            	This function is intended to be used to render the shadows of transparent objects which have
            	transparency_casts_shadows set to 'on' in their material
            </remarks>
            <param name="list"></param>
            <param name="doLightIteration"></param>
            <param name="manualLightList"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderVisibleObjects">
            <summary>
            	Sends visible objects found in <see cref="M:Axiom.Core.SceneManager.FindVisibleObjects(Axiom.Core.Camera,System.Boolean)"/> to the rendering engine.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.QueueSkiesForRendering(Axiom.Core.Camera)">
            <summary>
            	Internal method for queueing the sky objects with the params as
            	previously set through SetSkyBox, SetSkyPlane and SetSkyDome.
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.PopulateLightList(Axiom.Math.Vector3,System.Single,Axiom.Core.Collections.LightList)">
            <summary>
            	Populate a light list with an ordered set of the lights which are closest
            </summary>
            <remarks>
            	<p>
            	Note that since directional lights have no position, they are always considered
            	closer than any point lights and as such will always take precedence.
            	</p>
            	<p>
            	Subclasses of the default SceneManager may wish to take into account other issues
            	such as possible visibility of the light if that information is included in their
            	data structures. This basic scenemanager simply orders by distance, eliminating
            	those lights which are out of range.
            	</p>
            	<p>
            	The number of items in the list max exceed the maximum number of lights supported
            	by the renderer, but the extraneous ones will never be used. In fact the limit will
            	be imposed by Pass::getMaxSimultaneousLights.
            	</p>
            </remarks>
            <param name="position">The position at which to evaluate the list of lights</param>
            <param name="radius">The bounding radius to test</param>
            <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyPlane(System.Boolean,Axiom.Math.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single,System.String)">
            <summary>
            	Enables / disables a 'sky plane' i.e. a plane at constant
            	distance from the camera representing the sky.
            </summary>
            <param name="enable">True to enable the plane, false to disable it.</param>
            <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera.</param>
            <param name="materialName">The name of the material the plane will use.</param>
            <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane.</param>
            <param name="tiling">How many times to tile the texture across the sky.</param>
            <param name="drawFirst">
            	If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer.
            	This is the safest rendering method since all other objects
            	will always appear in front of the sky. However this is not
            	the most efficient way if most of the sky is often occluded
            	by other objects. If this is the case, you can set this
            	parameter to false meaning it draws <em>after</em> all other
            	geometry which can be an optimisation - however you must
            	ensure that the plane.d value is large enough that no objects
            	will 'poke through' the sky plane when it is rendered.
             </param>
            <param name="bow">
            	If above zero, the plane will be curved, allowing
            	the sky to appear below camera level.  Curved sky planes are
            	simular to skydomes, but are more compatable with fog.
            </param>
            <param name="groupName"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyPlane(System.Boolean,Axiom.Math.Plane,System.String)">
            <summary>
            	Overload.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.NotifyAutoTrackingSceneNode(Axiom.Core.SceneNode,System.Boolean)">
            <summary>
            	Internal method for notifying the manager that a SceneNode is autotracking.
            </summary>
            <param name="node">Scene node that is auto tracking another scene node.</param>
            <param name="autoTrack">True if tracking, false if it is stopping tracking.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.OverrideRootSceneNode(Axiom.Core.SceneNode)">
             <summary>
             If set, only the selected node is rendered.
             To render all nodes, set to null.
             </summary>
            
        </member>
        <member name="M:Axiom.Core.SceneManager.InjectRenderWithPass(Axiom.Graphics.Pass,Axiom.Graphics.IRenderable,System.Boolean)">
             <summary>
                 Render something as if it came from the current queue.
             </summary>
            <param name="pass">Material pass to use for setting up this quad.</param>
            <param name="rend">Renderable to render</param>
            <param name="shadowDerivation">Whether passes should be replaced with shadow caster / receiver passes</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateStaticGeometry(System.String,System.Int32)">
            <summary>
                Creates a StaticGeometry instance suitable for use with this
                SceneManager.
            </summary>
            <remarks>
                StaticGeometry is a way of batching up geometry into a more
                efficient form at the expense of being able to move it. Please
                read the StaticGeometry class documentation for full information.
            </remarks>
            <param name="name">The name to give the new object</param>
            <param name="logLevel"></param>
            <returns>The new StaticGeometry instance</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetStaticGeometry(System.String)">
            <summary>
                Retrieve a previously created StaticGeometry instance.
            </summary>
            <note>
                Throws an exception if the named instance does not exist
            </note>
        </member>
        <member name="M:Axiom.Core.SceneManager.HasStaticGeometry(System.String)">
            <summary>
                Returns whether a static geometry instance with the given name exists. */
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyStaticGeometry(Axiom.Core.StaticGeometry)">
            <summary>
                Remove &amp; destroy a StaticGeometry instance.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyStaticGeometry(System.String)">
            <summary>
                Remove &amp; destroy a StaticGeometry instance.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllStaticGeometry">
            <summary>
                Destroy all StaticGeometry instances.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.EstimateWorldGeometry(System.String)">
            <summary>
            Estimate the number of loading stages required to load the named
            world geometry.
            </summary>
            <remarks>
            This method should be overridden by SceneManagers that provide
            custom world geometry that can take some time to load. They should
            return from this method a count of the number of stages of progress
            they can report on whilst loading. During real loading (setWorldGeomtry),
            they should call <see name="ResourceGroupManager.notifyWorlGeometryProgress"/> exactly
            that number of times when loading the geometry for real.
            </remarks>
            <param name="fileName">Name of the file.</param>
            <returns>
            The default is to return 0, ie to not report progress.
            </returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.EstimateWorldGeometry(System.IO.Stream)">
            <summary>
            Estimate the number of loading stages required to load the named world geometry.
            </summary>
            <remarks>
            Operates just like the version of this method which takes a
            filename, but operates on a stream instead. Note that since the
            stream is updated, you'll need to reset the stream or reopen it
            when it comes to loading it for real.
            </remarks>
            <param name="stream">Data stream containing data to load</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.EstimateWorldGeometry(System.IO.Stream,System.String)">
            <summary>
            Estimates the world geometry.
            </summary>
            <remarks>
            Operates just like the version of this method which takes a
            filename, but operates on a stream instead. Note that since the
            stream is updated, you'll need to reset the stream or reopen it
            when it comes to loading it for real.
            </remarks>
            <param name="stream">Data stream containing data to load</param>
            <param name="typeName">Identifies the type of world geometry
            contained in the stream - not required if this manager only
            supports one type of world geometry.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.PrepareWorldGeometry(System.String)">
            <summary>
            Sets the source of the 'world' geometry, i.e. the large, mainly static geometry
            making up the world e.g. rooms, landscape etc.
            This function can be called before setWorldGeometry in a background thread, do to
            some slow tasks (e.g. IO) that do not involve the backend render system.
            </summary>
            <remarks>
            Depending on the type of SceneManager (subclasses will be specialised
            for particular world geometry types) you have requested via the Root or
            SceneManagerEnumerator classes, you can pass a filename to this method and it
            will attempt to load the world-level geometry for use. If you try to load
            an inappropriate type of world data an exception will be thrown. The default
            SceneManager cannot handle any sort of world geometry and so will always
            throw an exception. However subclasses like BspSceneManager can load
            particular types of world geometry e.g. "q3dm1.bsp".
            </remarks>
            <param name="filename"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.PrepareWorldGeometry(System.IO.Stream,System.String)">
            <summary>
            Sets the source of the 'world' geometry, i.e. the large, mainly static geometry
            making up the world e.g. rooms, landscape etc.
            This function can be called before setWorldGeometry in a background thread, do to
            some slow tasks (e.g. IO) that do not involve the backend render system.
            </summary>
            <remarks>
            Depending on the type of SceneManager (subclasses will be 
            specialised for particular world geometry types) you have 
            requested via the Root or SceneManagerEnumerator classes, you 
            can pass a stream to this method and it will attempt to load 
            the world-level geometry for use. If the manager can only 
            handle one input format the typeName parameter is not required.
            The stream passed will be read (and it's state updated). 
            </remarks>
            <param name="stream">Data stream containing data to load</param>
            <param name="typeName">String identifying the type of world geometry
            contained in the stream - not required if this manager only 
            supports one type of world geometry.
            </param>
        </member>
        <member name="P:Axiom.Core.SceneManager.IsLateMaterialResolving">
            <summary>
            If set, materials will be resolved from the materials at the
            pass-setting stage and not at the render queue building stage.
            This is useful when the active material scheme during the render
            queue building stage is different from the one during the rendering stage.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.Lights">
            <summary>A list of lights in the scene for easy lookup.</summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.IsShadowTechniqueStencilBased">
            <summary>
            	If true, the shadow technique is based on texture maps
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.IsShadowTechniqueTextureBased">
            <summary>
            	If true, the shadow technique is based on texture maps
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.IsShadowTechniqueAdditive">
            <summary>
            	If true, the shadow technique is additive
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.IsShadowTechniqueModulative">
            <summary>
            	If true, the shadow technique is modulative
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.IsShadowTechniqueInUse">
            <summary>
            	Is the shadow technique is not "None"
            </summary>
        </member>
        <member name="E:Axiom.Core.SceneManager.QueueStarted">
            <summary>
            Fired when a render queue is starting to be rendered.
            </summary>
        </member>
        <member name="E:Axiom.Core.SceneManager.QueueEnded">
            <summary>
            Fired when a render queue is finished being rendered.
            </summary>
        </member>
        <member name="E:Axiom.Core.SceneManager.PreFindVisibleObjects">
            <summary>Will fire before FindVisibleObjects is called</summary>
        </member>
        <member name="E:Axiom.Core.SceneManager.PostFindVisibleObjects">
            <summary>Will fire after FindVisibleObjects is called</summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ActiveCompositorChain">
            <summary>
            Sets the active compositor chain of the current scene being rendered.
            </summary>
            <note>
            CompositorChain does this automatically, no need to call manually.
            </note>
        </member>
        <member name="P:Axiom.Core.SceneManager.TargetRenderSystem">
            <summary>
            Gets/Sets the target render system that this scene manager should be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.RootSceneNode">
            <summary>
            	Gets the SceneNode at the root of the scene hierarchy.
            </summary>
            <remarks>
            	The entire scene is held as a hierarchy of nodes, which
            	allows things like relative transforms, general changes in
            	rendering state etc (See the SceneNode class for more info).
            	In this basic SceneManager class, you are free to
            	structure this hierarchy however you like, since
            	it has no real significance apart from making transforms
            	relative to each node (more specialised subclasses will
            	provide utility methods for building specific node structures
            	e.g. loading a BSP tree).
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.AmbientLight">
            <summary>
            	Gets/Sets the ambient light level to be used for the scene.
            </summary>
            <remarks>
            	This sets the color and intensity of the ambient light in the scene, i.e. the
            	light which is 'sourceless' and illuminates all objects equally.
            	The color of an object is affected by a combination of the light in the scene,
            	and the amount of light that object reflects (in this case based on the Material.Ambient
            	property).
            	<p/>
            	By default the ambient light in the scene is Black, i.e. no ambient light. This
            	means that any objects rendered with a Material which has lighting enabled
            	(see Material.LightingEnabled) will not be visible unless you have some dynamic lights in your scene.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.Options">
            <summary>
            	Method for setting a specific option of the Scene Manager. These options are usually
            	specific for a certain implementation of the Scene Manager class, and may (and probably
            	will) not exist across different implementations.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowCameraSetup">
            <summary>
            Get/Set the shadow camera setup in use for all lights which don't have
            their own shadow camera setup.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowColor">
            <summary>
            	Gets/Sets the color used to modulate areas in shadow.
            </summary>
            <remarks>
            	This is only applicable for shadow techniques which involve
            	darkening the area in shadow, as opposed to masking out the light.
            	This color provided is used as a modulative value to darken the
            	areas.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowDirectionalLightExtrusionDistance">
            <summary>
            	Sets the distance a shadow volume is extruded for a directional light.
            </summary>
            <remarks>
            	Although directional lights are essentially infinite, there are many
            	reasons to limit the shadow extrusion distance to a finite number,
            	not least of which is compatibility with older cards (which do not
            	support infinite positions), and shadow caster elimination.
            	<p/>
            	The default value is 10,000 world units. This does not apply to
            	point lights or spotlights, since they extrude up to their
            	attenuation range.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowDirectionalLightTextureOffset">
            <summary>
            Gets the proportional distance which a texture shadow which is generated from a
            directional light will be offset into the camera view to make best use of texture space.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowFarDistance">
            <summary>
            	Sets the maximum distance away from the camera that shadows will be visible.
            </summary>
            <remarks>
            	Shadow techniques can be expensive, therefore it is a good idea
            	to limit them to being rendered close to the camera if possible,
            	and to skip the expense of rendering shadows for distance objects.
            	This method allows you to set the distance at which shadows will no
            	longer be rendered.
            	Note:
            	Each shadow technique can interpret this subtely differently.
            	For example, one technique may use this to eliminate casters,
            	another might use it to attenuate the shadows themselves.
            	You should tweak this value to suit your chosen shadow technique
            	and scene setup.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowIndexBufferSize">
            <summary>
            	Sets the maximum size of the index buffer used to render shadow primitives.
            </summary>
            <remarks>
            	This property allows you to tweak the size of the index buffer used
            	to render shadow primitives (including stencil shadow volumes). The
            	default size is 51,200 entries, which is 100k of GPU memory, or
            	enough to render approximately 17,000 triangles. You can reduce this
            	as long as you do not have any models / world geometry chunks which
            	could require more than the amount you set.
            	<p/>
            	The maximum number of triangles required to render a single shadow
            	volume (including light and dark caps when needed) will be 3x the
            	number of edges on the light silhouette, plus the number of
            	light-facing triangles.	On average, half the
            	triangles will be facing toward the light, but the number of
            	triangles in the silhouette entirely depends on the mesh -
            	angular meshes will have a higher silhouette tris/mesh tris
            	ratio than a smooth mesh. You can estimate the requirements for
            	your particular mesh by rendering it alone in a scene with shadows
            	enabled and a single light - rotate it or the light and make a note
            	of how high the triangle count goes (remembering to subtract the
            	mesh triangle count)
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTextureSize">
            <summary>
            	Set the size of the texture used for texture-based shadows.
            </summary>
            <remarks>
            	The larger the shadow texture, the better the detail on
            	texture based shadows, but obviously this takes more memory.
            	The default size is 512. Sizes must be a power of 2.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTextureCount">
            <summary>
            	Set the number of textures allocated for texture-based shadows.
            </summary>
            <remarks>
            	The default number of textures assigned to deal with texture based
            	shadows is 1; however this means you can only have one light casting
            	shadows at the same time. You can increase this number in order to
            	make this more flexible, but be aware of the texture memory it will use.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTextureSelfShadow">
            <summary>
            	Determines whether we're supporting self-shadowing
            </summary>
            <remarks>
            	The default number of textures assigned to deal with texture based
            	shadows is 1; however this means you can only have one light casting
            	shadows at the same time. You can increase this number in order to
            	make this more flexible, but be aware of the texture memory it will use.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTechnique">
            <summary>
            	Sets the general shadow technique to be used in this scene.
            </summary>
            <remarks>
            	There are multiple ways to generate shadows in a scene, and each has
            	strengths and weaknesses.
            	<ul><li>Stencil-based approaches can be used to
            	draw very long, extreme shadows without loss of precision and the 'additive'
            	version can correctly show the shadowing of complex effects like bump mapping
            	because they physically exclude the light from those areas. However, the edges
            	are very sharp and stencils cannot handle transparency, and they involve a
            	fair amount of CPU work in order to calculate the shadow volumes, especially
            	when animated objects are involved.</li>
            	<li>Texture-based approaches are good for handling transparency (they can, for
            	example, correctly shadow a mesh which uses alpha to represent holes), and they
            	require little CPU overhead, and can happily shadow geometry which is deformed
            	by a vertex program, unlike stencil shadows. However, they have a fixed precision
            	which can introduce 'jaggies' at long range and have fillrate issues of their own.</li>
            	</ul>
            	<p/>
            	We support 2 kinds of stencil shadows, and 2 kinds of texture-based shadows, and one
            	simple decal approach. The 2 stencil approaches differ in the amount of multipass work
            	that is required - the modulative approach simply 'darkens' areas in shadow after the
            	main render, which is the least expensive, whilst the additive approach has to perform
            	a render per light and adds the cumulative effect, whcih is more expensive but more
            	accurate. The texture based shadows both work in roughly the same way, the only difference is
            	that the shadowmap approach is slightly more accurate, but requires a more recent
            	graphics card.
            	<p/>
            	Note that because mixing many shadow techniques can cause problems, only one technique
            	is supported at once. Also, you should call this method at the start of the
            	scene setup.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowUseInfiniteFarPlane">
            <summary>
            	Sets whether we should use an inifinite camera far plane
            	when rendering stencil shadows.
            </summary>
            <remarks>
            	Stencil shadow coherency is very reliant on the shadow volume
            	not being clipped by the far plane. If this clipping happens, you
            	get a kind of 'negative' shadow effect. The best way to achieve
            	coherency is to move the far plane of the camera out to infinity,
            	thus preventing the far plane from clipping the shadow volumes.
            	When combined with vertex program extrusion of the volume to
            	infinity, which	Axiom does when available, this results in very
            	robust shadow volumes. For this reason, when you enable stencil
            	shadows, Ogre automatically changes your camera settings to
            	project to infinity if the card supports it. You can disable this
            	behavior if you like by setting this property; although you can
            	never enable infinite projection if the card does not support it.
            	<p/>
            	If you disable infinite projection, or it is not available,
            	you need to be far more careful with your light attenuation /
            	directional light extrusion distances to avoid clipping artefacts
            	at the far plane.
            	<p/>
            	Recent cards will generally support infinite far plane projection.
            	However, we have found some cases where they do not, especially
            	on Direct3D. There is no standard capability we can check to
            	validate this, so we use some heuristics based on experience:
            	<UL>
            	<LI>OpenGL always seems to support it no matter what the card</LI>
            	<LI>Direct3D on non-vertex program capable systems (including
            	vertex program capable cards on Direct3D7) does not
            	support it</LI>
            	<LI>Direct3D on GeForce3 and GeForce4 Ti does not seem to support
            	infinite projection</LI>
            	</UL>
            	Therefore in the RenderSystem implementation, we may veto the use
            	of an infinite far plane based on these heuristics.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShowBoundingBoxes">
            <summary>
            	Gets/Sets a value that forces all nodes to render their bounding boxes.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShowDebugShadows">
            <summary>
            	Gets/Sets a flag that indicates whether debug shadow info (i.e. visible volumes)
            	will be displayed.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.DisplayNodes">
            <summary>
            	Gets/Sets whether or not to display the nodes themselves in addition to their objects.
            </summary>
            <remarks>
            	What will be displayed is the local axes of the node (for debugging mainly).
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogMode">
            <summary>
            	Gets the fog mode that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogStart">
            <summary>
            	Gets the fog starting point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogEnd">
            <summary>
            	Gets the fog ending point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogDensity">
            <summary>
            	Gets the fog density that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogColor">
            <summary>
            	Gets the fog color that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.DefaultMaterialSettings">
            <summary>
            	Returns a pointer to the default Material settings.
            </summary>
            <remarks>
            	<p>
            	Axiom comes configured with a set of defaults for newly created
            	materials. If you wish to have a different set of defaults,
            	simply call this method and change the returned Material's
            	settings. All materials created from then on will be configured
            	with the new defaults you have specified.
            	</p>
            	<p>
            	The default settings begin as a single Technique with a single, non-programmable Pass:
                <ul>
                <li>ambient = ColourEx.White</li>
                <li>diffuse = ColourEx.White</li>
                <li>specular = ColourEx.Black</li>
                <li>emmissive = ColourEx.Black</li>
                <li>shininess = 0</li>
                <li>No texture unit settings (&amp; hence no textures)</li>
                <li>SourceBlendFactor = SBF_ONE</li>
                <li>DestBlendFactor = SBF_ZERO (no blend, replace with new colour)</li>
                <li>Depth buffer checking on</li>
                <li>Depth buffer writing on</li>
                <li>Depth buffer comparison function = CMPF_LESS_EQUAL</li>
                <li>Colour buffer writing on for all channels</li>
                <li>Culling mode = CULL_CLOCKWISE</li>
                <li>Ambient lighting = ColourValue(0.5, 0.5, 0.5) (mid-grey)</li>
                <li>Dynamic lighting enabled</li>
                <li>Gourad shading mode</li>
                <li>Bilinear texture filtering</li>
                </ul>
            	</p>
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.CurrentViewport">
            <summary>
            	Gets the current viewport - - needed by compositor
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.VisibilityMask">
            <summary>
            	Gets and sets the object visibility mask
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.CombinedVisibilityMask">
            <summary>
            	Gets ths combined object visibility mask of this scenemanager and the current viewport
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FindVisibleObjectsBool">
            <summary>
            	Gets and sets the object visibility mask
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.Name">
            <summary>
            	Gets the instance name of this SceneManager.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.TypeName">
             <summary>
            		Retrieves the type name of this scene manager.
             </summary>
             <remarks>
            		This method has to be implemented by subclasses. It should
            		return the type name of this SceneManager which agrees with
            		the type name of the SceneManagerFactory which created it.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.LightsDirtyCounter">
            <summary>
            Gets the lights dirty counter.
            </summary>
            <remarks>
            Scene manager tracking lights that affecting the frustum, if changes
            detected (the changes includes light list itself and the light's position
            and attenuation range), then increase the lights dirty counter.
            <para/>
            When implementing customise lights finding algorithm relied on either
            <see cref="F:Axiom.Core.SceneManager.lightsAffectingFrustum"/> or <see cref="M:Axiom.Core.SceneManager.PopulateLightList(Axiom.Math.Vector3,System.Single,Axiom.Core.Collections.LightList)"/>,
            might check this value for sure that the light list are really need to
            re-populate, otherwise, returns cached light list (if exists) for better
            performance.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneManager.ShadowCasterSceneQueryListener">
            <summary>
            	Nested class to use as a callback for shadow caster scene query.
            </summary>
        </member>
        <member name="T:Axiom.Core.ISceneQueryListener">
            <summary>
            	This optional class allows you to receive per-result callbacks from
            	SceneQuery executions instead of a single set of consolidated results.
            </summary>
        </member>
        <member name="M:Axiom.Core.ISceneQueryListener.OnQueryResult(Axiom.Core.MovableObject)">
            <summary>
            	Called when a <see name="SceneObject"/> is returned by a query.
            </summary>
            <remarks>
            	The implementor should return 'true' to continue returning objects,
            	or 'false' to abandon any further results from this query.
            </remarks>
            <param name="sceneObject">Object found by the query.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ISceneQueryListener.OnQueryResult(Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            	Called when a <see cref="T:Axiom.Core.SceneQuery.WorldFragment"/> is returned by a query.
            </summary>
            <param name="fragment">Fragment found by the query.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.ShadowCasterSceneQueryListener.Prepare(System.Boolean,Axiom.Math.Collections.PlaneBoundedVolumeList,Axiom.Core.Light,Axiom.Core.Camera,System.Collections.Generic.List{Axiom.Graphics.ShadowCaster},System.Single)">
            <summary>
            	Prepare the listener for use with a set of parameters.
            </summary>
            <param name="lightInFrustum"></param>
            <param name="lightClipVolumes"></param>
            <param name="light"></param>
            <param name="camera"></param>
            <param name="shadowCasterList"></param>
            <param name="farDistSquared"></param>
        </member>
        <member name="T:Axiom.Core.DefaultAxisAlignedBoxRegionSceneQuery">
            <summary>
            	Default implementation of a AxisAlignedBoxRegionSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying items within an AxisAlignedBox.
            </summary>
        </member>
        <member name="T:Axiom.Core.RegionSceneQuery">
            <summary>
            	Abstract class defining a query which returns single results from within a region.
            </summary>
            <remarks>
            	This class is simply a generalization of the subtypes of query that return
            	a set of individual results in a region. See the <see cref="T:Axiom.Core.SceneQuery"/> class for
            	abstract information, and subclasses for the detail of each query type.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneQuery">
            <summary>
            	A class for performing queries on a scene.
            </summary>
            <remarks>
            	This is an abstract class for performing a query on a scene, i.e. to retrieve
            	a list of objects and/or world geometry sections which are potentially intersecting a
            	given region. Note the use of the word 'potentially': the results of a scene query
            	are generated based on bounding volumes, and as such are not correct at a triangle
            	level; the user of the SceneQuery is expected to filter the results further if
            	greater accuracy is required.
            	<p/>
            	Different SceneManagers will implement these queries in different ways to
            	exploit their particular scene organization, and thus will provide their own
            	concrete subclasses. In fact, these subclasses will be derived from subclasses
            	of this class rather than directly because there will be region-type classes
            	in between.
            	<p/>
            	These queries could have just been implemented as methods on the SceneManager,
            	however, they are wrapped up as objects to allow 'compilation' of queries
            	if deemed appropriate by the implementation; i.e. each concrete subclass may
            	precalculate information (such as fixed scene partitions involved in the query)
            	to speed up the repeated use of the query.
            	<p/>
            	You should never try to create a SceneQuery object yourself, they should be created
            	using the SceneManager interfaces for the type of query required, e.g.
            	SceneManager.CreateRaySceneQuery.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneQuery.creator">
            <summary>
            	Reference to the SceneManager that this query was created by.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.queryMask">
            <summary>
            	User definable query bit mask which can be used to filter the results of a query.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.queryTypeMask">
            <summary>
            	query bit mask which can be used to filter the results of a query based on object type.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.worldFragmentTypes">
            <summary>
            	A flag enum which holds the world fragment types supported by this query.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Internal constructor.
            </summary>
            <param name="creator">Reference to the scene manager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.SceneQuery.AddWorldFragmentType(Axiom.Core.WorldFragmentType)">
            <summary>
            	Used to add a supported world fragment type to this query.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneQuery.QueryMask">
            <summary>
               Sets the mask for results of this query.
            </summary>
            <remarks>
               This property allows you to set a 'mask' to limit the results of this
               query to certain types of result. The actual meaning of this value is
               up to the application; basically SceneObject instances will only be returned
               from this query if a bitwise AND operation between this mask value and the
               SceneObject.QueryFlags value is non-zero. The application will
               have to decide what each of the bits means.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneQuery.QueryTypeMask">
            <summary>
               Sets the mask for results of this query.
            </summary>
            <remarks>
               This property allows you to set a 'mask' to limit the results of this
               query to certain types of result.  Whilst setQueryMask deals with flags
               set per instance of object, this method deals with setting a mask on
               flags set per type of object. Both may exclude an object from query
               results.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneQuery.WorldFragment">
            <summary>
            	Represents part of the world geometry that is a result of a <see cref="T:Axiom.Core.SceneQuery"/>.
            </summary>
            <remarks>
            	Since world geometry is normally vast and sprawling, we need a way of
            	retrieving parts of it based on a query. That is what this struct is for;
            	note there are potentially as many data structures for world geometry as there
            	are SceneManagers, however this structure includes a few common abstractions as
            	well as a more general format.
            	<p/>
            	The type of world fragment that is returned from a query depends on the
            	SceneManager, and the fragment types are supported on the query.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.FragmentType">
            <summary>
            	The type of this world fragment.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.SingleIntersection">
            <summary>
            	Single intersection point, only applicable for <see cref="F:Axiom.Core.WorldFragmentType.SingleIntersection"/>.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.Planes">
            <summary>
            	Planes bounding a convex region, only applicable for <see cref="F:Axiom.Core.WorldFragmentType.PlaneBoundedRegion"/>.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.RenderOp">
            <summary>
            	General render operation structure.  Fallback if nothing else is available.
            </summary>
        </member>
        <member name="F:Axiom.Core.RegionSceneQuery.lastResult">
            <summary>
            	List of results from the last non-listener query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.ClearResults">
            <summary>
            	Clears out any cached results from the last query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.Execute">
            <summary>
            	Executes the query, returning the results back in one list.
            </summary>
            <remarks>
            	This method executes the scene query as configured, gathers the results
            	into one structure and returns a reference to that structure. These
            	results will also persist in this query object until the next query is
            	executed, or <see cref="M:Axiom.Core.RegionSceneQuery.ClearResults"/> is called. An more lightweight version of
            	this method that returns results through a listener is also available.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.Execute(Axiom.Core.ISceneQueryListener)">
            <summary>
            	Executes the query and returns each match through a listener interface.
            </summary>
            <remarks>
            	Note that this method does not store the results of the query internally
            	so does not update the 'last result' value. This means that this version of
            	execute is more lightweight and therefore more efficient than the version
            	which returns the results as a collection.
            </remarks>
            <param name="listener"></param>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.OnQueryResult(Axiom.Core.MovableObject)">
            <summary>
            	Self-callback in order to deal with execute which returns collection.
            </summary>
            <param name="sceneObject"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.OnQueryResult(Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            	Self-callback in order to deal with execute which returns collection.
            </summary>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Core.AxisAlignedBoxRegionSceneQuery.box">
            <summary>
            	Sphere to query items within.
            </summary>
        </member>
        <member name="M:Axiom.Core.AxisAlignedBoxRegionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBoxRegionSceneQuery.Box">
            <summary>
            	Gets/Sets the sphere to use for the query.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultRaySceneQuery">
            <summary>
               Default implementation of RaySceneQuery.
            </summary>
            <remarks>
            Note that becuase we have no scene partitioning, we actually
            perform a complete scene search even if restricted results are
            requested; smarter scene manager queries can utilise the paritioning
            of the scene in order to reduce the number of intersection tests
            required to fulfil the query
            </remarks>
        </member>
        <member name="T:Axiom.Core.RaySceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying for objects along a ray.
            </summary>
        </member>
        <member name="T:Axiom.Core.IRaySceneQueryListener">
            <summary>
            	Alternative listener interface for dealing with <see cref="T:Axiom.Core.RaySceneQuery"/>.
            </summary>
        </member>
        <member name="M:Axiom.Core.IRaySceneQueryListener.OnQueryResult(Axiom.Core.MovableObject,System.Single)">
            <summary>
            	Called when a scene objects intersect the ray.
            </summary>
            <param name="sceneObject">Reference to the object hit by the ray.</param>
            <param name="distance">Distance from the origin of the ray where the intersection took place.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="M:Axiom.Core.IRaySceneQueryListener.OnQueryResult(Axiom.Core.SceneQuery.WorldFragment,System.Single)">
            <summary>
            	Called when a world fragment is intersected by the ray.
            </summary>
            <param name="fragment">World fragment hit by the ray.</param>
            <param name="distance">Distance from the origin of the ray where the intersection took place.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.ray">
            <summary>
            	Reference to a ray to use for this query.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.sortByDistance">
            <summary>
            	If true, results returned in the list
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.maxResults">
            <summary>
            	Maximum results to return when executing the query.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.lastResults">
            <summary>
            	List of query results from the last execution of this query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Constructor.
            </summary>
            <param name="creator">Scene manager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.ClearResults">
            <summary>
            	Clears out any cached results from the last query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.Execute">
            <summary>
            	Executes the query, returning the results back in one list.
            </summary>
            <remarks>
            	This method executes the scene query as configured, gathers the results
            	into one structure and returns a reference to that structure. These
            	results will also persist in this query object until the next query is
            	executed, or <see cref="M:Axiom.Core.RaySceneQuery.ClearResults"/>. A more lightweight version of
            	this method that returns results through a listener is also available.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.Execute(Axiom.Core.IRaySceneQueryListener)">
            <summary>
            	Executes the query and returns each match through a listener interface.
            </summary>
            <remarks>
            	Note that this method does not store the results of the query internally
            	so does not update the 'last result' value. This means that this version of
            	execute is more lightweight and therefore more efficient than the version
            	which returns the results as a collection.
            </remarks>
            <param name="listener">Listener object to handle the result callbacks.</param>
        </member>
        <member name="P:Axiom.Core.RaySceneQuery.Ray">
            <summary>
               Gets/Sets the Ray being used for this query.
            </summary>
        </member>
        <member name="P:Axiom.Core.RaySceneQuery.SortByDistance">
            <summary>
            	Gets/Sets whether this queries results are sorted by distance.
            </summary>
            <remarks>
            	Often you want to know what was the first object a ray intersected with, and this
            	method allows you to ask the query to sort the results so that the nearest results
            	are listed first.
            	<p/>
            	Note that because the query returns results based on bounding volumes, the ray may not
            	actually intersect the detail of the objects returned from the query, just their
            	bounding volumes. For this reason the caller is advised to use more detailed
            	intersection tests on the results if a more accurate result is required; we use
            	bounds checking in order to give the most speedy results since not all applications
            	need extreme accuracy.
            </remarks>
        </member>
        <member name="P:Axiom.Core.RaySceneQuery.MaxResults">
            <summary>
            	Gets/Sets the maximum number of results to return from this query when
            	sorting is enabled.
            </summary>
            <remarks>
            	If sorting by distance is not enabled, then this value has no affect.
            </remarks>
        </member>
        <member name="T:Axiom.Core.DefaultSphereRegionSceneQuery">
            <summary>
            	Default implementation of a SphereRegionSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.SphereRegionSceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying items within a sphere.
            </summary>
        </member>
        <member name="F:Axiom.Core.SphereRegionSceneQuery.sphere">
            <summary>
            	Sphere to query items within.
            </summary>
        </member>
        <member name="M:Axiom.Core.SphereRegionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="P:Axiom.Core.SphereRegionSceneQuery.Sphere">
            <summary>
            	Gets/Sets the sphere to use for the query.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultPlaneBoundedVolumeListSceneQuery">
            <summary>
            	Default implementation of a PlaneBoundedVolumeListSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying items within PlaneBoundedVolumes.
            </summary>
        </member>
        <member name="F:Axiom.Core.PlaneBoundedVolumeListSceneQuery.volumes">
            <summary>
            	Sphere to query items within.
            </summary>
        </member>
        <member name="M:Axiom.Core.PlaneBoundedVolumeListSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="P:Axiom.Core.PlaneBoundedVolumeListSceneQuery.Volumes">
            <summary>
            	Gets/Sets the sphere to use for the query.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultIntersectionSceneQuery">
            <summary>
               Default implementation of IntersectionSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.IntersectionSceneQuery">
            <summary>
            Separate SceneQuery class to query for pairs of objects which are
            possibly intersecting one another.
            </summary>
            <remarks>
            This SceneQuery subclass considers the whole world and returns pairs of objects
            which are close enough to each other that they may be intersecting. Because of
            this slightly different focus, the return types and listener interface are
            different for this class.
            </remarks>
        </member>
        <member name="T:Axiom.Core.IIntersectionSceneQueryListener">
            <summary>
            	Alternative listener interface for dealing with <see cref="T:Axiom.Core.IntersectionSceneQuery"/>.
            </summary>
            <remarks>
            	Because the IntersectionSceneQuery returns results in pairs, rather than singularly,
            	the listener interface must be customised from the standard SceneQueryListener.
            </remarks>
        </member>
        <member name="M:Axiom.Core.IIntersectionSceneQueryListener.OnQueryResult(Axiom.Core.MovableObject,Axiom.Core.MovableObject)">
            <summary>
            	Called when 2 movable objects intersect one another.
            </summary>
            <param name="first">Reference to the first intersecting object.</param>
            <param name="second">Reference to the second intersecting object.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="M:Axiom.Core.IIntersectionSceneQueryListener.OnQueryResult(Axiom.Core.MovableObject,Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            	Called when a movable intersects a world fragment.
            </summary>
            <param name="obj">Intersecting object.</param>
            <param name="fragment">Intersecting world fragment.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="F:Axiom.Core.IntersectionSceneQuery.lastResults">
            <summary>
            	List of query results from the last execution of this query.
            </summary>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Constructor.
            </summary>
            <param name="creator">Scene manager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.ClearResults">
            <summary>
            	Clears out any cached results from the last query.
            </summary>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.Execute">
            <summary>
            	Executes the query, returning the results back in one list.
            </summary>
            <remarks>
            	This method executes the scene query as configured, gathers the results
            	into one structure and returns a reference to that structure. These
            	results will also persist in this query object until the next query is
            	executed, or <see cref="M:Axiom.Core.IntersectionSceneQuery.ClearResults"/>. A more lightweight version of
            	this method that returns results through a listener is also available.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.Execute(Axiom.Core.IIntersectionSceneQueryListener)">
            <summary>
            	Executes the query and returns each match through a listener interface.
            </summary>
            <remarks>
            	Note that this method does not store the results of the query internally
            	so does not update the 'last result' value. This means that this version of
            	execute is more lightweight and therefore more efficient than the version
            	which returns the results as a collection.
            </remarks>
            <param name="listener">Listener object to handle the result callbacks.</param>
        </member>
        <member name="T:Axiom.Core.ViewPoint">
            <summary>
                Structure for holding a position &amp; orientation pair.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneManagerMetaData">
            <summary>
            	Structure containing information about a scene manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerMetaData.description">
            <summary>
            	A text description of the scene manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerMetaData.sceneTypeMask">
            <summary>
            	A mask describing which sorts of scenes this manager can handle.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerMetaData.typeName">
            <summary>
            	A globally unique string identifying the scene manager type.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerMetaData.worldGeometrySupported">
            <summary>
            		Flag indicating whether world geometry is supported.
             </summary>
        </member>
        <member name="T:Axiom.Core.SceneManagerFactory">
            <summary>
            	Class which will create instances of a given SceneManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerFactory.metaData">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerFactory.metaDataInit">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Core.SceneManagerFactory.InitMetaData">
            <summary>
            	Internal method to initialise the metadata, must be implemented.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManagerFactory.CreateInstance(System.String)">
            <summary>
            	Creates a new instance of a SceneManager.
            </summary>
            <remarks>
            	Don't call directly, use SceneManagerEnumerator.CreateSceneManager.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManagerFactory.DestroyInstance(Axiom.Core.SceneManager)">
            <summary>
            	Destroys an instance of a SceneManager.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="P:Axiom.Core.SceneManagerFactory.MetaData">
            <summary>
            	Gets information about the SceneManager type created by this factory.
            </summary>
        </member>
        <member name="T:Axiom.Animating.KeyFrame">
            <summary>
            	A key frame in an animation sequence defined by an AnimationTrack.
            </summary>
            <remarks>
            	This class can be used as a basis for all kinds of key frames. 
            	The unifying principle is that multiple KeyFrames define an 
            	animation sequence, with the exact state of the animation being an 
            	interpolation between these key frames.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.time">
            <summary>
            	Time of this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.parentTrack">
            <summary>
            	Animation track that this key frame belongs to.
            </summary>
        </member>
        <member name="M:Axiom.Animating.KeyFrame.#ctor(Axiom.Animating.AnimationTrack,System.Single)">
            <summary>
            	Creates a new keyframe with the specified time.  
            	Should really be created by <see cref="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)"/> instead.
            </summary>
            <param name="parent">Animation track that this keyframe belongs to.</param>
            <param name="time">Time at which this keyframe begins.</param>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Time">
            <summary>
            	Gets the time of this keyframe in the animation sequence.
            </summary>
        </member>
        <member name="T:Axiom.Animating.NumericKeyFrame">
            <summary>Specialised KeyFrame which stores any numeric value.</summary>
        </member>
        <member name="F:Axiom.Animating.NumericKeyFrame.numericValue">
            <summary>
            	Object holding the numeric value
            </summary>
        </member>
        <member name="M:Axiom.Animating.NumericKeyFrame.#ctor(Axiom.Animating.AnimationTrack,System.Single)">
            <summary>
            	Creates a new keyframe with the specified time.  
            	Should really be created by <see cref="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)"/> instead.
            </summary>
            <param name="parent">Animation track that this keyframe belongs to.</param>
            <param name="time">Time at which this keyframe begins.</param>
        </member>
        <member name="P:Axiom.Animating.NumericKeyFrame.NumericValue">
            <summary>
            	Gets the time of this keyframe in the animation sequence.
            </summary>
        </member>
        <member name="T:Axiom.Animating.TransformKeyFrame">
            <summary>Specialised KeyFrame which stores a full transform.</summary>
        </member>
        <member name="F:Axiom.Animating.TransformKeyFrame.translate">
            <summary>
            	Translation at this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TransformKeyFrame.scale">
            <summary>
            	Scale factor at this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TransformKeyFrame.rotation">
            <summary>
            	Rotation at this keyframe.
            </summary>
        </member>
        <member name="M:Axiom.Animating.TransformKeyFrame.#ctor(Axiom.Animating.AnimationTrack,System.Single)">
            <summary>
            	Creates a new keyframe with the specified time.  
            	Should really be created by <see cref="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)"/> instead.
            </summary>
            <param name="parent">Animation track that this keyframe belongs to.</param>
            <param name="time">Time at which this keyframe begins.</param>
        </member>
        <member name="P:Axiom.Animating.TransformKeyFrame.Rotation">
            <summary>
            	Sets the rotation applied by this keyframe.
            	Use Quaternion methods to convert from angle/axis or Matrix3 if
            	you don't like using Quaternions directly.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TransformKeyFrame.Scale">
            <summary>
            	Sets the scaling factor applied by this keyframe to the animable
            	object at its time index.
            	beware of supplying zero values for any component of this
            	vector, it will scale the object to zero dimensions.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TransformKeyFrame.Translate">
            <summary>
            	Sets the translation associated with this keyframe. 
            </summary>
            <remarks>
            	The translation factor affects how much the keyframe translates (moves) its animable
            	object at it's time index.
            </remarks>
        </member>
        <member name="T:Axiom.Animating.PoseRef">
            <summary>Reference to a pose at a given influence level</summary>
            <remarks>
            	Each keyframe can refer to many poses each at a given influence level.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.PoseRef.poseIndex">
            <summary>The linked pose index.</summary>
            <remarks>
                The Mesh contains all poses for all vertex data in one list, both 
                for the shared vertex data and the dedicated vertex data on submeshes.
                The 'target' on the parent track must match the 'target' on the 
                linked pose.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.PoseRef.influence">
            <summary>
                Influence level of the linked pose. 
                1.0 for full influence (full offset), 0.0 for no influence.
            </summary>
        </member>
        <member name="F:Axiom.Animating.VertexMorphKeyFrame.vertexBuffer">
            <summary>
            	A list of the pose references for this frame
            </summary>
        </member>
        <member name="M:Axiom.Animating.VertexMorphKeyFrame.#ctor(Axiom.Animating.AnimationTrack,System.Single)">
            <summary>
            	Creates a new keyframe with the specified time.  
            	Should really be created by <see cref="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)"/> instead.
            </summary>
            <param name="parent">Animation track that this keyframe belongs to.</param>
            <param name="time">Time at which this keyframe begins.</param>
        </member>
        <member name="P:Axiom.Animating.VertexMorphKeyFrame.VertexBuffer">
            <summary>
            	Gets or sets the vertex buffer
            </summary>
        </member>
        <member name="F:Axiom.Animating.VertexPoseKeyFrame.poseRefs">
            <summary>
            	A list of the pose references for this frame
            </summary>
        </member>
        <member name="M:Axiom.Animating.VertexPoseKeyFrame.#ctor(Axiom.Animating.AnimationTrack,System.Single)">
            <summary>
            	Creates a new keyframe with the specified time.  
            	Should really be created by <see cref="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)"/> instead.
            </summary>
            <param name="parent">Animation track that this keyframe belongs to.</param>
            <param name="time">Time at which this keyframe begins.</param>
        </member>
        <member name="M:Axiom.Animating.VertexPoseKeyFrame.AddPoseReference(System.UInt16,System.Single)">
            <summary>Add a new pose reference.</summary>
        </member>
        <member name="M:Axiom.Animating.VertexPoseKeyFrame.UpdatePoseReference(System.UInt16,System.Single)">
            <summary>Update the influence of a pose reference.</summary>
        </member>
        <member name="M:Axiom.Animating.VertexPoseKeyFrame.RemovePoseReference(System.UInt16)">
            <summary>Remove reference to a given pose.</summary>
            <param name="poseIndex">The pose index (not the index of the reference)</param>
        </member>
        <member name="M:Axiom.Animating.VertexPoseKeyFrame.RemoveAllPoseReferences">
            <summary>Remove all pose references.</summary>
        </member>
        <member name="P:Axiom.Animating.VertexPoseKeyFrame.PoseRefs">
            <summary>
            	Gets the time of this keyframe in the animation sequence.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TriangleListBuilder">
            <summary>
                General utility class for collecting the set of all
                triangles in a mesh; used for picking
            </summary>
        </member>
        <member name="T:Axiom.Graphics.AnyBuilder">
            <summary>
            Base class for classes that iterate over the vertices in a mesh
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AnyBuilder.indexDataList">
            <summary>
            List of objects that will provide index data to the build process.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AnyBuilder.indexDataVertexDataSetList">
            <summary>
            Mapping of index data sets to vertex data sets.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AnyBuilder.vertexDataList">
            <summary>
            List of vertex data objects.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AnyBuilder.operationTypes">
            <summary>
            Mappings of operation type to vertex data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AnyBuilder.customIndexBufferList">
            <summary>
            List of software index buffers that were created and to be disposed by this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AnyBuilder.AddVertexData(Axiom.Graphics.VertexData)">
            <summary>
            Add a set of vertex geometry data to the edge builder.
            </summary>
            <remarks>
            You must add at least one set of vertex data to the builder before invoking the
            <see name="Build"/> method.
            </remarks>
            <param name="vertexData">Vertex data to consider for edge detection.</param>
        </member>
        <member name="M:Axiom.Graphics.AnyBuilder.AddIndexData(Axiom.Graphics.IndexData)">
            <summary>
            Add a set of index geometry data to the edge builder.
            </summary>
            <remarks>
            You must add at least one set of index data to the builder before invoking the
            <see name="Build"/> method.
            </remarks>
            <param name="indexData">The index information which describes the triangles.</param>
        </member>
        <member name="M:Axiom.Graphics.AnyBuilder.AddIndexData(Axiom.Graphics.IndexData,System.Int32,Axiom.Graphics.OperationType)">
            <summary>
            Add a set of index geometry data to the edge builder.
            </summary>
            <remarks>
            You must add at least one set of index data to the builder before invoking the
            <see name="Build"/> method.
            </remarks>
            <param name="indexData">The index information which describes the triangles.</param>
            <param name="vertexSet">
            The vertex data set this index data refers to; you only need to alter this
            if you have added multiple sets of vertices.
            </param>
            <param name="opType"></param>
        </member>
        <member name="M:Axiom.Graphics.AnyBuilder.AddObject(Axiom.Graphics.IRenderable)">
            <summary>
            Populate with data as obtained from an IRenderable.
            </summary>
            <remarks>
            Will share the buffers.
            In case there are no index data associated with the <see cref="T:Axiom.Graphics.IRenderable"/>, i.e. <see cref="F:Axiom.Graphics.RenderOperation.useIndices"/> is false,
            custom software index buffer is created to provide default index data to the builder.
            This makes it possible for derived classes to handle the data in a convenient way.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.AnyBuilder.AddObject(Axiom.Core.Mesh,System.Int32)">
            <summary>
            Add vertex and index sets of a mesh to the builder.
            </summary>
            <param name="mesh">The mesh object.</param>
            <param name="lodIndex">The LOD level to be processed.</param>
        </member>
        <member name="M:Axiom.Graphics.AnyBuilder.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="T:Axiom.Graphics.HardwarePixelBuffer">
            <summary>
                Specialization of HardwareBuffer for a pixel buffer. The
                HardwarePixelbuffer abstracts an 1D, 2D or 3D quantity of pixels
                stored by the rendering API. The buffer can be located on the card
                or in main memory depending on its usage. One mipmap level of a
                texture is an example of a HardwarePixelBuffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwarePixelBuffer._width">
            <summary>
                Extents
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwarePixelBuffer._rowPitch">
            <summary>
                Pitches (offsets between rows and slices)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwarePixelBuffer._format">
            <summary>
                Internal format
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwarePixelBuffer._currentLock">
            <summary>
                Currently locked region
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.#ctor(System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
                Should be called by HardwareBufferManager
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.LockImpl(Axiom.Media.BasicBox,Axiom.Graphics.BufferLocking)">
            <summary>
                Internal implementation of lock(), must be overridden in subclasses
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.BlitFromMemory(Axiom.Media.PixelBox,Axiom.Media.BasicBox)">
            <summary>
                Copies a region from normal memory to a region of this pixelbuffer. The source
                image can be in any pixel format supported by Axiom, and in any size. 
            </summary>
            <param name="src">PixelBox containing the source pixels and format in memory</param>
            <param name="dstBox">Image.BasicBox describing the destination region in this buffer</param>
            <remarks>
                The source and destination regions dimensions don't have to match, in which
                case scaling is done. This scaling is generally done using a bilinear filter in hardware,
                but it is faster to pass the source image in the right dimensions.
                Only call this function when both  buffers are unlocked. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.BlitToMemory(Axiom.Media.BasicBox,Axiom.Media.PixelBox)">
            <summary>
                Copies a region of this pixelbuffer to normal memory.
            </summary>
            <param name="srcBox">BasicBox describing the source region of this buffer</param>
            <param name="dst">PixelBox describing the destination pixels and format in memory</param>
            <remarks>
                The source and destination regions don't have to match, in which
                case scaling is done.
                Only call this function when the buffer is unlocked. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.Lock(Axiom.Media.BasicBox,Axiom.Graphics.BufferLocking)">
            <summary>
                Lock the buffer for (potentially) reading / writing.
            </summary>
            <param name="lockBox">Region of the buffer to lock</param>
            <param name="options">Locking options</param>
            <returns>
                PixelBox containing the locked region, the pitches and
                the pixel format
            </returns>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.LockImpl(System.Int32,System.Int32,Axiom.Graphics.BufferLocking)">
            <summary>
                Internal implementation of lock(), do not override or call this
                for HardwarePixelBuffer implementations, but override the previous method
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.Blit(Axiom.Graphics.HardwarePixelBuffer,Axiom.Media.BasicBox,Axiom.Media.BasicBox)">
            <summary>
                Copies a box from another PixelBuffer to a region of the 
                this PixelBuffer. 
            </summary>
            <param name="src">Source/dest pixel buffer</param>
            <param name="srcBox">Image.BasicBox describing the source region in this buffer</param>
            <param name="dstBox">Image.BasicBox describing the destination region in this buffer</param>
            <remarks>
                The source and destination regions dimensions don't have to match, in which
                case scaling is done. This scaling is generally done using a bilinear filter in hardware,
                but it is faster to pass the source image in the right dimensions.
                Only call this function when both buffers are unlocked. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.ClearSliceRTT(System.Int32)">
            <summary>
                Notify TextureBuffer of destruction of render target.
                Called by RenderTexture when destroyed.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.ReadData(System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Reads data from the buffer and places it in the memory pointed to by 'dest'.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to read.</param>
            <param name="length">The size of the area to read, in bytes.</param>
            <param name="dest">
                The area of memory in which to place the data, must be large enough to 
                accommodate the data!
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.WriteData(System.Int32,System.Int32,System.IntPtr,System.Boolean)">
            <summary>
                Writes data to the buffer from an area of system memory; note that you must
                ensure that your buffer is big enough.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="source">The source of the data to be written.</param>
            <param name="discardWholeBuffer">
                If true, this allows the driver to discard the entire buffer when writing,
                such that DMA stalls can be avoided; use if you can.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.Blit(Axiom.Graphics.HardwarePixelBuffer)">
            <summary>
                Convience function that blits the entire source pixel buffer to this buffer. 
                If source and destination dimensions don't match, scaling is done.
            </summary>
            <param name="src">PixelBox containing the source pixels and format in memory</param>
            <remarks>
                Only call this function when the buffer is unlocked. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.BlitFromMemory(Axiom.Media.PixelBox)">
            <summary>
                Convenience function that blits a pixelbox from memory to the entire 
                buffer. The source image is scaled as needed.
            </summary>
            <param name="src">PixelBox containing the source pixels and format in memory</param>
            <remarks>
                Only call this function when the buffer is unlocked. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.BlitToMemory(Axiom.Media.PixelBox)">
            <summary>
                Convenience function that blits this entire buffer to a pixelbox.
                The image is scaled as needed.
            </summary>
            <param name="dst">PixelBox containing the source pixels and format in memory</param>
            <remarks>
                Only call this function when the buffer is unlocked. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.GetRenderTarget(System.Int32)">
            <summary>
                Get a render target for this PixelBuffer, or a slice of it. The texture this
                was acquired from must have TextureUsage.RenderTarget set, otherwise it is possible to
                render to it and this method will throw an exception.
            </summary>
            <param name="slice">Which slice</param>
            <returns>
                A pointer to the render target. This pointer has the lifespan of this PixelBuffer.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.HardwarePixelBuffer.GetRenderTarget">
            <summary>
                Get a render target for this PixelBuffer, or a slice of it. The texture this
                was acquired from must have TextureUsage.RenderTarget set, otherwise it is possible to
                render to it and this method will throw an exception.
            </summary>
            <returns>
                A pointer to the render target. This pointer has the lifespan of this PixelBuffer.
            </returns>
        </member>
        <member name="P:Axiom.Graphics.HardwarePixelBuffer.CurrentLock">
            <summary>
                Get the current locked region. This is the same value as returned
                by Lock(BasicBox, BufferLocking)
            </summary>
            <returns>PixelBox containing the locked region</returns>
        </member>
        <member name="T:Axiom.Graphics.HardwareOcclusionQuery">
            <summary>
            	Interface specification for hardware queries that can be used to find the number
            	of fragments rendered by the last render operation.
            </summary>
            Original Author: Lee Sandberg.
        </member>
        <member name="M:Axiom.Graphics.HardwareOcclusionQuery.Begin">
            <summary>
            Starts the hardware occlusion query
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareOcclusionQuery.End">
            <summary>
            Ends the hardware occlusion test
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareOcclusionQuery.PullResults">
            <summary>
            Pulls the hardware occlusion query.
            </summary>
            <remarks>
            Waits until the query result is available; use <see cref="M:Axiom.Graphics.HardwareOcclusionQuery.IsStillOutstanding"/>
            if just want to test if the result is available.
            </remarks>
            <returns>the resulting number of fragments.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareOcclusionQuery.IsStillOutstanding">
            <summary>
            Lets you know when query is done, or still be processed by the Hardware
            </summary>
            <returns>true if query isn't finished.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareOcclusionQuery.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
             
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Graphics.HardwareOcclusionQuery.LastFragmentCount">
            <summary>
            Let's you get the last pixel count with out doing the hardware occlusion test
            </summary>
            <remarks>
            This function won't give you new values, just the old value.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.DepthBuffer">
            <summary>
            An abstract class that contains a depth/stencil buffer.
            Depth Buffers can be attached to render targets. Note we handle Depth &amp; Stencil together.
            DepthBuffer sharing is handled automatically for you. However, there are times where you want
            to specifically control depth buffers to achieve certain effects or increase performance.
            You can control this by hinting Ogre with POOL IDs. Created depth buffers can live in different
            pools, or alltoghether in the same one.
            Usually, a depth buffer can only be attached to a RenderTarget only if it's dimensions are bigger
            and have the same bit depth and same multisample settings. Depth Buffers are created automatically
            for new RTs when needed, and stored in the pool where the RenderTarget should have drawn from.
            By default, all RTs have the Id POOL_DEFAULT, which means all depth buffers are stored by default
            in that pool. By chosing a different Pool Id for a specific RenderTarget, that RT will only
            retrieve depth buffers from _that_ pool, therefore not conflicting with sharing depth buffers
            with other RTs (such as shadows maps).
            Setting an RT to POOL_MANUAL_USAGE means Ogre won't manage the DepthBuffer for you (not recommended)
            RTs with POOL_NO_DEPTH are very useful when you don't want to create a DepthBuffer for it. You can
            still manually attach a depth buffer though as internally POOL_NO_DEPTH &amp; POOL_MANUAL_USAGE are
            handled in the same way.
            
            Behavior is consistent across all render systems, if, and only if, the same RSC flags are set
            RSC flags that affect this class are:
            * RSC_RTT_SEPARATE_DEPTHBUFFER:
            The RTT can create a custom depth buffer different from the main depth buffer. This means,
            an RTT is able to not share it's depth buffer with the main window if it wants to.
            * RSC_RTT_MAIN_DEPTHBUFFER_ATTACHABLE:
            When RSC_RTT_SEPARATE_DEPTHBUFFER is set, some APIs (ie. OpenGL w/ FBO) don't allow using
            the main depth buffer for offscreen RTTs. When this flag is set, the depth buffer can be
            shared between the main window and an RTT.
            * RSC_RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL:
            When this flag isn't set, the depth buffer can only be shared across RTTs who have the EXACT
            same resolution. When it's set, it can be shared with RTTs as long as they have a
            resolution less or equal than the depth buffer's.
            </summary>
            <remarks>
            Design discussion <a href="http://www.ogre3d.org/forums/viewtopic.php?f=4&amp;t=53534&amp;p=365582" />
            </remarks>    
        </member>
        <member name="M:Axiom.Graphics.DepthBuffer.SetPoolId(Axiom.Graphics.PoolId)">
            <summary>
            Sets the pool id in which this DepthBuffer lives
            Note this will detach any render target from this depth buffer
            </summary>
        </member>
        <member name="M:Axiom.Graphics.DepthBuffer.IsCompatible(Axiom.Graphics.RenderTarget)">
            <summary>
            Returns whether the specified RenderTarget is compatible with this DepthBuffer
            That is, this DepthBuffer can be attached to that RenderTarget
            </summary>
            <remarks>
            Most APIs impose the following restrictions:
            Width &amp; height must be equal or higher than the render target's
            They must be of the same bit depth.
            They need to have the same FSAA setting
            </remarks>
            <param name="renderTarget">The render target to test against</param>
            <returns>true if compatible</returns>
        </member>
        <member name="M:Axiom.Graphics.DepthBuffer.NotifyRenderTargetAttached(Axiom.Graphics.RenderTarget)">
            <summary>
            Called when a RenderTarget is attaches this DepthBuffer
            </summary>
            <remarks>
            This function doesn't actually attach. It merely informs the DepthBuffer
            which RenderTarget did attach. The real attachment happens in
            RenderTarget::attachDepthBuffer()
            </remarks>
            <param name="renderTarget">The RenderTarget that has just been attached</param>
        </member>
        <member name="M:Axiom.Graphics.DepthBuffer.NotifyRenderTargetDetached(Axiom.Graphics.RenderTarget)">
            <summary>
            Called when a RenderTarget is detaches from this DepthBuffer
            </summary>
            <remarks>
            Same as <see cref="M:Axiom.Graphics.DepthBuffer.NotifyRenderTargetAttached(Axiom.Graphics.RenderTarget)"/>
            </remarks>        
            <param name="renderTarget">The RenderTarget that has just been attached</param>
        </member>
        <member name="P:Axiom.Graphics.DepthBuffer.PoolId">
            <summary>
            Gets the pool id in which this DepthBuffer lives
            </summary>
        </member>
        <member name="P:Axiom.Graphics.DepthBuffer.IsManual">
            <summary>
            Manual DepthBuffers are cleared in RenderSystem's destructor. Non-manual ones are released
            with it's render target (aka, a backbuffer or similar)
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.RenderTargetCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Graphics.RenderTarget">RenderTargets</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.ZipArchive">
            <summary>
            Specialization of the Archive class to allow reading of files from from a zip format source archive.
            </summary>
            <remarks>
            This archive format supports all archives compressed in the standard
            zip format, including iD pk3 files.
            </remarks>
            <ogre name="ZipArchive">
                <file name="OgreZip.h"   revision="" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreZip.cpp" revision="" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
        </member>
        <member name="F:Axiom.FileSystem.ZipArchive._zipFile">
            <summary>
            root location of the zip file.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.findFiles(System.String,System.Boolean,System.Collections.Generic.List{System.String},Axiom.FileSystem.FileInfoList)">
            <overloads><summary>
            Utility method to retrieve all files in a directory matching pattern.
            </summary>
            <param name="pattern">File pattern</param>
            <param name="recursive">Whether to cascade down directories</param>
            <param name="simpleList">Populated if retrieving a simple list</param>
            <param name="detailList">Populated if retrieving a detailed list</param>
            </overloads>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.findFiles(System.String,System.Boolean,System.Collections.Generic.List{System.String},Axiom.FileSystem.FileInfoList,System.String)">
            <param name="detailList"></param>
            <param name="currentDir">The current directory relative to the base of the archive, for file naming</param>
            <param name="pattern"></param>
            <param name="recursive"></param>
            <param name="simpleList"></param>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.Load">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.Unload">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.Open(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="filename"></param>
            <param name="readOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.List(System.Boolean)">
            <summary>
            
            </summary>
            <param name="recursive"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.ListFileInfo(System.Boolean)">
            <summary>
            
            </summary>
            <param name="recursive"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.Find(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pattern"></param>
            <param name="recursive"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.FindFileInfo(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pattern"></param>
            <param name="recursive"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchive.Exists(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.FileSystem.ZipArchive.IsCaseSensitive">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.ZipArchiveFactory">
            <summary>
            Specialization of ArchiveFactory for Zip files.
            </summary>
            <ogre name="ZipArchive">
                <file name="OgreZip.h"   revision="" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreZip.cpp" revision="" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
        </member>
        <member name="T:Axiom.Collections.SceneManagerCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.SceneManager">SceneManagers</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Collections.CameraCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.Camera">Cameras</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Collections.BoneCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Animating.Bone">Bones</see> that are sorted by key.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AxiomSortedCollection`2">
            <summary>
            Serves as a basis for strongly typed collections in the engine.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomSortedCollection`2.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomSortedCollection`2.#ctor(System.Object)">
             <summary>
            
             </summary>
             <param name="parent"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomSortedCollection`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Generic.SortedList`2"/> can contain.
            </param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys.
            -or-
            null to use the default <see cref="T:System.Collections.Generic.Comparer`1"/> for the type of the key.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.
            </exception>
        </member>
        <member name="M:Axiom.Collections.AxiomSortedCollection`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"/>, has sufficient capacity to accommodate the number of elements copied, and uses the specified <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"/> whose elements are copied to the new <see cref="T:System.Collections.Generic.SortedList`2"/>.
            </param><param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys.
            -or-
            null to use the default <see cref="T:System.Collections.Generic.Comparer`1"/> for the type of the key.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="dictionary"/> contains one or more duplicate keys.
            </exception>
        </member>
        <member name="M:Axiom.Scripting.Compiler.Parser.ScriptLexer.Tokenize(System.String,System.String)">
            <summary>
            Tokenizes the given input and returns the list of tokens found
            </summary>
            <param name="str"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ConcreteNodeType">
            <summary>
            These enums hold the types of the concrete parsed nodes
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ConcreteNode">
            <summary>
            The ConcreteNode is the class that holds an un-conditioned sub-tree of parsed input
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.VariableSetAbstractNode">
            <summary>
            This abstract node represents a variable assignment
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.VariableSetAbstractNode.Clone">
            <see cref="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone"/>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.VariableSetAbstractNode.Value">
            <see cref="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value"/>
        </member>
        <member name="T:Axiom.Graphics.RenderPriorityGroup">
            <summary>
            	IRenderables in the queue grouped by priority.
            </summary>
            <remarks>
            	This class simply groups renderables for rendering. All the 
            	renderables contained in this class are destined for the same
            	RenderQueueGroup (coarse groupings like those between the main
            	scene and overlays) and have the same priority (fine groupings
            	for detailed overlap control).
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.transparentPasses">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPasses">
            <summary>
            	Solid pass list, used when no shadows, modulative shadows, or ambient passes for additive.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPassesDiffuseSpecular">
            <summary>
            	Solid per-light pass list, used with additive shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPassesDecal">
            <summary>
            	Solid decal (texture) pass list, used with additive shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPassesNoShadow">
            <summary>
            	Solid pass list, used when shadows are enabled but shadow receive is turned off for these passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.splitPassesByLightingType">
            <summary>
            	Should passes be split by their lighting stage?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.#ctor(Axiom.Graphics.RenderQueueGroup,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddRenderable(Axiom.Graphics.IRenderable,Axiom.Graphics.Technique)">
            <summary>
            	Add a renderable to this group.
            </summary>
            <param name="renderable">Renderable to add to the queue.</param>
            <param name="technique"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddSolidRenderable(Axiom.Graphics.Technique,Axiom.Graphics.IRenderable,System.Boolean)">
            <summary>
            	Internal method for adding a solid renderable
            </summary>
            <param name="technique">Technique to use for this renderable.</param>
            <param name="renderable">Renderable to add to the queue.</param>
            <param name="noShadows">True to add to the no shadow group, false otherwise.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddSolidRenderableSplitByLightType(Axiom.Graphics.Technique,Axiom.Graphics.IRenderable)">
            <summary>
            	Internal method for adding a solid renderable ot the group based on lighting stage.
            </summary>
            <param name="technique">Technique to use for this renderable.</param>
            <param name="renderable">Renderable to add to the queue.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddTransparentRenderable(Axiom.Graphics.Technique,Axiom.Graphics.IRenderable)">
            <summary>
            	Internal method for adding a transparent renderable.
            </summary>
            <param name="technique">Technique to use for this renderable.</param>
            <param name="renderable">Renderable to add to the queue.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.Clear">
            <summary>
            	Clears all the internal lists.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.GetSolidPass(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.GetSolidPassRenderables(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.GetTransparentPass(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.Sort(Axiom.Core.Camera)">
            <summary>
               Sorts the objects which have been added to the queue; transparent objects by their 
               depth in relation to the passed in Camera, solid objects in order to minimize
               render state changes.
            </summary>
            <remarks>
               Solid passes are already stored in a sorted structure, so nothing extra needed here.
            </remarks>
            <param name="camera">Current camera to use for depth sorting.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.RemoveSolidPassEntry(Axiom.Graphics.Pass)">
            <summary>
            	Remove a pass entry from all solid pass maps
            </summary>
            <param name="pass">Reference to the pass to remove.</param>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.NumSolidPasses">
            <summary>
               Gets the number of non-transparent passes for this priority group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.NumTransparentPasses">
            <summary>
               Gets the number of transparent passes for this priority group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.SplitPassesByLightingType">
            <summary>
            	Gets/Sets whether or not the queue will split passes by their lighting type,
            	ie ambient, per-light and decal. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.SplitNoShadowPasses">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.ShadowCastersCannotBeReceivers">
            <summary>
            	Gets/Sets whether or not the queue will disallow receivers when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderPriorityGroup.SolidSort">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderPriorityGroup.TransparencySort">
            <summary>
            	Nested class that implements IComparer for transparency sorting.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HighLevelGpuProgram">
            <summary>
            	Abstract base class representing a high-level program (a vertex or
            	fragment program).
            </summary>
            <remarks>
               High-level programs are vertex and fragment programs written in a high-level
               language such as Cg or HLSL, and as such do not require you to write assembler code
               like GpuProgram does. However, the high-level program does eventually 
               get converted (compiled) into assembler and then eventually microcode which is
               what runs on the GPU. As well as the convenience, some high-level languages like Cg allow
               you to write a program which will operate under both Direct3D and OpenGL, something
               which you cannot do with just GpuProgram (which requires you to write 2 programs and
               use each in a Technique to provide cross-API compatibility). The engine will be creating
               a GpuProgram for you based on the high-level program, which is compiled specifically 
               for the API being used at the time, but this process is transparent.
               <p/>
               You cannot create high-level programs direct - use HighLevelGpuProgramManager instead.
               Plugins can register new implementations of HighLevelGpuProgramFactory in order to add
               support for new languages without requiring changes to the core engine API. To allow 
               custom parameters to be set, this class implement IConfigurable - the application
               can query on the available custom parameters and get/set them without having to 
               link specifically with it.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.GpuProgram">
            <summary>
                Defines a program which runs on the GPU such as a vertex or fragment program.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.fileName">
            <summary>
               The name of the file to load from source (may be blank).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.source">
            <summary>
               The assembler source of this program.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.morphAnimation">
            <summary>
                   Does this (vertex) program include morph animation?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.vertexTextureFetchRequired">
            <summary>
                   Does this (vertex) program require vertex texture fetch?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.needsAdjacencyInfo">
            <summary>
                   Does this (vertex) program require vertex texture fetch?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.poseAnimation">
            <summary>
                   Does this (vertex) program include morph animation?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.defaultParams">
            <summary>
               List of default parameters, as gathered from the program definition.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.compileError">
            <summary>
            Did we encounter a compilation error?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.ResetCompileError">
            <summary>
            Reset a compile error if it occurred, allowing the load to be retried.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.floatLogicalToPhysical">
            <summary>
            Record of logical to physical buffer maps. Mandatory for low-level
            programs or high-level programs which set their params the same way.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.intLogicalToPhysical">
            <summary>
            Record of logical to physical buffer maps. Mandatory for low-level
            programs or high-level programs which set their params the same way.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.constantDefs">
            <summary>
            Parameter name -> ConstantDefinition map, shared instance used by all parameter objects
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.manualNamedConstantsFile">
            <summary>   
            File from which to load named constants manually
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <summary>
               Constructor for creating
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.CreateParameters">
            <summary>
               Creates a new parameters object compatible with this program definition.
            </summary>
            <remarks>
               It is recommended that you use this method of creating parameters objects
               rather than going direct to GpuProgramManager, because this method will
               populate any implementation-specific extras (like named parameters) where
               they are appropriate.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.load">
            <summary>
               Loads this Gpu Program.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.LoadFromSource">
            <summary>
               Method which must be implemented by subclasses, loads the program from source.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.CreateParameterMappingStructures(System.Boolean)">
            <summary>
            Create the internal params logical &amp; named mapping structures
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.CreateLogicalParameterMappingStructures(System.Boolean)">
            <summary>
            Create the internal params logical mapping structures
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.CreateNamedParameterMappingStructures(System.Boolean)">
            <summary>
            Create the internal params named mapping structures
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.BindingDelegate">
            <summary>
               Returns the GpuProgram which should be bound to the pipeline.
            </summary>
            <remarks>
               This method is simply to allow some subclasses of GpuProgram to delegate
               the program which is bound to the pipeline to a delegate, if required.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.LoadFromFile">
            <summary>
               Whether this source is being loaded from file or not.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.SourceFile">
            <summary>
               Gets/Sets the source file for this program.
            </summary>
            <remarks>
               Setting this will have no effect until you (re)load the program.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.Source">
            <summary>
               Gets/Sets the source assembler code for this program.
            </summary>
            <remarks>
               Setting this will have no effect until you (re)load the program.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.SyntaxCode">
            <summary>
              Syntax code (i.e. arbvp1, vs_2_0, etc.)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.Language">
            <summary>
               Gets the language of this program
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.Type">
            <summary>
              Type of program this represents (vertex or fragment).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsSkeletalAnimationIncluded">
            <summary>
                   Flag indicating whether this program is being used for hardware skinning.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsMorphAnimationIncluded">
            <summary>
                   Gets/Sets whether a vertex program includes the required instructions
                   to perform morph animation. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsVertexTextureFetchRequired">
            <summary>
                   Gets/Sets whether this vertex program requires support for vertex 
                   texture fetch from the hardware. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsAdjacencyInfoRequired">
            <summary>
                   Gets/Sets whether this vertex program requires support for vertex 
                   texture fetch from the hardware. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.PoseAnimationCount">
            <summary>
                   Gets/Sets whether a vertex program includes the required instructions
                   to perform pose animation. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsPoseAnimationIncluded">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.DefaultParameters">
            <summary>
               Get a reference to the default parameters which are to be used for all uses of this program.
            </summary>
            <remarks>
            A program can be set up with a list of default parameters, which can save time when 
            using a program many times in a material with roughly the same settings. By 
            retrieving the default parameters and populating it with the most used options, 
            any new parameter objects created from this program afterwards will automatically include
            the default parameters; thus users of the program need only change the parameters
            which are unique to their own usage of the program.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.PassSurfaceAndLightStates">
            <summary>
                   Determines whether a vertex program requires light and material states to be passed
                   to through fixed pipeline low level API rendering calls.
            </summary>
            <remarks>
                   If this is set to true, Axiom will pass all active light states to the fixed function
                   pipeline.  This is useful for high level shaders like GLSL that can read the OpenGL
                   light and material states.  This way the user does not have to use autoparameters to 
                   pass light position, color etc.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.PassFogStates">
            <summary>
                   Determines whether a vertex program requires fog states to be passed
                   to through fixed pipeline low level API rendering calls.
            </summary>
            <remarks>
                   If this is set to true, Axiom will pass all fog states to the fixed function
                   pipeline.  This is useful for high level shaders like GLSL that can read the OpenGL
                   fog states.  This way the user does not have to use autoparameters to 
                   pass fog color etc.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.PassTransformStates">
            <summary>
                   Sets whether a vertex program requires transform states to be passed
                   to through fixed pipeline low level API rendering calls.
            </summary>
            <remarks>
                   If this is set to true, Axiom will pass all transform states to the fixed function
                   pipeline.  This is useful for high level shaders like GLSL that can read the OpenGL
                   transform states.  This way the user does not have to use autoparameters to 
                   pass position etc.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsSupported">
            <summary>
               Returns whether this program can be supported on the current renderer and hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.SamplerCount">
            <summary>
            Returns the maximum number of samplers that this fragment program has access
            to, based on the fragment program profile it uses.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.HasCompileError">
            <summary>
            Did this program encounter a compile error when loading?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.ConstantDefinitions">
            <summary>
            Get the full list of named constants.
            </summary>
            <note>
            Only available if this parameters object has named parameters, which means either
            a high-level program which loads them, or a low-level program which has them
            specified manually.
            </note>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.ManualNamedConstants">
            <summary>
            Allows you to manually provide a set of named parameter mappings
            to a program which would not be able to derive named parameters itself.
            </summary>
            <remarks>
            You may wish to use this if you have assembler programs that were compiled
            from a high-level source, and want the convenience of still being able
            to use the named parameters from the original high-level source.
            <seealso cref="P:Axiom.Graphics.GpuProgram.ManualNamedConstantsFile"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.ManualNamedConstantsFile">
            <summary>
            Specifies the name of a file from which to load named parameters mapping
            for a program which would not be able to derive named parameters itself.
            </summary>
            <remarks>
            You may wish to use this if you have assembler programs that were compiled
            from a high-level source, and want the convenience of still being able
            to use the named parameters from the original high-level source. This
            method will make a low-level program search in the resource group of the
            program for the named file from which to load parameter names from. 
            The file must be in the format produced by <see>GpuNamedConstants.Save</see>.
            </remarks>
        </member>
        <member name="T:Axiom.Core.IConfigurable">
            <summary>
            	Describes behaviors required by objects that can be configured, whether through script
            	parameters or programatically.
            </summary>
        </member>
        <member name="M:Axiom.Core.IConfigurable.SetParam(System.String,System.String)">
            <summary>
               Will be called by script parsers that run across extended properties, and will pass them
               along expecting the target object to handle them.
            </summary>
            <param name="name">
               Name of the parameter.
            </param>
            <param name="val">
               Value of the parameter.
            </param>
            <returns>
               False if the param was not dealt with, True if it was.
            </returns>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgram.highLevelLoaded">
            <summary>
               Whether the high-level program (and it's parameter defs) is loaded.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgram.assemblerProgram">
            <summary>
               The underlying assembler program.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.LoadHighLevel">
            <summary>
               Internal load high-level portion if not loaded
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.LoadHighLevelImpl">
            <summary>
            Internal load implementation, loads just the high-level portion, enough to 
            get parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.UnloadHighLevel">
            <summary>
            Internal unload high-level portion if loaded
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.CreateLowLevelImpl">
            <summary>
               Internal method for creating an appropriate low-level program from this
               high-level program, must be implemented by subclasses.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.UnloadHighLevelImpl">
            <summary>
               Internal unload implementation, must be implemented by subclasses.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.PopulateParameterNames(Axiom.Graphics.GpuProgramParameters)">
            <summary>
               Populate the passed parameters with name->index map, must be overridden.
            </summary>
            <param name="parms"></param>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.BuildConstantDefinitions">
            <summary>
            Build the constant definition map, must be overridden.
            </summary>
            <remarks>
            The implementation must fill in the (inherited) mConstantDefs field at a minimum, 
            and if the program requires that parameters are bound using logical 
            parameter indexes then the mFloatLogicalToPhysical and mIntLogicalToPhysical
            maps must also be populated.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.CreateParameters">
            <summary>
               Creates a new parameters object compatible with this program definition.
            </summary>
            <remarks>
               Unlike low-level assembly programs, parameters objects are specific to the
               program and therefore must be created from it rather than by the 
               HighLevelGpuProgramManager. This method creates a new instance of a parameters
               object containing the definition of the parameters this program understands.
            </remarks>
            <returns>A new set of program parameters.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.load">
            <summary>
               Implementation of Resource.load.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.unload">
            <summary>
               Implementation of Resource.unload.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.SetParam(System.String,System.String)">
            <summary>
               Must be implemented by subclasses.
            </summary>
            <param name="name"></param>
            <param name="val"></param>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgram.BindingDelegate">
            <summary>
               Gets the lowlevel assembler program based on this HighLevel program.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgram.NamedConstants">
            <summary>
            Override GpuProgram::getNamedConstants to ensure built
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HighLevelGpuProgramFactory">
            <summary>
               Interface definition for factories that create instances of HighLevelGpuProgram.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramFactory.CreateInstance(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <summary>
               Create method which needs to be implemented to return an
               instance of a HighLevelGpuProgram.
            </summary>
            <returns>
               A newly created instance of HighLevelGpuProgram.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramFactory.CreateInstance(System.String)">
            <summary>
            Creates an instance of a HighLevelGpuProgram
            </summary>
            <param name="name"></param>
            <returns></returns>
            <remarks>This method cannot be used to create an instance of a HighLevelGpuProgram use CreateInstance( ResourceManager creator, string name, ResourceHandle handle, string group, bool isManual, IManualResourceLoader loader ) instead.</remarks>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgramFactory.Language">
            <summary>
               Gets the name of the HLSL language that this factory creates programs for.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgramFactory.Type">
            <summary>
            For HighLevelGpuPrograms this simply returns the Language.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeListBuilder">
            <summary>
                General utility class for building edge lists for geometry.
            </summary>
            <remarks>
                You can add multiple sets of vertex and index data to build an edge list. 
                Edges will be built between the various sets as well as within sets; this allows 
                you to use a model which is built from multiple SubMeshes each using 
                separate index and (optionally) vertex data and still get the same connectivity 
                information. It's important to note that the indexes for the edge will be constrained
                to a single vertex buffer though (this is required in order to render the edge).
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.vertices">
            <summary>
            	List of common vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.edgeData">
            <summary>
            	Underlying edge data to use for building.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.uniqueEdges">
            <summary>
            	Unique edges, used to detect whether there are too many triangles on an edge
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.weldVertices">
            <summary>
            	Do we weld common vertices at all?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.weldVerticesAcrossVertexSets">
            <summary>
            	Should we treat coincident vertices from different vertex sets as one?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.weldVerticesAcrossIndexSets">
            <summary>
            	Should we treat coincident vertices referenced from different index sets as one?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.Build">
            <summary>
                Builds the edge information based on the information built up so far.
            </summary>
            <returns>All edge data from the vertex/index data recognized by the builder.</returns>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.BuildTrianglesEdges(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="indexSet"></param>
            <param name="vertexSet"></param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.CreateEdge(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="vertexSet"></param>
            <param name="triangleIndex"></param>
            <param name="vertexIndex0"></param>
            <param name="vertexIndex1"></param>
            <param name="sharedVertIndex0"></param>
            <param name="sharedVertIndex1"></param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.ConnectEdges">
            <summary>
                
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.FindEdge(System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="sharedIndex1"></param>
            <param name="sharedIndex2"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.FindOrCreateCommonVertex(Axiom.Math.Vector3,System.Int32,System.Int32,System.Int32)">
            <summary>
            	Finds an existing common vertex, or inserts a new one.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.EdgeListBuilder.CommonVertex">
            <summary>
                A vertex can actually represent several vertices in the final model, because
                vertices along texture seams etc will have been duplicated. In order to properly
                evaluate the surface properties, a single common vertex is used for these duplicates,
                and the faces hold the detail of the duplicated vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.position">
            <summary>
                Location of point in euclidean space.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.index">
            <summary>
                Place of vertex in original vertex set.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.vertexSet">
            <summary>
                 The vertex set this came from.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.indexSet">
            <summary>
                The index set this was referenced (first) from.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.originalIndex">
            <summary>
                Place of vertex in original vertex set.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneQueryResult">
            <summary>
            	Holds the results of a single scene query.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryResult.objects">
            <summary>
            	List of scene objects in the query (entities, particle systems etc).
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryResult.worldFragments">
            <summary>
            	List of world fragments.
            </summary>
        </member>
        <member name="T:Axiom.Core.RaySceneQueryResultEntry">
            <summary>
            	This struct allows a single comparison of result data no matter what the type.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQueryResultEntry.Distance">
            <summary>
            	Distance along the ray.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQueryResultEntry.SceneObject">
            <summary>
            	The object, or null if this is not a scene object result.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQueryResultEntry.worldFragment">
            <summary>
            	The world fragment, or null if this is not a fragment result.
            </summary>
        </member>
        <member name="M:Axiom.Core.RaySceneQueryResultEntry.CompareTo(System.Object)">
            <summary>
            	Implemented to allow sorting of results based on distance.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.IntersectionSceneQueryResult">
            <summary>Holds the results of an intersection scene query (pair values).</summary>
        </member>
        <member name="T:Axiom.Core.LogListenerEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.LogListenerEventArgs.#ctor(System.String,Axiom.Core.LogMessageLevel,System.Boolean,System.String)">
            <summary>
            This is called whenever the log recieves a message and is about to write it out
            </summary>
            <param name="message">The message to be logged</param>
            <param name="lml">The message level the log is using</param>
            <param name="maskDebug">If we are printing to the console or not</param>
            <param name="logName">the name of this log (so you can have several listeners for different logs, and identify them)</param>
        </member>
        <member name="P:Axiom.Core.LogListenerEventArgs.Message">
            <summary>
            The message to be logged
            </summary>
        </member>
        <member name="P:Axiom.Core.LogListenerEventArgs.Level">
            <summary>
            The message level the log is using
            </summary>
        </member>
        <member name="P:Axiom.Core.LogListenerEventArgs.MaskDebug">
            <summary>
            If we are printing to the console or not
            </summary>
        </member>
        <member name="P:Axiom.Core.LogListenerEventArgs.LogName">
            <summary>
            the name of this log (so you can have several listeners for different logs, and identify them)
            </summary>
        </member>
        <member name="T:Axiom.Core.Log">
            <summary>
                Log class for writing debug/log data to files.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.LogThreshold">
            <summary>
                LogMessageLevel + LoggingLevel > LOG_THRESHOLD = message logged.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.log">
            <summary>
                File stream used for kepping the log file open.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.writer">
            <summary>
                Writer used for writing to the log file.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.logLevel">
            <summary>
                Level of detail for this log.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.debugOutput">
            <summary>
                Debug output enabled?
            </summary>
        </member>
        <member name="F:Axiom.Core.Log._isDisposed">
            <summary>
            	flag to indicate object already disposed.
            </summary>
        </member>
        <member name="M:Axiom.Core.Log.#ctor(System.String)">
            <summary>
                Constructor.  Creates a log file that also logs debug output.
            </summary>
            <param name="fileName">Name of the log file to open.</param>
        </member>
        <member name="M:Axiom.Core.Log.#ctor(System.String,System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="fileName">Name of the log file to open.</param>
            <param name="debugOutput">Write log messages to the debug output?</param>
        </member>
        <member name="M:Axiom.Core.Log.Write(System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.Log.Write(System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.Log.Write(Axiom.Core.LogMessageLevel,System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <param name="level">Importance of this logged message.</param>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.Log.Dispose">
            <summary>
                Called to dispose of this objects resources.
            </summary>
            <remarks>
                For the log, closes any open file streams and file writers.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Log.LogDetail">
            <summary>
                Gets/Sets the level of the detail for this log.
            </summary>
            <value></value>
        </member>
        <member name="T:Axiom.Core.ITimer">
            <summary>
            	Describes the interface for a platform independent timer.
            </summary>
        </member>
        <member name="M:Axiom.Core.ITimer.Reset">
            <summary>
            	Resets this timer.
            </summary>
            <remarks>
            	This must be called first before using the timer.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ITimer.Microseconds">
            <summary>
            	Returns microseconds since initialization or last reset.
            </summary>
        </member>
        <member name="P:Axiom.Core.ITimer.Milliseconds">
            <summary>
            	Returns milliseconds since initialization or last reset.
            </summary>
        </member>
        <member name="T:Axiom.Collections.BillboardSetCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.BillboardSet">BillboardSets</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorScriptLoader.CompositorScriptSection">
            <summary>
            	Enum to identify compositor sections.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorScriptLoader.CompositorScriptContext">
            <summary>
            	Struct for holding the script context while parsing.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositionTechnique">
            <summary>
             Base composition technique, can be subclassed in plugins.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.textureDefinitions">
            <summary>
            local texture definitions.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.targetPasses">
            <summary>
            Intermediate target passes
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.outputTarget">
            <summary>
            Output target pass (can be only one)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.schemeName">
            <summary>
            Optional scheme name
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.compositorLogicName">
            <summary>
            Optional compositor logic name
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.parent">
            <summary>
            Parent compositor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.#ctor(Axiom.Graphics.Compositor)">
            <summary>
            Create's a new Composition technique
            </summary>
            <param name="parent">parent of this technique</param>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.CreateTextureDefinition(System.String)">
            <summary>
            Create a new local texture definition, and return a pointer to it.
            </summary>
            <param name="name">name of the local texture</param>
            <returns>pointer to a texture definition</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.RemoveTextureDefinition(System.Int32)">
            <summary>
            Remove and destroy a local texture definition.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.GetTextureDefinition(System.Int32)">
            <summary>
            Get's a local texture definition by index.
            </summary>
            <param name="index">index of the texture definition</param>
            <returns>texture definition for the given index</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.GetTextureDefinition(System.String)">
            <summary>
            Get's a local texture definition by name.
            </summary>
            <param name="name">name of the texture definition</param>
            <returns>texture definition for the given name.if noone exists, null</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.RemoveAllTextureDefinitions">
            <summary>
            Remove's all texture definitions.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.CreateTargetPass">
            <summary>
            Create's a new target pass.
            </summary>
            <returns>pointer to a new target pass</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.RemoveTargetPass(System.Int32)">
            <summary>
            Remove's and destroys a target pass.
            </summary>
            <param name="index">index of the target pass to remove to.</param>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.GetTargetPass(System.Int32)">
            <summary>
            Get's a target passs by index.
            </summary>
            <param name="index">index of the target pass</param>
            <returns>target pass for the given index</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.RemoveAllTargetPasses">
            <summary>
            Remove's all target passes from this technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.IsSupported(System.Boolean)">
            <summary>
            Determine if this technique is supported on the current rendering device.
            </summary>
            <param name="allowTextureDegradation">True to accept a reduction in texture depth</param>
            <returns>true if supported, otherwise false</returns>
            <remarks>
            A technique is supported if all materials referenced have a supported
            technique, and the intermediate texture formats requested are supported
            Material support is a cast-iron requirement, but if no texture formats
            are directly supported we can let the rendersystem create the closest
            match for the least demanding technique
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinitions">
            <summary>
            Get's a list of all texture definitions.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TargetPasses">
            <summary>
            Get's a list of all target passes of this technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.OutputTarget">
            <summary>
            Get's the output (final) target pass.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.SchemeName">
            <summary>
            Get's or set's a scheme name for this technique,
            used to switch between multiple techniques by choice,
            rather than for hardware compatibility.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.CompositorLogicName">
            <summary>
            Get's or set's the logic name, assigned to this technique.
            Instances if this technique will be auto-coupled with the matching logic.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.Parent">
            <summary>
            Get's the parent of this technique.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositionTechnique.TextureScope">
            <summary>
             The scope of a texture defined by the compositor.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.TextureScope.Local">
            <summary>
             Local texture - only available to the compositor passes in this technique
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.TextureScope.Chain">
            <summary>
             Chain texture - available to the other compositors in the chain
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionTechnique.TextureScope.Global">
            <summary>
             Global texture - available to everyone in every scope
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositionTechnique.TextureDefinition">
            <summary>
             Local texture definitions
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionTechnique.TextureDefinition.#ctor">
            <summary>
            Creates a new local texture definition.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.Name">
            <summary>
             Name of the texture definition.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.ReferenceCompositorName">
            <summary>
            If a reference, the name of the compositor being referenced
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.ReferenceTextureName">
            <summary>
            If a reference, the name of the texture in the compositor being referenced
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.Width">
            <summary>
            0 means adapt to target width
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.Height">
            <summary>
            0 means adapt to target height
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.WidthFactor">
            <summary>
            multiple of target width to use (if width = 0)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.HeightFactor">
            <summary>
            multiple of target height to use (if height = 0)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.PixelFormats">
            <summary>
            more than one means MRT
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.Fsaa">
            <summary>
            FSAA enabled; 
            true = determine from main target (if render_scene), false = disable
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.HwGammaWrite">
            <summary>
            Do sRGB gamma correction on write (only 8-bit per channel formats)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.DepthBufferId">
            <summary>
            Depth Buffer's pool ID. (unrelated to "pool" variable below)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.Pooled">
            <summary>
            whether to use pooled textures for this one
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionTechnique.TextureDefinition.Scope">
            <summary>
            Which scope has access to this texture
            </summary>
        </member>
        <member name="T:Axiom.Fonts.MemoryRec_">
            <summary>
                FreeType 2 Binding for .NET
            </summary>
            <remarks>
                <para>
                    Binds functions and definitions in 
                    freetype6.dll (Windows)
                    /usr/lib/libfreetype.so.6 (Linux - specifically Fedora Core freetype install location)
                    /Library/Frameworks/Mono.framework/Libraries/libfreetype.6.dylib (MacOSX)
                </para>
                <para>
                    The FreeType library includes the base data types and function calls to FreeType 2
                    to allow access to TrueType and OpenType fonts across platforms.
                </para>
                <para>
                    This is not a rendering utility and will not render fonts to the screen. It is an interface
                    to the various font formats, and can provide either outline or bitmapped versions
                    of font glyphs.
                </para>    
            </remarks>
        </member>
        <member name="F:Axiom.Fonts.MemoryRec_.user">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.MemoryRec_.alloc">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.MemoryRec_.free">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.MemoryRec_.realloc">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_StreamRec">
            <summary>
            A structure used to describe an input stream.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec._base">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.pos">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.descriptor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.pathname">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.read">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.close">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.cursor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamRec.limit">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_StreamDesc">
            <summary>
            A union type used to store either a long or a pointer. This is used to store a file descriptor or a FILE* in an input stream
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamDesc._value">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_StreamDesc.pointer">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Vector">
            <summary>
            A simple structure used to store a 2D vector; coordinates are of the FT_Pos type.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Vector.x">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Vector.y">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_BBox">
            <summary>
            A structure used to hold an outline's bounding box, i.e., the coordinates of its extrema in the horizontal and vertical directions.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_BBox.xMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_BBox.yMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_BBox.xMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_BBox.yMax">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Bitmap">
            <summary>
            A structure used to describe a bitmap or pixmap to the raster. Note that we now manage pixmaps of various depths through the pixel_mode field.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.rows">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.width">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.pitch">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.num_grays">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.pixel_mode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.palette_mode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap.palette">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Outline">
            <summary>
            This structure is used to describe an outline to the scan-line converter.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline.n_contours">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline.n_points">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline.points">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline.tags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline.contours">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline.flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Outline_Funcs">
            <summary>
            A structure to hold various function pointers used during outline decomposition in order to emit segments, conic, and cubic Bziers, as well as move to and close to operations.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline_Funcs.move_to">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline_Funcs.line_to">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline_Funcs.conic_to">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline_Funcs.cubic_to">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline_Funcs.shift">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Outline_Funcs.delta">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.RasterRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Span">
            <summary>
            A structure used to model a single span of gray (or black) pixels when rendering a monochrome or anti-aliased bitmap
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Span.x">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Span.len">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Span.coverage">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Raster_Params">
            <summary>
            A structure to hold the arguments used by a raster's render functions
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.target">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.source">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.gray_spans">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.black_spans">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.bit_test">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.bit_set">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.user">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Params.clip_box">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Raster_Funcs">
            <summary>
            A structure used to describe a given raster class to the library.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Funcs.glyph_format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Funcs.raster_new">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Funcs.raster_reset">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Funcs.raster_set_mode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Funcs.raster_render">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Raster_Funcs.raster_done">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_UnitVector">
            <summary>
            A simple structure used to store a 2D vector unit vector.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_UnitVector.x">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_UnitVector.y">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Matrix">
            <summary>
            A simple structure used to store a 2x2 matrix. Coefficients are in 16.16 fixed float format. The computation performed is:
            x' = x*xx + y*xy                                             
            y' = x*yx + y*yy   
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Matrix.xx">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Matrix.xy">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Matrix.yx">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Matrix.yy">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Data">
            <summary>
            Read-only binary data represented as a pointer and a length.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Data.pointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Data.length">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Generic">
            <summary>
            Client applications often need to associate their own data to a variety of FreeType core objects. For example, a text layout API might want to associate a glyph cache to a given size object.
            Most FreeType object contains a generic field, of type FT_Generic, which usage is left to client applications and font servers.
            It can be used to store a pointer to client-specific data, as well as the address of a finalizer function, which will be called by FreeType when the object is destroyed (for example, the previous client example would put the address of the glyph cache destructor in the finalizer field).
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Generic.data">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Generic.finalizer">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_ListNodeRec">
            <summary>
            A structure used to hold a single list element.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_ListNodeRec.prev">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_ListNodeRec.next">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_ListNodeRec.data">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_ListRec">
            <summary>
            A structure used to hold a simple double-linked list. These are used in many parts of FreeType.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_ListRec.head">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_ListRec.tail">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Glyph_Metrics">
            <summary>
            A structure used to model the metrics of a single glyph. The values are expressed in 26.6 fractional pixel format; if the flag FT_LOAD_NO_SCALE has been used while loading the glyph, values are expressed in font units instead.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.width">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.horiBearingX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.horiBearingY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.horiAdvance">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.vertBearingX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.vertBearingY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Metrics.vertAdvance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Bitmap_Size">
            <summary>
            This structure models the metrics of a bitmap strike (i.e., a set of glyphs for a given point size and resolution) in a bitmap font. It is used for the available_sizes field of FT_Face.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap_Size.height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap_Size.width">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap_Size.size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap_Size.x_ppem">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Bitmap_Size.y_ppem">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.LibraryRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.ModuleRec_">
            <summary>
            /
            </summary>
        </member>
        <member name="T:Axiom.Fonts.DriverRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.RendererRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_FaceRec">
            <summary>
            FreeType root face class structure. A face object models a typeface in a font file.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.num_faces">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.face_index">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.face_flags">
            <summary>
            /
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.style_flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.num_glyphs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.family_name">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.style_name">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.num_fixed_sizes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.available_sizes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.num_charmaps">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.charmaps">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.generic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.bbox">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.units_per_EM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.ascender">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.descender">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.max_advance_width">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.max_advance_height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.underline_position">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.underline_thickness">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.glyph">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.charmap">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.driver">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.stream">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.sizes_list">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.autohint">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec.extensions">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_FaceRec._internal">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_SizeRec">
            <summary>
            FreeType root size class structure. A size object models a face object at a given size.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_SizeRec.face">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_SizeRec.generic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_SizeRec.metrics">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_SizeRec._internal">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_GlyphSlotRec">
            <summary>
            FreeType root glyph slot class structure. A glyph slot is a container where individual glyphs can be loaded, be they in outline or bitmap format.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.library">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.face">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.next">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.reserved">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.generic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.metrics">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.linearHoriAdvance">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.linearVertAdvance">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.advance">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.bitmap">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.bitmap_left">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.bitmap_top">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.outline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.num_subglyphs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.subglyphs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.control_data">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.control_len">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.lsb_delta">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.rsb_delta">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec.other">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_GlyphSlotRec._internal">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_CharMapRec">
            <summary>
            The base charmap structure.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_CharMapRec.face">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_CharMapRec.encoding">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_CharMapRec.platform_id">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_CharMapRec.encoding_id">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.Face_InternalRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.Size_InternalRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Size_Metrics">
            <summary>
            The size metrics structure gives the metrics of a size object.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.x_ppem">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.y_ppem">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.x_scale">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.y_scale">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.ascender">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.descender">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Size_Metrics.max_advance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.SubGlyphRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.Slot_InternalRec_">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Parameter">
            <summary>
            A simple structure used to pass more or less generic parameters to FT_Open_Face.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Parameter.tag">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Parameter.data">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Open_Args">
            <summary>
            A structure used to indicate how to open a new font file or stream. A pointer to such a structure can be used as a parameter for the functions FT_Open_Face and FT_Attach_Stream.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.memory_base">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.memory_size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.pathname">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.stream">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.driver">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args.num_params">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Open_Args._params">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Pixel_Mode">
            <summary>
            An enumeration type used to describe the format of pixels in a given bitmap. Note that additional formats may be added in the future.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_NONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_MONO">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_GRAY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_GRAY2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_GRAY4">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_LCD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_LCD_V">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Pixel_Mode.FT_PIXEL_MODE_MAX">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Glyph_Format">
            <summary>
            An enumeration type used to describe the format of a given glyph image. Note that this version of FreeType only supports two image formats, even though future font drivers will be able to register their own format.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Format.FT_GLYPH_FORMAT_NONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Format.FT_GLYPH_FORMAT_COMPOSITE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Format.FT_GLYPH_FORMAT_BITMAP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Format.FT_GLYPH_FORMAT_OUTLINE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Glyph_Format.FT_GLYPH_FORMAT_PLOTTER">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Encoding">
            <summary>
            An enumeration used to specify character sets supported by charmaps. Used in the FT_Select_Charmap API function.
            note:
            Despite the name, this enumeration lists specific character repertories (i.e., charsets), and not text encoding methods (e.g., UTF-8, UTF-16, GB2312_EUC, etc.).
            Because of 32-bit charcodes defined in Unicode (i.e., surrogates), all character codes must be expressed as FT_Longs.
            Other encodings might be defined in the future.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_NONE">
            <summary>
            /
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_MS_SYMBOL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_UNICODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_SJIS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_GB2312">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_BIG5">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_WANSUNG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_JOHAB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_MS_SJIS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_MS_GB2312">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_MS_BIG5">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_MS_WANSUNG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_MS_JOHAB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_ADOBE_STANDARD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_ADOBE_EXPERT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_ADOBE_CUSTOM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_ADOBE_LATIN_1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_OLD_LATIN_2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Encoding.FT_ENCODING_APPLE_ROMAN">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Render_Mode">
            <summary>
            An enumeration type that lists the render modes supported by FreeType 2. Each mode corresponds to a specific type of scanline conversion performed on the outline.
            For bitmap fonts the bitmap->pixel_mode field in the FT_GlyphSlotRec structure gives the format of the returned bitmap.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Render_Mode.FT_RENDER_MODE_NORMAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Render_Mode.FT_RENDER_MODE_LIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Render_Mode.FT_RENDER_MODE_MONO">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Render_Mode.FT_RENDER_MODE_LCD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Render_Mode.FT_RENDER_MODE_LCD_V">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Render_Mode.FT_RENDER_MODE_MAX">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT_Kerning_Mode">
            <summary>
            An enumeration used to specify which kerning values to return in FT_Get_Kerning.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Kerning_Mode.FT_KERNING_DEFAULT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Kerning_Mode.FT_KERNING_UNFITTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT_Kerning_Mode.FT_KERNING_UNSCALED">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FT">
            <summary>
            Main FreeType method class. Call FT_Init_FreeType to initialise
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_NATIVE_LIBRARY">
            <summary>
            Specifies the FT native library used in the bindings
            </summary>
            <remarks>
            The Windows dll is specified here universally - note that
            under Mono the non-windows native library can be mapped using
            the ".config" file mechanism.  Kudos to the Mono team for this
            simple yet elegant solution.
            </remarks>
        </member>
        <member name="F:Axiom.Fonts.FT.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention used for the binding.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/>
                for the bindings.
            </remarks>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_open_driver">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_open_memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_open_params">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_open_pathname">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_open_stream">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_even_odd_fill">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_high_precision">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_ignore_dropouts">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_none">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_owner">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_reverse_fill">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_outline_single_pass">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_raster_flag_aa">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_raster_flag_clip">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_raster_flag_default">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ft_raster_flag_direct">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FREETYPE_MAJOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FREETYPE_MINOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FREETYPE_PATCH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ALIGNMENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Curve_Tag_Conic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Curve_Tag_Cubic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Curve_Tag_On">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Curve_Tag_Touch_X">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Curve_Tag_Touch_Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.CURVE_TAG_CONIC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.CURVE_TAG_CUBIC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.CURVE_TAG_ON">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.CURVE_TAG_TOUCH_X">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.CURVE_TAG_TOUCH_Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_CROP_BITMAP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_DEFAULT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_FORCE_AUTOHINT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_IGNORE_TRANSFORM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_LINEAR_DESIGN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_MONOCHROME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_NO_BITMAP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_NO_HINTING">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_NO_RECURSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_NO_SCALE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_PEDANTIC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_RENDER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_SBITS_ONLY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_LOAD_VERTICAL_LAYOUT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.MAX_MODULES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OPEN_DRIVER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OPEN_MEMORY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OPEN_PARAMS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OPEN_PATHNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OPEN_STREAM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_EVEN_ODD_FILL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_HIGH_PRECISION">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_IGNORE_DROPOUTS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_NONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_OWNER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_REVERSE_FILL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_OUTLINE_SINGLE_PASS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_RASTER_FLAG_AA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_RASTER_FLAG_CLIP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_RASTER_FLAG_DEFAULT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.FT_RASTER_FLAG_DIRECT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.HAVE_FCNTL_H">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.HAVE_UNISTD_H">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.T1_MAX_CHARSTRINGS_OPERANDS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.T1_MAX_DICT_DEPTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.T1_MAX_SUBRS_CALLS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Base">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Autohint">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_BDF">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Cache">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_CFF">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_CID">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Gzip">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_LZW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_PCF">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_PFR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_PSaux">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_PShinter">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_PSnames">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Raster">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_SFNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Smooth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_TrueType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Type1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Type42">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Winfonts">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Mod_Err_Max">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Ok">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Cannot_Open_Resource">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Unknown_File_Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_File_Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Lower_Module_Version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Argument">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Unimplemented_Feature">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Table">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Glyph_Index">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Character_Code">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Glyph_Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Cannot_Render_Glyph">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Outline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Composite">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Many_Hints">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Pixel_Size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Library_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Driver_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Face_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Size_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Slot_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_CharMap_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Cache_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Stream_Handle">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Many_Drivers">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Many_Extensions">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Out_Of_Memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Unlisted_Object">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Cannot_Open_Stream">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Stream_Seek">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Stream_Skip">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Stream_Read">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Stream_Operation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Frame_Operation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Nested_Frame_Access">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Frame_Read">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Raster_Uninitialized">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Raster_Corrupted">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Raster_Overflow">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Raster_Negative_Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Many_Caches">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Opcode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Few_Arguments">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Stack_Overflow">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Code_Overflow">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Bad_Argument">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Divide_By_Zero">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Reference">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Debug_OpCode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_ENDF_In_Exec_Stream">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Nested_DEFS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_CodeRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Execution_Too_Long">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Many_Function_Defs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Too_Many_Instruction_Defs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Table_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Horiz_Header_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Locations_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Name_Table_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_CMap_Table_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Hmtx_Table_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Post_Table_Missing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Horiz_Metrics">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_CharMap_Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_PPem">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Vert_Metrics">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Could_Not_Find_Context">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Post_Table_Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Invalid_Post_Table">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Syntax_Error">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Stack_Underflow">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Ignore">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Startfont_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Font_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Size_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Chars_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Startchar_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Encoding_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.Err_Missing_Bbx_Field">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FT.ErrorStrings">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Init_FreeType(System.IntPtr@)">
            <summary>
            Initialize a new FreeType library object. The set of modules that are registered by this function is determined at build time.
            </summary>
            <param name="alibrary">A handle to a new library object.</param>
            <returns>FreeType error code. 0 means success.</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Library_Version(System.IntPtr,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return the version of the FreeType library being used. This is useful when dynamically linking to the library, since one cannot use the macros FREETYPE_MAJOR, FREETYPE_MINOR, and FREETYPE_PATCH.
            </summary>
            <param name="library">A source library handle.</param>
            <param name="amajor">The major version number.</param>
            <param name="aminor">The minor version number</param>
            <param name="apatch">The patch version number</param>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Done_FreeType(System.IntPtr)">
            <summary>
            Destroy a given FreeType library object and all of its children, including resources, drivers, faces, sizes, etc.
            </summary>
            <param name="library">A handle to the target library object</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_New_Face(System.IntPtr,System.String,System.Int32,System.IntPtr@)">
            <summary>
            This function calls FT_Open_Face to open a font by its pathname.
            </summary>
            <param name="library">A handle to the library resource.</param>
            <param name="filepathname">A path to the font file</param>
            <param name="face_index">The index of the face within the font. The first face has index 0</param>
            <param name="aface"> A handle to a new face object. If face_index is greater than or equal to zero, it must be non-NULL. See FT_Open_Face for more details.</param>
            <returns>FreeType error code. 0 means success.</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_New_Memory_Face(System.IntPtr,System.Byte[],System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            This function calls FT_Open_Face to open a font which has been loaded into memory.
            You must not deallocate the memory before calling FT_Done_Face.
            </summary>
            <param name="library">A handle to the library resource</param>
            <param name="file_base">A pointer to the beginning of the font data</param>
            <param name="file_size">The size of the memory chunk used by the font data</param>
            <param name="face_index">The index of the face within the font. The first face has index 0</param>
            <param name="aface">A handle to a new face object. If face_index is greater than or equal to zero, it must be non-NULL. See FT_Open_Face for more details.</param>
            <returns>FreeType error code. 0 means success.</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Open_Face(System.IntPtr,Axiom.Fonts.FT_Open_Args,System.Int32,System.IntPtr)">
            <summary>
            Create a face object from a given resource described by FT_Open_Args.
            Unlike FreeType 1.x, this function automatically creates a glyph slot for the face object which can be accessed directly through face->glyph.
            FT_Open_Face can be used to quickly check whether the font format of a given font resource is supported by FreeType. If the face_index field is negative, the function's return value is 0 if the font format is recognized, or non-zero otherwise; the function returns a more or less empty face handle in *aface (if aface isn't NULL). The only useful field in this special case is face->num_faces which gives the number of faces within the font file. After examination, the returned FT_Face structure should be deallocated with a call to FT_Done_Face.
            Each new face object created with this function also owns a default FT_Size object, accessible as face->size.
            </summary>
            <param name="library">A handle to the library resource</param>
            <param name="args">A pointer to an FT_Open_Args structure which must be filled by the caller.</param>
            <param name="face_index">The index of the face within the font. The first face has index 0</param>
            <param name="aface">A handle to a new face object. If face_index is greater than or equal to zero, it must be non-NULL. See note below</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Attach_File(System.IntPtr,System.String)">
            <summary>
            This function calls FT_Attach_Stream to attach a file.
            </summary>
            <param name="face">The target face object.</param>
            <param name="filepathname">The pathname</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Attach_Stream(System.IntPtr,Axiom.Fonts.FT_Open_Args@)">
            <summary>
            Attach data to a face object. Normally, this is used to read additional information for the face object. For example, you can attach an AFM file that comes with a Type 1 font to get the kerning values and other metrics
            </summary>
            <param name="face">The target face object</param>
            <param name="parameters">A pointer to FT_Open_Args which must be filled by the caller</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Done_Face(System.IntPtr)">
            <summary>
            Discard a given face object, as well as all of its child slots and sizes.
            </summary>
            <param name="face">A handle to a target face object.</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Set_Char_Size(System.IntPtr,System.Int32,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            This function calls FT_Request_Size to request the nominal size (in points).
            If either the character width or height is zero, it is set equal to the other value.
            If either the horizontal or vertical resolution is zero, it is set equal to the other value.
            A character width or height smaller than 1pt is set to 1pt; if both resolution values are zero, they are set to 72dpi.
            </summary>
            <param name="face">A handle to a target face object</param>
            <param name="char_width">The nominal width, in 26.6 fractional points</param>
            <param name="char_height">The nominal height, in 26.6 fractional points</param>
            <param name="horz_resolution">The horizontal resolution in dpi</param>
            <param name="vert_resolution">The vertical resolution in dpi</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Set_Pixel_Sizes(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            This function calls FT_Request_Size to request the nominal size (in pixels).
            </summary>
            <param name="face">A handle to the target face object.</param>
            <param name="pixel_width">The nominal width, in pixels.</param>
            <param name="pixel_height">The nominal height, in pixels</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Load_Glyph(System.IntPtr,System.UInt32,System.Int32)">
            <summary>
            A function used to load a single glyph into the glyph slot of a face object.
            The loaded glyph may be transformed. See FT_Set_Transform for the details.
            </summary>
            <param name="face">A handle to the target face object where the glyph is loaded.</param>
            <param name="glyph_index">The index of the glyph in the font file. For CID-keyed fonts (either in PS or in CFF format) this argument specifies the CID value.</param>
            <param name="load_flags">A flag indicating what to load for this glyph. The FT_LOAD_XXX constants can be used to control the glyph loading process (e.g., whether the outline should be scaled, whether to load bitmaps or not, whether to hint the outline, etc).</param>
            <returns>FreeType error code. 0 means success.</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Load_Char(System.IntPtr,System.UInt32,System.Int32)">
            <summary>
            A function used to load a single glyph into the glyph slot of a face object, according to its character code.
            This function simply calls FT_Get_Char_Index and FT_Load_Glyph.
            </summary>
            <param name="face">A handle to a target face object where the glyph is loaded.</param>
            <param name="char_code">The glyph's character code, according to the current charmap used in the face</param>
            <param name="load_flags">A flag indicating what to load for this glyph. The FT_LOAD_XXX constants can be used to control the glyph loading process (e.g., whether the outline should be scaled, whether to load bitmaps or not, whether to hint the outline, etc).</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Set_Transform(System.IntPtr,Axiom.Fonts.FT_Matrix@,Axiom.Fonts.FT_Vector@)">
            <summary>
            A function used to set the transformation that is applied to glyph images when they are loaded into a glyph slot through FT_Load_Glyph.
            The transformation is only applied to scalable image formats after the glyph has been loaded. It means that hinting is unaltered by the transformation and is performed on the character size given in the last call to FT_Set_Char_Size or FT_Set_Pixel_Sizes.
            Note that this also transforms the face.glyph.advance field, but not the values in face.glyph.metrics
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="matrix">A pointer to the transformation's 2x2 matrix. Use 0 for the identity matrix</param>
            <param name="delta">A pointer to the translation vector. Use 0 for the null vector</param>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Render_Glyph(Axiom.Fonts.FT_GlyphSlotRec@,Axiom.Fonts.FT_Render_Mode)">
            <summary>
            Convert a given glyph image to a bitmap. It does so by inspecting the glyph image format, finding the relevant renderer, and invoking it
            </summary>
            <param name="slot">A handle to the glyph slot containing the image to convert</param>
            <param name="render_mode">This is the render mode used to render the glyph image into a bitmap. See FT_Render_Mode for a list of possible values</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Kerning(System.IntPtr,System.UInt32,System.UInt32,System.UInt32,Axiom.Fonts.FT_Vector@)">
            <summary>
            Return the kerning vector between two glyphs of a same face
            </summary>
            <param name="face">A handle to a source face object</param>
            <param name="left_glyph">The index of the left glyph in the kern pair</param>
            <param name="right_glyph">The index of the right glyph in the kern pair</param>
            <param name="kern_mode">See FT_Kerning_Mode for more information. Determines the scale and dimension of the returned kerning vector</param>
            <param name="akerning">The kerning vector. This is either in font units or in pixels (26.6 format) for scalable formats, and in pixels for fixed-sizes formats</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Glyph_Name(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>
            Retrieve the UTF8 name of a given glyph in a face. This only works for those faces where FT_HAS_GLYPH_NAMES(face) returns 1
            An error is returned if the face doesn't provide glyph names or if the glyph index is invalid. In all cases of failure, the first byte of buffer is set to 0 to indicate an empty name.
            The glyph name is truncated to fit within the buffer if it is too long. The returned string is always zero-terminated.
            This function is not compiled within the library if the config macro FT_CONFIG_OPTION_NO_GLYPH_NAMES is defined in include/freetype/config/ftoptions.h
            </summary>
            <param name="face">A handle to a source face object</param>
            <param name="glyph_index">The glyph index</param>
            <param name="buffer">A pointer to a target buffer where the name is copied to</param>
            <param name="buffer_max">The maximal number of bytes available in the buffer</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Postscript_Name(System.IntPtr)">
            <summary>
            Retrieve the UTF8 Postscript name of a given face, if available. This only works with Postscript and TrueType fonts
            The returned pointer is owned by the face and is destroyed with it
            </summary>
            <param name="face">A handle to the source face object</param>
            <returns>A pointer to the face's Postscript name. NULL if unavailable</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Select_Charmap(System.IntPtr,Axiom.Fonts.FT_Encoding)">
            <summary>
            Select a given charmap by its encoding tag (as listed in freetype.h).
            This function returns an error if no charmap in the face corresponds to the encoding queried here.
            Because many fonts contain more than a single cmap for Unicode encoding, this function has some special code to select the one which covers Unicode best. It is thus preferable to FT_Set_Charmap in this case
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="encoding">A handle to the selected encoding</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Set_Charmap(System.IntPtr,Axiom.Fonts.FT_CharMapRec@)">
            <summary>
            Select a given charmap for character code to glyph index mapping
            This function returns an error if the charmap is not part of the face (i.e., if it is not listed in the face->charmaps table)
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="charmap">A handle to the selected charmap</param>
            <returns>FreeType error code. 0 means success</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Charmap_Index(Axiom.Fonts.FT_CharMapRec@)">
            <summary>
            Retrieve index of a given charmap
            </summary>
            <param name="charmap">A handle to a charmap</param>
            <returns>The index into the array of character maps within the face to which charmap belongs</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Char_Index(System.IntPtr,System.UInt32)">
            <summary>
            Return the glyph index of a given character code. This function uses a charmap object to do the mapping
            If you use FreeType to manipulate the contents of font files directly, be aware that the glyph index returned by this function doesn't always correspond to the internal indices used within the file. This is done to ensure that value 0 always corresponds to the missing glyph.
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="charcode">The character code</param>
            <returns>The glyph index. 0 means undefined character code</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_First_Char(System.IntPtr,System.UInt32[])">
            <summary>
            This function is used to return the first character code in the current charmap of a given face. It also returns the corresponding glyph index.
            You should use this function with FT_Get_Next_Char to be able to parse all character codes available in a given charmap.
            Note that agindex is set to 0 if the charmap is empty. The result itself can be 0 in two cases: if the charmap is empty or when the value 0 is the first valid character code
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="agindex">Glyph index of first character code. 0 if charmap is empty</param>
            <returns>The charmap's first character code</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Next_Char(System.IntPtr,System.UInt32,System.UInt32[])">
            <summary>
            This function is used to return the next character code in the current charmap of a given face following the value char_code, as well as the corresponding glyph index.
            You should use this function with FT_Get_First_Char to walk over all character codes available in a given charmap. See the note for this function for a simple code example.
            Note that *agindex is set to 0 when there are no more codes in the charmap.
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="char_code">The starting character code</param>
            <param name="agindex">Glyph index of first character code. 0 if charmap is empty</param>
            <returns>The charmap's next character code</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Get_Name_Index(System.IntPtr,System.SByte[])">
            <summary>
            Return the glyph index of a given glyph name. This function uses driver specific objects to do the translation
            </summary>
            <param name="face">A handle to the source face object</param>
            <param name="glyph_name">The glyph name</param>
            <returns>The glyph index. 0 means undefined character code</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_MulDiv(System.Int32,System.Int32,System.Int32)">
            <summary>
            A very simple function used to perform the computation (a*b)/c with maximal accuracy (it uses a 64-bit intermediate integer whenever necessary).
            This function isn't necessarily as fast as some processor specific operations, but is at least completely portable.
            </summary>
            <param name="a">The first multiplier</param>
            <param name="b">The second multiplier</param>
            <param name="c">The divisor</param>
            <returns>The result of (a*b)/c. This function never traps when trying to divide by zero; it simply returns MaxInt or MinInt depending on the signs of a and b</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_MulFix(System.Int32,System.Int32)">
            <summary>
            A very simple function used to perform the computation (a*b)/0x10000 with maximal accuracy. Most of the time this is used to multiply a given value by a 16.16 fixed float factor
            This function has been optimized for the case where the absolute value of a is less than 2048, and b is a 16.16 scaling factor. As this happens mainly when scaling from notional units to fractional pixels in FreeType, it resulted in noticeable speed improvements between versions 2.x and 1.x.
            As a conclusion, always try to place a 16.16 factor as the second argument of this function; this can make a great difference
            </summary>
            <param name="a">The first multiplier</param>
            <param name="b">The second multiplier. Use a 16.16 factor here whenever possible</param>
            <returns>The result of (a*b)/0x10000</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_DivFix(System.Int32,System.Int32)">
            <summary>
            A very simple function used to perform the computation (a*0x10000)/b with maximal accuracy. Most of the time, this is used to divide a given value by a 16.16 fixed float factor
            The optimization for FT_DivFix() is simple: If (a &lt;&lt; 16) fits in 32 bits, then the division is computed directly. Otherwise, we use a specialized version of FT_MulDiv
            </summary>
            <param name="a">The first multiplier</param>
            <param name="b">The second multiplier. Use a 16.16 factor here whenever possible</param>
            <returns>The result of (a*0x10000)/b</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_RoundFix(System.Int32)">
            <summary>
            A very simple function used to round a 16.16 fixed number
            </summary>
            <param name="a">The number to be rounded</param>
            <returns>The result of (a + 0x8000) &amp; -0x10000</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_CeilFix(System.Int32)">
            <summary>
            A very simple function used to compute the ceiling function of a 16.16 fixed number
            </summary>
            <param name="a">The number for which the ceiling function is to be computed</param>
            <returns>The result of (a + 0x10000 - 1) &amp;-0x10000</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_FloorFix(System.Int32)">
            <summary>
            A very simple function used to compute the floor function of a 16.16 fixed number
            </summary>
            <param name="a">The number for which the floor function is to be computed</param>
            <returns>The result of a &amp; -0x10000</returns>
        </member>
        <member name="M:Axiom.Fonts.FT.FT_Vector_Transform(Axiom.Fonts.FT_Vector@,Axiom.Fonts.FT_Matrix@)">
            <summary>
            Transform a single vector through a 2x2 matrix.  
            The result is undefined if either vector or matrix is invalid 
            </summary>
            <param name="vec">The target vector to transform</param>
            <param name="matrix">A pointer to the source 2x2 matrix</param>
        </member>
        <member name="T:Axiom.Core.StaticGeometry">
            <summary>
                Pre-transforms and batches up meshes for efficient use as static geometry in a scene.
            </summary>
            <remarks>
            Modern graphics cards (GPUs) prefer to receive geometry in large
            batches. It is orders of magnitude faster to render 10 batches
            of 10,000 triangles than it is to render 10,000 batches of 10
            triangles, even though both result in the same number of on-screen
            triangles.
            <br/>
            Therefore it is important when you are rendering a lot of geometry to
            batch things up into as few rendering calls as possible. This
            class allows you to build a batched object from a series of entities
            in order to benefit from this behaviour.
            Batching has implications of it's own though:
            <ul>
            <li> Batched geometry cannot be subdivided; that means that the whole
            	group will be displayed, or none of it will. This obivously has
            	culling issues.</li>l
            <li> A single world transform must apply to the entire batch. Therefore
            	once you have batched things, you can't move them around relative to
            	each other. That's why this class is most useful when dealing with
            	static geometry (hence the name). In addition, geometry is
            	effectively duplicated, so if you add 3 entities based on the same
            	mesh in different positions, they will use 3 times the geometry
            	space than the movable version (which re-uses the same geometry).
            	So you trade memory	and flexibility of movement for pure speed when
            	using this class.</li>l
            <li> A single material must apply for each batch. In fact this class
            	allows you to use multiple materials, but you should be aware that
            	internally this means that there is one batch per material.
            	Therefore you won't gain as much benefit from the batching if you
            	use many different materials; try to keep the number down.</li>l
            </ul>
            <br/>
            In order to retain some sort of culling, this class will batch up
            meshes in localised regions. The size and shape of these blocks is
            controlled by the SceneManager which constructs this object, since it
            makes sense to batch things up in the most appropriate way given the
            existing partitioning of the scene.
            <br/>
            The LOD settings of both the Mesh and the Materials used in
            constructing this static geometry will be respected. This means that
            if you use meshes/materials which have LOD, batches in the distance
            will have a lower polygon count or material detail to those in the
            foreground. Since each mesh might have different LOD distances, during
            build the furthest distance at each LOD level from all meshes
            in that region is used. This means all the LOD levels change at the
            same time, but at the furthest distance of any of them (so quality is
            not degraded). Be aware that using Mesh LOD in this class will
            further increase the memory required. Only generated LOD
            is supported for meshes.
            <br/>
            There are 2 ways you can add geometry to this class; you can add
            Entity objects directly with predetermined positions, scales and
            orientations, or you can add an entire SceneNode and it's subtree,
            including all the objects attached to it. Once you've added everthing
            you need to, you have to call build() the fix the geometry in place.
            <br/>
            This class is not a replacement for world geometry (see
            SceneManager.WorldGeometry). The single most efficient way to
            render large amounts of static geometry is to use a SceneManager which
            is specialised for dealing with that particular world structure.
            However, this class does provide you with a good 'halfway house'
            between generalised movable geometry (Entity) which works with all
            SceneManagers but isn't efficient when using very large numbers, and
            highly specialised world geometry which is extremely fast but not
            generic and typically requires custom world editors.
            <br/>
            You should not construct instances of this class directly; instead, call
            SceneManager.CreateStaticGeometry, which gives the SceneManager the
            option of providing you with a specialised version of this class if it
            wishes, and also handles the memory management for you like other
            classes.
            </remarks>
            Port started by jwace81
            OGRE Source File: http://cvs.sourceforge.net/viewcvs.py/ogre/ogrenew/OgreMain/src/OgreStaticGeometry.cpp?rev=1.22&amp;view=auto
            OGRE Header File: http://cvs.sourceforge.net/viewcvs.py/ogre/ogrenew/OgreMain/include/OgreStaticGeometry.h?rev=1.14&amp;view=auto
        </member>
        <member name="F:Axiom.Core.StaticGeometry.regionSize">
            <summary>
                This is the size of each dimension of a region; it can
                be set via a public property.  By default, set to 100 meters
            </summary>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.AddEntity(Axiom.Core.Entity,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
             <summary>
                 Adds an Entity to the static geometry.
             </summary>
             <remarks>
                 This method takes an existing Entity and adds its details to the
                 list of	elements to include when building. Note that the Entity
                 itself is not copied or referenced in this method; an Entity is
                 passed simply so that you can change the materials of attached
                 SubEntity objects if you want. You can add the same Entity
                 instance multiple times with different material settings
                 completely safely, and destroy the Entity before destroying
                 this StaticGeometry if you like. The Entity passed in is simply
                 used as a definition.
            
                 Note: Must be called before 'build'.
             </remarks>
             <param name="ent">The Entity to use as a definition (the Mesh and Materials</param>
             <param name="position">The world position at which to add this Entity</param>
             <param name="orientation">The world orientation at which to add this Entity</param>
             <param name="scale">The scale at which to add this entity</param>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.AddSceneNode(Axiom.Core.SceneNode)">
            <summary>
                Adds all the Entity objects attached to a SceneNode and all it's
                children to the static geometry.
            </summary>
            <remarks>
                This method performs just like addEntity, except it adds all the
                entities attached to an entire sub-tree to the geometry.
                The position / orientation / scale parameters are taken from the
                node structure instead of being specified manually.
            </remarks>
            <note>
                The SceneNode you pass in will not be automatically detached from
                it's parent, so if you have this node already attached to the scene
                graph, you will need to remove it if you wish to avoid the overhead
                of rendering <i>both</i> the original objects and their new static
                versions! We don't do this for you incase you are preparing this
                in advance and so don't want the originals detached yet.
            </note>
            <param name="node">Pointer to the node to use to provide a set of Entity templates</param>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.Build">
            <summary>
                Build the geometry.
            </summary>
            <remarks>
                Based on all the entities which have been added, and the batching
                options which have been set, this method constructs	the batched
                geometry structures required. The batches are added to the scene
                and will be rendered unless you specifically hide them.
            </remarks>
            <note>
                Once you have called this method, you can no longer add any more
                entities.
            </note>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.Destroy">
            <summary>
                Destroys all the built geometry state (reverse of build).
            </summary>
            <remarks>
                You can call build() again after this and it will pick up all the
                same entities / nodes you queued last time.
            </remarks>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.Reset">
            <summary>
                Clears any of the entities / nodes added to this geometry and
                destroys anything which has already been built.
            </summary>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.GeometryBucket">
            <summary>
                A GeometryBucket is a the lowest level bucket where geometry with
                the same vertex &amp; index format is stored. It also acts as the
                renderable.
            </summary>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.GeometryBucket.dispose(System.Boolean)">
            <summary>
                Dispose the hardware index and vertex buffers
            </summary>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.MaterialBucket">
            <summary>
            A MaterialBucket is a collection of smaller buckets with the same 
            Material (and implicitly the same LOD).
            </summary>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.MaterialBucket.dispose(System.Boolean)">
            <summary>
                Dispose the geometry buckets
            </summary>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.LODBucket">
            <summary>
            A LODBucket is a collection of smaller buckets with the same LOD.
            </summary>
            <remarks>
            LOD refers to Mesh LOD here. Material LOD can change separately
            at the next bucket down from this.
            </remarks>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.LODBucket.dispose(System.Boolean)">
            <summary>
                Dispose the material buckets
            </summary>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.Region">
            <summary>
            The details of a topological region which is the highest level of
            partitioning for this class.
            </summary>
            <remarks>
            The size &amp; shape of regions entirely depends on the SceneManager
            specific implementation. It is a MovableObject since it will be
            attached to a node based on the local centre - in practice it
            won't actually move (although in theory it could).
            </remarks>
        </member>
        <member name="M:Axiom.Core.StaticGeometry.Region.dispose(System.Boolean)">
            <summary>
                Remove the region from the scene graph
            </summary>
        </member>
        <member name="P:Axiom.Core.StaticGeometry.Region.TypeFlags">
            <summary>
            Get the 'type flags' for this <see cref="T:Axiom.Core.StaticGeometry.Region"/>.
            </summary>
            <seealso cref="P:Axiom.Core.MovableObject.TypeFlags"/>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.OptimisedSubMeshGeometry">
            <summary>
                Struct holding geometry optimised per SubMesh / LOD level, ready
                for copying to instances.
            </summary>
            <remarks>
                Since we're going to be duplicating geometry lots of times, it's
                far more important that we don't have redundant vertex data. If a
                SubMesh uses shared geometry, or we're looking at a lower LOD, not
                all the vertices are being referenced by faces on that submesh.
                Therefore to duplicate them, potentially hundreds or even thousands
                of times, would be extremely wasteful. Therefore, if a SubMesh at
                a given LOD has wastage, we create an optimised version of it's
                geometry which is ready for copying with no wastage.
            
                The hierarchy is:
                    StaticGeometry
                    Region
                    LODBucket
                    MaterialBucket
                    GeometryBucket
            
                GeometryBucket is the layer at which different meshes that
                share the same material are combined.
            </remarks>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.SubMeshLodGeometryLink">
            <summary>
                Saved link between SubMesh at a LOD and vertex/index data
                May point to original or optimised geometry
            </summary>
        </member>
        <member name="T:Axiom.Core.StaticGeometry.QueuedSubMesh">
            <summary>
                Structure recording a queued submesh for the build
            </summary>
        </member>
        <member name="F:Axiom.Core.StaticGeometry.QueuedSubMesh.geometryLodList">
            Link to LOD list of geometry, potentially optimised
        </member>
        <member name="T:Axiom.Core.StaticGeometry.QueuedGeometry">
            <summary>
                Structure recording a queued geometry for low level builds
            </summary>
        </member>
        <member name="T:Axiom.Core.ProgressiveMesh">
            <summary>
               Class for handling multiple levels of detail for a Mesh
            </summary>
            <remarks>
               This class reduces the complexity of the geometry it is given.
               This class is dedicated to reducing the number of triangles in a given mesh
               taking into account seams in both geometry and texture co-ordinates and meshes 
               which have multiple frames.
               <para/>
               The primary use for this is generating LOD versions of Mesh objects, but it can be
               used by any geometry provider. The only limitation at the moment is that the 
               provider uses a common vertex buffer for all LODs and one index buffer per LOD.
               Therefore at the moment this class can only handle indexed geometry.
               <para/>
               NB the interface of this class will certainly change when compiled vertex buffers are
               supported.
            </remarks>
        </member>
        <member name="F:Axiom.Core.ProgressiveMesh.workingDataList">
            Multiple copies, 1 per vertex buffer
        </member>
        <member name="F:Axiom.Core.ProgressiveMesh.worstCosts">
            The worst collapse cost from all vertex buffers for each vertex
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.#ctor(Axiom.Graphics.VertexData,Axiom.Graphics.IndexData)">
            <summary>
               Constructor, takes the geometry data and index buffer. 
            </summary>
            <remarks>
               DO NOT pass write-only, unshadowed buffers to this method! They will not
               work. Pass only shadowed buffers, or better yet perform mesh reduction as
               an offline process using DefaultHardwareBufferManager to manage vertex
               buffers in system memory.
            </remarks>
            <param name="vertexData"></param>
            <param name="indexData"></param>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.AddExtraVertexPositionBuffer(Axiom.Graphics.VertexData)">
            <summary>
               Adds an extra vertex position buffer. 
            </summary>
            <remarks>
               As well as the main vertex buffer, the client of this class may add extra versions
               of the vertex buffer which will also be taken into account when the cost of 
               simplifying the mesh is taken into account. This is because the cost of
               simplifying an animated mesh cannot be calculated from just the reference position,
               multiple positions needs to be assessed in order to find the best simplification option.
               <p/>
               DO NOT pass write-only, unshadowed buffers to this method! They will not
               work. Pass only shadowed buffers, or better yet perform mesh reduction as
               an offline process using DefaultHardwareBufferManager to manage vertex
               buffers in system memory.
            </remarks>
            <param name="vertexData">buffer Pointer to x/y/z buffer with vertex positions.
               The number of vertices must be the same as in the original GeometryData passed to the constructor.
            </param>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.Build(System.UInt16,System.Collections.Generic.List{Axiom.Graphics.IndexData},Axiom.Core.ProgressiveMesh.VertexReductionQuota,System.Single)">
            <summary>
               Builds the progressive mesh with the specified number of levels.
            </summary>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.AddWorkingData(Axiom.Graphics.VertexData,Axiom.Graphics.IndexData)">
            <summary>
               Internal method for building PMWorkingData from geometry data
            </summary>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.InitialiseEdgeCollapseCosts">
            Internal method for initialising the edge collapse costs
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.ComputeEdgeCollapseCost(Axiom.Core.ProgressiveMesh.PMVertex,Axiom.Core.ProgressiveMesh.PMVertex)">
            Internal calculation method for deriving a collapse cost  from u to v
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.ComputeEdgeCostAtVertexForBuffer(Axiom.Core.ProgressiveMesh.PMWorkingData,System.UInt32)">
            <summary>
               Internal method evaluates all collapse costs from this vertex and picks the lowest for a single buffer
            </summary>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.ComputeEdgeCostAtVertex(System.UInt32)">
            Internal method evaluates all collapse costs from this vertex for every buffer and returns the worst
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.ComputeAllCosts">
            Internal method to compute edge collapse costs for all buffers /
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.GetNextCollapser">
            Internal method for getting the index of next best vertex to collapse
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.BakeNewLOD(Axiom.Graphics.IndexData)">
            <summary>
               Internal method builds an new LOD based on the current state
            </summary>
            <param name="indexData">Index data which will have an index buffer created and initialized</param>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.Collapse(Axiom.Core.ProgressiveMesh.PMVertex)">
            <summary>
               Internal method, collapses vertex onto it's saved collapse target. 
            </summary>
            <remarks>
               This updates the working triangle list to drop a triangle and recalculates
               the edge collapse costs around the collapse target. 
               This also updates all the working vertex lists for the relevant buffer. 
            </remarks>
            <pram name="src">the collapser</pram>
        </member>
        <member name="T:Axiom.Core.ProgressiveMesh.PMFaceVertex">
            <summary>
               A vertex as used by a face. This records the index of the actual vertex which is used
               by the face, and a pointer to the common vertex used for surface evaluation.
            </summary>
        </member>
        <member name="T:Axiom.Core.ProgressiveMesh.PMTriangle">
            <summary>
               A triangle in the progressive mesh, holds extra info like face normal.
            </summary>
        </member>
        <member name="T:Axiom.Core.ProgressiveMesh.PMVertex">
            <summary>
               A vertex in the progressive mesh, holds info like collapse cost etc. 
               This vertex can actually represent several vertices in the final model, because
               vertices along texture seams etc will have been duplicated. In order to properly
               evaluate the surface properties, a single common vertex is used for these duplicates,
               and the faces hold the detail of the duplicated vertices.
            </summary>
        </member>
        <member name="M:Axiom.Core.ProgressiveMesh.PMVertex.SetDetails(Axiom.Math.Vector3,System.UInt32)">
            true if this vertex is on a model seam where vertices are duplicated
        </member>
        <member name="P:Axiom.Core.ProgressiveMesh.PMVertex.IsBorder">
            <summary>
               Determine if this vertex is on the edge of an open geometry patch
            </summary>
            <returns>tru if this vertex is on the edge of an open geometry patch</returns>
        </member>
        <member name="T:Axiom.Core.ManualObject">
             <summary>
                Class providing a much simplified interface to generating manual
                objects with custom geometry.
            
                Building one-off geometry objects manually usually requires getting
                down and dirty with the vertex buffer and vertex declaration API,
                which some people find a steep learning curve. This class gives you
                a simpler interface specifically for the purpose of building a
                3D object simply and quickly. Note that if you intend to instance your
                object you will still need to become familiar with the Mesh class.
            
                This class draws heavily on the interface for OpenGL
                immediate-mode (glBegin, glVertex, glNormal etc), since this
                is generally well-liked by people. There are a couple of differences
                in the results though - internally this class still builds hardware
                buffers which can be re-used, so you can render the resulting object
                multiple times without re-issuing all the same commands again.
                Secondly, the rendering is not immediate, it is still queued just like
                all OGRE/Axiom objects. This makes this object more efficient than the
                equivalent GL immediate-mode commands, so it's feasible to use it for
                large objects if you really want to.
            
                To construct some geometry with this object:
                  -# If you know roughly how many vertices (and indices, if you use them)
                     you're going to submit, call <see cref="M:Axiom.Core.ManualObject.EstimateVertexCount(System.Int32)"/> and <see cref="M:Axiom.Core.ManualObject.EstimateIndexCount(System.Int32)"/>.
                     This is not essential but will make the process more efficient by saving
                     memory reallocations.
                  -# Call <see cref="M:Axiom.Core.ManualObject.Begin(System.String,Axiom.Graphics.OperationType)"/> to begin entering data
                  -# For each vertex, call <see cref="M:Axiom.Core.ManualObject.Position(Axiom.Math.Vector3)"/>, 
                  <see cref="M:Axiom.Core.ManualObject.Normal(Axiom.Math.Vector3)"/>, <see cref="M:Axiom.Core.ManualObject.TextureCoord(Axiom.Math.Vector3)"/>, <see cref="M:Axiom.Core.ManualObject.Color(Axiom.Core.ColorEx)"/>
                     to define your vertex data. Note that each time you call Position()
                     you start a new vertex. Note that the first vertex defines the
                     components of the vertex - you can't add more after that. For example
                     if you didn't call Normal() in the first vertex, you cannot call it
                     in any others. You ought to call the same combination of methods per
                     vertex.
                  -# If you want to define triangles (or lines/points) by indexing into the vertex list,
                     you can call <see cref="M:Axiom.Core.ManualObject.Index(System.UInt16)"/> as many times as you need to define them.
                     If you don't do this, the class will assume you want triangles drawn
                     directly as defined by the vertex list, ie non-indexed geometry. Note
                     that stencil shadows are only supported on indexed geometry, and that
                     indexed geometry is a little faster; so you should try to use it.
                  -# Call <see cref="M:Axiom.Core.ManualObject.End"/> to finish entering data.
                  -# Optionally repeat the begin-end cycle if you want more geometry
                    using different rendering operation types, or different materials
                After calling End(), the class will organize the data for that section
                internally and make it ready to render with. Like any other
                MovableObject you should attach the object to a SceneNode to make it
                visible. Other aspects like the relative render order can be controlled
                using standard MovableObject methods like SetRenderQueueGroup.
            
                You can also use <see cref="M:Axiom.Core.ManualObject.BeginUpdate(System.Int32)"/> to alter the geometry later on if you wish.
                If you do this, you should set the <see cref="P:Axiom.Core.ManualObject.Dynamic"/> property to true before your first call
                to Begin(), and also consider using EstimateVertexCount()/EstimateIndexCount()
                if your geometry is going to be growing, to avoid buffer recreation during
                growth.
            
                Note that like all OGRE/Axiom geometry, triangles should be specified in
                anti-clockwise winding order (whether you're doing it with just
                vertices, or using indexes too). That is to say that the front of the
                face is the one where the vertices are listed in anti-clockwise order.
             </summary>
        </member>
        <member name="F:Axiom.Core.ManualObject.AABB">
            Bounding box
        </member>
        <member name="F:Axiom.Core.ManualObject.anyIndexed">
            Any indexed geoemtry on any sections?
        </member>
        <member name="F:Axiom.Core.ManualObject.currentSection">
            Current section
        </member>
        <member name="F:Axiom.Core.ManualObject.currentUpdating">
            Are we updating?
        </member>
        <member name="F:Axiom.Core.ManualObject.declSize">
            Current declaration vertex size
        </member>
        <member name="F:Axiom.Core.ManualObject.dynamic">
            Whether geometry will be updated
        </member>
        <member name="F:Axiom.Core.ManualObject.edgeList">
            Edge list, used if stencil shadow casting is enabled
        </member>
        <member name="F:Axiom.Core.ManualObject.estIndexCount">
            Estimated index count
        </member>
        <member name="F:Axiom.Core.ManualObject.estVertexCount">
            Estimated vertex count
        </member>
        <member name="F:Axiom.Core.ManualObject.firstVertex">
            First vertex indicator
        </member>
        <member name="F:Axiom.Core.ManualObject.radius">
            Bounding sphere
        </member>
        <member name="F:Axiom.Core.ManualObject.sectionList">
            List of subsections
        </member>
        <member name="F:Axiom.Core.ManualObject.shadowRenderables">
            List of shadow renderables
        </member>
        <member name="F:Axiom.Core.ManualObject.tempIndexBuffer">
            System-memory buffer whilst we establish the size required
        </member>
        <member name="F:Axiom.Core.ManualObject.tempIndexSize">
            System memory allocation size, in bytes
        </member>
        <member name="F:Axiom.Core.ManualObject.tempVertex">
            Temp storage
        </member>
        <member name="F:Axiom.Core.ManualObject.tempVertexBuffer">
            System-memory buffer whilst we establish the size required
        </member>
        <member name="F:Axiom.Core.ManualObject.tempVertexPending">
            Temp vertex data to copy?
        </member>
        <member name="F:Axiom.Core.ManualObject.tempVertexSize">
            System memory allocation size, in bytes
        </member>
        <member name="F:Axiom.Core.ManualObject.texCoordIndex">
            Current texture coordinate
        </member>
        <member name="F:Axiom.Core.ManualObject.useIdentityProjection">
            Whether to use identity projection for sections
        </member>
        <member name="F:Axiom.Core.ManualObject.useIdentityView">
            Whether to use identity view for sections
        </member>
        <member name="M:Axiom.Core.ManualObject.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Core.ManualObject.ResetTempAreas">
            <summary>
            Delete temp buffers and reset init counts
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.ResizeTempVertexBufferIfNeeded(System.Int32)">
            <summary>
            Resize the temp vertex buffer
            </summary>
            <param name="numVerts">Number of vertices</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.ResizeTempIndexBufferIfNeeded(System.Int32)">
            <summary>
            Resize the index buffer
            </summary>
            <param name="numInds">Number of indices</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.CopyTempVertexToBuffer">
            <summary>
            Copies temporary vertex buffer to hardware buffer
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.Clear">
            <summary>
             Clearing the contents of this object and rebuilding from scratch
             is not the optimal way to manage dynamic vertex data, since the
             buffers are recreated. If you want to keep the same structure but
             update the content within that structure, use <see cref="M:Axiom.Core.ManualObject.BeginUpdate(System.Int32)"/> instead
             of <see cref="M:Axiom.Core.ManualObject.Clear"/> <see cref="M:Axiom.Core.ManualObject.Begin(System.String,Axiom.Graphics.OperationType)"/>. However if you do want to modify the structure
             from time to time you can do so by clearing and re-specifying the data.
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.EstimateVertexCount(System.Int32)">
            <summary>
             Calling this helps to avoid memory reallocations when you define
             vertices.
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.EstimateIndexCount(System.Int32)">
            <summary>
             Calling this helps to avoid memory reallocations when you define
             indices.
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.Begin(System.String,Axiom.Graphics.OperationType)">
            <summary>
             Each time you call this method, you start a new section of the
             object with its own material and potentially its own type of
             rendering operation (triangles, points or lines for example).
            </summary>
            <param name="materialName">The name of the material to render this part of the object with.</param>
            <param name="opType">The type of operation to use to render.</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.BeginUpdate(System.Int32)">
            <summary>
             Using this method, you can update an existing section of the object
             efficiently. You do not have the option of changing the operation type
             obviously, since it must match the one that was used before.
             </summary>
             <remarks>
             If your sections are changing size, particularly growing, use
            	<see cref="M:Axiom.Core.ManualObject.EstimateVertexCount(System.Int32)"/> and <see cref="M:Axiom.Core.ManualObject.EstimateIndexCount(System.Int32)"/> to pre-size the buffers a little
            	larger than the initial needs to avoid buffer reconstruction.
             </remarks>
             <param name="sectionIndex">The index of the section you want to update. The first
            	call to <see cref="M:Axiom.Core.ManualObject.Begin(System.String,Axiom.Graphics.OperationType)"/> would have created section 0, the second section 1, etc.
            	</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Position(Axiom.Math.Vector3)">
            <summary>
             A vertex position is slightly special among the other vertex data
             methods like <see cref="M:Axiom.Core.ManualObject.Normal(Axiom.Math.Vector3)"/> and <see cref="M:Axiom.Core.ManualObject.TextureCoord(Axiom.Math.Vector3)"/>, 
             since calling it indicates
             the start of a new vertex. All other vertex data methods you call
             after this are assumed to be adding more information (like normals or
             texture coordinates) to the last vertex started with <see cref="M:Axiom.Core.ManualObject.Position(Axiom.Math.Vector3)"/>.
             </summary>
             <param name="pos">Position as a <see cref="T:Axiom.Math.Vector3"/></param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Position(System.Single,System.Single,System.Single)">
            <summary>Vertex Position</summary>
            <param name="x">x value of position as a float</param>
            <param name="y">y value of position as a float</param>
            <param name="z">z value of position as a float</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Normal(Axiom.Math.Vector3)">
            <summary>
             Vertex normals are most often used for dynamic lighting, and
             their components should be normalized.
             </summary>
             <param name="norm">Normal as Vector3</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Normal(System.Single,System.Single,System.Single)">
            <summary>
            Normal value
            </summary>
            <param name="x">x value of vector as float</param>
            <param name="y">y value of vector as float</param>
            <param name="z">z value of vector as float</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.TextureCoord(System.Single)">
            <summary>
             You can call this method multiple times between <see cref="M:Axiom.Core.ManualObject.Position(Axiom.Math.Vector3)"/> calls
             to add multiple texture coordinates to a vertex. Each one can have
             between 1 and 3 dimensions, depending on your needs, although 2 is
             most common. There are several versions of this method for the
             variations in number of dimensions.
            </summary>
            <param name="u">u coordinate as float</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.TextureCoord(System.Single,System.Single)">
            <summary>
            Texture coordinate
            </summary>
            <param name="u">u coordinate as float</param>
            <param name="v">v coordinate as float</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.TextureCoord(System.Single,System.Single,System.Single)">
            <summary>
            Texture Coordinate
            </summary>
            <param name="u">u coordinate as float</param>
            <param name="v">v coordinate as float</param>
            <param name="w">w coordinate as float</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.TextureCoord(Axiom.Math.Vector2)">
            <summary>
            Texture coordinate
            </summary>
            <param name="uv">uv coordinate as Vector2</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.TextureCoord(Axiom.Math.Vector3)">
            <summary>
            Texture Coordinate
            </summary>
            <param name="uvw">uvw coordinate as Vector3</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Color(Axiom.Core.ColorEx)">
            <summary>Add a vertex color to a vertex</summary>
            <param name="col">col as ColorEx object</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Color(System.Single,System.Single,System.Single,System.Single)">
            <summary>Add a vertex color to a vertex</summary>
            <param name="r">r color component as float</param>
            <param name="g">g color component as float</param>
            <param name="b">b color component as float</param>
            <param name="a">a color component as float</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Index(System.UInt16)">
            <summary>
            Add a vertex index to construct faces / lines / points via indexing
             rather than just by a simple list of vertices.
             </summary>
             <remarks>
             You will have to call this 3 times for each face for a triangle list,
             or use the alternative 3-parameter version. Other operation types
             require different numbers of indexes, <see cref="F:Axiom.Graphics.RenderOperation.operationType"/>.
             32-bit indexes are not supported on all cards which is why this
             class only allows 16-bit indexes, for simplicity and ease of use.
             </remarks>
             <param name="idx">A vertex index from 0 to 65535.</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.Triangle(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
             Add a set of 3 vertex indices to construct a triangle; this is a
             shortcut to calling <see cref="M:Axiom.Core.ManualObject.Index(System.UInt16)"/> 3 times. It is only valid for triangle
             lists.
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.Quad(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
             Add a set of 4 vertex indices to construct a quad (out of 2
             triangles); this is a shortcut to calling <see cref="M:Axiom.Core.ManualObject.Index(System.UInt16)"/> 6 times,
             or <see cref="M:Axiom.Core.ManualObject.Triangle(System.UInt16,System.UInt16,System.UInt16)"/> twice. It's only valid for triangle list operations.
            </summary>
            <param name="i1">vertex index from 0 to 65535 defining a face</param>
            <param name="i2">vertex index from 0 to 65535 defining a face</param>
            <param name="i3">vertex index from 0 to 65535 defining a face</param>
            <param name="i4">vertex index from 0 to 65535 defining a face</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.End">
            <summary>
             Finish defining the object and compile the final renderable version.
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.SetMaterialName(System.Int32,System.String)">
            <summary>
            Alter the material for a subsection of this object after it has been
            specified.
            You specify the material to use on a section of this object during the
            call to <see cref="M:Axiom.Core.ManualObject.Begin(System.String,Axiom.Graphics.OperationType)"/>, however if you want to change the material afterwards
            you can do so by calling this method.
            </summary>
            <param name="idx">The index of the subsection to alter</param>
            <param name="name">The name of the new material to use</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.ConvertToMesh(System.String,System.String)">
            <summary>
             After you've finished building this object, you may convert it to
             a <see cref="T:Axiom.Core.Mesh"/> if you want in order to be able to create many instances of
             it in the world (via <see cref="T:Axiom.Core.Entity"/>). This is optional, since this instance
             can be directly attached to a <see cref="T:Axiom.Core.SceneNode"/> itself, but of course only
             one instance of it can exist that way.
            </summary>
            <remarks>Only objects which use indexed geometry may be converted to a mesh.</remarks>
            <param name="meshName">The name to give the mesh</param>
            <param name="groupName">The resource group to create the mesh in</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.GetSection(System.Int32)">
            <summary>
            Gets a reference to a <see cref="T:Axiom.Core.ManualObject.ManualObjectSection"/>, ie a part of a ManualObject.
            </summary>
            <param name="index">Index of section to get</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ManualObject.GetEdgeList">
            <summary>
            Implement this method to enable stencil shadows.
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.HasEdgeList">
            <summary>
            Does the edge list exist? Attempts to build one if not.
            </summary>
            <returns>true if list exists</returns>
        </member>
        <member name="M:Axiom.Core.ManualObject.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            Add sections that make up this ManualObject to a rendering queue.
            This is called by the engine automatically if the object is attached to a <see cref="T:Axiom.Core.SceneNode"/>.
            </summary>
            <param name="queue">Rendering queue to add this object</param>
        </member>
        <member name="M:Axiom.Core.ManualObject.GetShadowVolumeRenderableEnumerator(Axiom.Graphics.ShadowTechnique,Axiom.Core.Light,Axiom.Graphics.HardwareIndexBuffer,System.Boolean,System.Single,System.Int32)">
            <summary>
            Implement this method to enable stencil shadows.
            </summary>
            <param name="technique">Render technique</param>
            <param name="light">Light source</param>
            <param name="indexBuffer">Index buffer</param>
            <param name="extrudeVertices">Extrude (true or false)</param>
            <param name="extrusionDistance">Extrusion distance</param>
            <param name="flags">Flag parameters</param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.ManualObject.UseIdentityProjection">
            <summary>
            Usually ManualObjects will use a projection matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity projection, which effectively projects in 2D using
            a {-1, 1} view space. Useful for overlay rendering. Normally you don't
            need to change this. The default is false.
            </summary>
        </member>
        <member name="P:Axiom.Core.ManualObject.UseIdentityView">
            <summary>
            Usually ManualObjects will use a view matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity matrix, which means all geometry is assumed
            to be relative to camera space already. Useful for overlay rendering.
            Normally you don't need to change this. The default is false.
            </summary>
        </member>
        <member name="P:Axiom.Core.ManualObject.NumSections">
            <summary>
            Retrieves the number of <see cref="T:Axiom.Core.ManualObject.ManualObjectSection"/> objects making up this ManualObject.
            </summary>
        </member>
        <member name="P:Axiom.Core.ManualObject.Dynamic">
            <summary>
            Use before defining geometry to indicate that you intend to update the
            geometry regularly and want the internal structure to reflect that.
            </summary>
        </member>
        <member name="P:Axiom.Core.ManualObject.BoundingBox">
            <summary>
               Get bounding box for this object
            </summary>
        </member>
        <member name="P:Axiom.Core.ManualObject.BoundingRadius">
            <summary>
               Local bounding radius of this object.
            </summary>
        </member>
        <member name="T:Axiom.Core.ManualObject.TempVertex">
            <summary>
            Temporary vertex structure
            </summary>
        </member>
        <member name="T:Axiom.Core.ManualObject.ManualObjectSection">
            <summary>
             Built, renderable section of geometry
            </summary>
        </member>
        <member name="M:Axiom.Core.ManualObject.ManualObjectSection.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Core.ManualObject.ManualObjectSection.MaterialName">
            <summary>
            Get the material name in use
            </summary>
        </member>
        <member name="P:Axiom.Core.ManualObject.ManualObjectSection.RenderOperation">
            <summary>
            Get render operation for manipulation
            </summary>
        </member>
        <member name="T:Axiom.Core.ManualObject.ManualObjectSectionShadowRenderable">
            <summary>
            Nested class to allow shadows.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardChain.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.BillboardChain.GetSquaredViewDepth(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardChain.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Core.BillboardChain.NumWorldTransforms">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.BillboardChain.UseIdentityProjection">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.BillboardChain.UseIdentityView">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.BillboardChain.WorldOrientation">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.BillboardChain.WorldPosition">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Scripting.ScriptEnumAttribute">
            <summary>
            	This attribute is intended to be used on enum fields for enums that can be used
            	in script files (.material, .overlay, etc).  Placing this attribute on the field will
            	allow the script parsers to look up a real enum value based on the value as it is
            	used in the script.
            </summary>
            <remarks>
            	For example, texturing addressing mode can base used in .material scripts, and
            	the values in the script are 'wrap', 'clamp', and 'mirror'.
            	<p/>
            	The TextureAddress enum fields are defined with attributes to create the mapping
            	between the scriptable values and their real enum values.
            	<p/>
            	...
            	[ScriptEnum("wrap")]
            	Wrap
            	...
            </remarks>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="val">The value as it will appear when used in script files (.material, .overlay, etc).</param>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.Lookup(System.String,System.Type)">
            <summary>
            	Returns an actual enum value for a enum that can be used in script files.
            </summary>
            <param name="val"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.GetScriptAttribute(System.Int32,System.Type)">
            <summary>
            Looks up the script attibute for the enumeration value
            </summary>
            <param name="enumValue">The enumeration value</param>
            <param name="type">The Enumeration</param>
            <returns>The first script attribute found to match the enumeration value</returns>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.GetLegalValues(System.Type)">
            <summary>
            	Returns a string describing the legal values for a particular enum.
            </summary>
            <param name="type"></param>
            <returns>
            	A string containing legal values for script file.
            	i.e. "'none', 'clockwise', 'anticlockwise'"
            </returns>
        </member>
        <member name="T:Axiom.Scripting.Compiler.Keywords">
            This enum defines the integer ids for keywords this compiler handles
        </member>
        <member name="T:Axiom.Overlays.Overlay">
            <summary>
               Represents a layer which is rendered on top of the 'normal' scene contents.
            </summary>
            <remarks>
               An overlay is a container for visual components (2D and 3D) which will be 
               rendered after the main scene in order to composite heads-up-displays, menus
               or other layers on top of the contents of the scene.
               <p/>
               An overlay always takes up the entire size of the viewport, although the 
               components attached to it do not have to. An overlay has no visual element
               in itself, it it merely a container for visual elements.
               <p/>
               Overlays are created by calling SceneManager.CreateOverlay, or by defining them
               in special text scripts (.overlay files). As many overlays
               as you like can be defined; after creation an overlay is hidden i.e. not
               visible until you specifically enable it by calling Show(). This allows you to have multiple
               overlays predefined (menus etc) which you make visible only when you want.
               It is possible to have multiple overlays enabled at once; in this case the
               relative ZOrder parameter of the overlays determine which one is displayed
               on top.
               <p/>
               By default overlays are rendered into all viewports. This is fine when you only
               have fullscreen viewports, but if you have picture-in-picture views, you probably
               don't want the overlay displayed in the smaller viewports. You turn this off for 
               a specific viewport by calling the Viewport.DisplayOverlays property.
            </remarks>
        </member>
        <member name="F:Axiom.Overlays.Overlay.rootNode">
            <summary>
            Internal root node, used as parent for 3D objects
            </summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.elementList">
            <summary>2D element list.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.rotate">
            <summary>Degrees of rotation around center.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scrollX">
            <summary>Scroll values, offsets.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scrollY">
            <summary>Scroll values, offsets.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scaleX">
            <summary>Scale values.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scaleY">
            <summary>Scale values.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.transform">
            <summary> Camera relative transform. </summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.xform">
            <summary> Used when passing transform to overlay elements.</summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.#ctor(System.String)">
            <summary>
               Constructor: do not call direct, use SceneManager.CreateOverlay
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.AddElement(Axiom.Overlays.OverlayElementContainer)">
            <summary>
               Adds a 2d element to this overlay.
            </summary>
            <remarks>
               Containers are created and managed using the OverlayManager. A container
               could be as simple as a square panel, or something more complex like
               a grid or tree view. Containers group collections of other elements,
               giving them a relative coordinate space and a common z-order.
               If you want to attach a gui widget to an overlay, you have to do it via
               a container.
            </remarks>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.AddElement(Axiom.Core.SceneNode)">
            <summary>
               Adds a node capable of holding 3D objects to the overlay.
            </summary>
            <remarks>
               Although overlays are traditionally associated with 2D elements, there 
               are reasons why you might want to attach 3D elements to the overlay too.
               For example, if you wanted to have a 3D cockpit, which was overlaid with a
               HUD, then you would create 2 overlays, one with a 3D object attached for the
               cockpit, and one with the HUD elements attached (the zorder of the HUD 
               overlay would be higher than the cockpit to ensure it was always on top).
               <p/>
               A SceneNode can have any number of 3D objects attached to it. SceneNodes
               are created using SceneManager.CreateSceneNode, and are normally attached 
               (directly or indirectly) to the root node of the scene. By attaching them
               to an overlay, you indicate that:<OL>
               <LI>You want the contents of this node to only appear when the overlay is active</LI>
               <LI>You want the node to inherit a coordinate space relative to the camera,
               rather than relative to the root scene node</LI>
               <LI>You want these objects to be rendered after the contents of the main scene
               to ensure they are rendered on top</LI>
               </OL>
               One major consideration when using 3D objects in overlays is the behavior of 
               the depth buffer. Overlays are rendered with depth checking off, to ensure
               that their contents are always displayed on top of the main scene (to do 
               otherwise would result in objects 'poking through' the overlay). The problem
               with using 3D objects is that if they are concave, or self-overlap, then you
               can get artifacts because of the lack of depth buffer checking. So you should 
               ensure that any 3D objects you us in the overlay are convex and don't overlap
               each other. If they must overlap, split them up and put them in 2 overlays.
            </remarks>
            <param name="node"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.RemoveElement(System.String)">
            <summary>
            Removes a 2D container from the overlay.
            </summary>
            <remarks>
            Consider using <see>Hide</see>.
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.Overlay.RemoveElement(Axiom.Overlays.OverlayElementContainer)">
            <summary>
            Removes a 2D container from the overlay.
            </summary>
            <remarks>
            Consider using <see>Hide</see>.
            </remarks>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.RemoveElement(Axiom.Core.SceneNode)">
            <summary>
            Removes a 3D element from the overlay.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Clear">
            <summary>
               Clears the overlay of all attached items.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Show">
            <summary>
               Shows this overlay if it is not already visible.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Hide">
            <summary>
               Hides this overlay if it is currently being displayed.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue)">
            <summary>
               Internal method to put the overlay contents onto the render queue.
            </summary>
            <param name="camera">Current camera being used in the render loop.</param>
            <param name="queue">Current render queue.</param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.FindElementAt(System.Single,System.Single)">
            <summary>
            This returns a OverlayElement at position x,y.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Overlay.GetChild(System.String)">
            <summary>
               Gets a child container of this overlay by name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Overlay.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
               Used to transform the overlay when scrolling, scaling etc.
            </summary>
            <param name="xform">Array of Matrix4s to populate with the world 
               transforms of this overlay.
            </param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Rotate(System.Single)">
            <summary>
               Adds the passed in angle to the rotation applied to this overlay.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Scroll(System.Single,System.Single)">
            <summary>
               Scrolls the overlay by the offsets provided.
            </summary>
            <remarks>
               This method moves the overlay by the amounts provided. As with
               other methods on this object, a full screen width / height is represented
               by the value 1.0.
            </remarks>
            <param name="xOffset"></param>
            <param name="yOffset"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.SetScale(System.Single,System.Single)">
            <summary>
               Sets the scaling factor of this overlay.
            </summary>
            <remarks>
               You can use this to set an scale factor to be used to zoom an overlay.
            </remarks>
            <param name="x">Horizontal scale value, where 1.0 = normal, 0.5 = half size etc</param>
            <param name="y">Vertical scale value, where 1.0 = normal, 0.5 = half size etc</param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.SetScroll(System.Single,System.Single)">
            <summary>
               Sets the scrolling factor of this overlay.
            </summary>
            <remarks>
               You can use this to set an offset to be used to scroll an 
               overlay around the screen.
            </remarks>
            <param name="x">
               Horizontal scroll value, where 0 = normal, -0.5 = scroll so that only
               the right half the screen is visible etc
            </param>
            <param name="y">
               Vertical scroll value, where 0 = normal, 0.5 = scroll down by half 
               a screen etc.
            </param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.UpdateTransforms">
            <summary>
               Internal lazy update method.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.AssignZOrders">
            <summary>
            Updates container elements' Z-ordering
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.unload">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.IsVisible">
            <summary>
               Gets whether this overlay is being displayed or not.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.Rotation">
            <summary>
               Gets/Sets the rotation applied to this overlay, in degrees.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScaleX">
            <summary>
               Gets the current x scale value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScaleY">
            <summary>
               Gets the current y scale value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScrollX">
            <summary>
               Gets the current x scroll value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScrollY">
            <summary>
               Gets the  current y scroll value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ZOrder">
            <summary>
               Z ordering of this overlay. Valid values are between 0 and 650.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.#cctor">
            <summary>
            Empty static constructor
            DO NOT DELETE.  It needs to be here because:
            
                # The presence of a static constructor suppresses beforeFieldInit.
                # Static field variables are initialized before the static constructor is called.
                # Having a static constructor is the only way to ensure that all resources are 
                  initialized before other static functions are called.
            
            (from "Static Constructors Demystified" by Satya Komatineni
             http://www.ondotnet.com/pub/a/dotnet/2003/07/07/staticxtor.html)
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.BoundingRadiusFromAABB(Axiom.Math.AxisAlignedBox)">
            <summary>
            
            </summary>
            <param name="aabb"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RadiansToDegrees(Axiom.Math.Radian)">
            <summary>
            	Converts radians to degrees.
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.DegreesToRadians(Axiom.Math.Real)">
            <summary>
            	Converts degrees to radians.
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RadiansToDegrees(Axiom.Math.Real)">
            <summary>
            	Converts radians to degrees.
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RealEqual(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
                Compares float values for equality, taking into consideration
                that floating point values should never be directly compared using
                the '==' operator.  2 floats could be conceptually equal, but vary by a 
                float.Epsilon which would fail in a direct comparison.  To circumvent that,
                a tolerance value is used to see if the difference between the 2 floats
                is less than the desired amount of accuracy.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RealEqual(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
                Compares float values for equality, taking into consideration
                that floating point values should never be directly compared using
                the '==' operator.  2 floats could be conceptually equal, but vary by a 
                float.Epsilon which would fail in a direct comparison.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Sign(Axiom.Math.Real)">
            <summary>
                Returns the sign of a real number.
            The result will be -1 for a negative number, 0 for zero and 1 for positive number.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Sin(Axiom.Math.Radian)">
            <summary>
            Returns the sine of the specified angle.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.ASin(Axiom.Math.Real)">
            <summary>
            Returns the angle whose cosine is the specified number.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Cos(Axiom.Math.Radian)">
            <summary>
            Returns the cosine of the specified angle.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.ACos(Axiom.Math.Real)">
            <summary>
            Returns the angle whose cosine is the specified number.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Tan(Axiom.Math.Radian)">
            <summary>
            Returns the tangent of the specified angle.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.ATan(Axiom.Math.Real)">
            <summary>
            Return the angle whos tangent is the specified number.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.ATan(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Returns the angle whose tangent is the quotient of the two specified numbers.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Sqrt(Axiom.Math.Real)">
            <summary>
            	Returns the square root of a number.
            </summary>
            <remarks>This is one of the more expensive math operations.  Avoid when possible.</remarks>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.InvSqrt(Axiom.Math.Real)">
            <summary>
               Inverse square root.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Pow(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
                Raise a number to a power.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The number x raised to power y</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Abs(Axiom.Math.Real)">
            <summary>
            	Returns the absolute value of the supplied number.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Max(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Returns the maximum of the two supplied values.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Max(System.Int64,System.Int64)">
            <summary>
            Returns the maximum of the two supplied values.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Max(Axiom.Math.Real[])">
            <summary>
                Finds the first maximum value in the array and returns the index of it.
            </summary>
            <param name="values">Array of values containing one value at least.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Min(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Returns the minumum of the two supplied values.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Min(System.Int64,System.Int64)">
            <summary>
            Returns the minumum of the two supplied values.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Min(Axiom.Math.Real[])">
            <summary>
                Finds the first minimum value in the array and returns the index of it.
            </summary>
            <param name="values">Array of values containing one value at least.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Ceiling(Axiom.Math.Real)">
            <summary>
            Returns the smallest integer greater than or equal to the specified value.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RangeRandom(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
               Returns a random value between the specified min and max values.
            </summary>
            <param name="min">Minimum value.</param>
            <param name="max">Maximum value.</param>
            <returns>A random value in the range [min,max].</returns>
        </member>
        <member name="M:Axiom.Math.Utility.UnitRandom">
            <summary>
               
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.SymmetricRandom">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.BuildReflectionMatrix(Axiom.Math.Plane)">
            <summary>
                Builds a reflection matrix for the specified plane.
            </summary>
            <param name="plane"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateFaceNormal(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Calculate a face normal, including the w component which is the offset from the origin.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateBasicFaceNormal(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Calculate a face normal, no w-information.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateBasicFaceNormalWithoutNormalize(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Calculate a face normal, no w-information.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateTangentSpaceVector(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
               Calculates the tangent space vector for a given set of positions / texture coords.
            </summary>
            <remarks>
               Adapted from bump mapping tutorials at:
               http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
               author : paul.baker@univ.ox.ac.uk
            </remarks>
            <param name="position1"></param>
            <param name="position2"></param>
            <param name="position3"></param>
            <param name="u1"></param>
            <param name="v1"></param>
            <param name="u2"></param>
            <param name="v2"></param>
            <param name="u3"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.PointInTri2D(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Checks wether a given point is inside a triangle, in a
            	2-dimensional (Cartesian) space.
            </summary>
            <remarks>
            	The vertices of the triangle must be given in either
            	trigonometrical (anticlockwise) or inverse trigonometrical
            	(clockwise) order.
            </remarks>
            <param name="px">
               The X-coordinate of the point.
            </param>
            <param name="py">
               The Y-coordinate of the point.
            </param>
            <param name="ax">
               The X-coordinate of the triangle's first vertex.
            </param>
            <param name="ay">
               The Y-coordinate of the triangle's first vertex.
            </param>
            <param name="bx">
               The X-coordinate of the triangle's second vertex.
            </param>
            <param name="by">
               The Y-coordinate of the triangle's second vertex.
            </param>
            <param name="cx">
               The X-coordinate of the triangle's third vertex.
            </param>
            <param name="cy">
               The Y-coordinate of the triangle's third vertex.
            </param>
            <returns>
               <list type="bullet">
                   <item>
                       <description><b>true</b> - the point resides in the triangle.</description>
                   </item>
                   <item>
                       <description><b>false</b> - the point is outside the triangle</description>
                    </item>
                </list>
            </returns>
        </member>
        <member name="M:Axiom.Math.Utility.Measure(Axiom.Math.Utility.SimpleMethodDelegate)">
            <summary>
                Measure the execution time of a method.
            </summary>
            <param name="method"></param>
            <returns>The elapsed time in seconds.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.AxisAlignedBox)">
            <summary>
               Tests an intersection between a ray and a box.
            </summary>
            <param name="ray"></param>
            <param name="box"></param>
            <returns>A Pair object containing whether the intersection occurred, and the distance between the 2 objects.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.AxisAlignedBox,Axiom.Math.AxisAlignedBox)">
            <summary>
               Tests an intersection between two boxes.
            </summary>
            <param name="boxA">
               The primary box.
            </param>
            <param name="boxB">
               The box to test intersection with boxA.
            </param>
            <returns>
               <list type="bullet">
                   <item>
                       <description>None - There was no intersection between the 2 boxes.</description>
                   </item>
                   <item>
                       <description>Contained - boxA is fully within boxB.</description>
                    </item>
                   <item>
                       <description>Contains - boxB is fully within boxA.</description>
                    </item>
                   <item>
                       <description>Partial - boxA is partially intersecting with boxB.</description>
                    </item>
                </list>
            </returns>
            Submitted by: romout
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.Sphere,System.Boolean)">
            <summary>
            	Ray/Sphere intersection test.
            </summary>
            <param name="ray"></param>
            <param name="sphere"></param>
            <param name="discardInside"></param>
            <returns>Struct that contains a bool (hit?) and distance.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.Plane)">
            <summary>
            	Ray/Plane intersection test.
            </summary>
            <param name="ray"></param>
            <param name="plane"></param>
            <returns>Struct that contains a bool (hit?) and distance.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Sphere,Axiom.Math.AxisAlignedBox)">
            <summary>
            	Sphere/Box intersection test.
            </summary>
            <param name="sphere"></param>
            <param name="box"></param>
            <returns>True if there was an intersection, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Plane,Axiom.Math.AxisAlignedBox)">
            <summary>
            	Plane/Box intersection test.
            </summary>
            <param name="plane"></param>
            <param name="box"></param>
            <returns>True if there was an intersection, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Sphere,Axiom.Math.Plane)">
            <summary>
            	Sphere/Plane intersection test.
            </summary>
            <param name="sphere"></param>
            <param name="plane"></param>
            <returns>True if there was an intersection, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersect(Axiom.Math.Ray,Axiom.Math.AxisAlignedBox)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.PlaneBoundedVolume)">
            <summary>
               Ray/PlaneBoundedVolume intersection test.
            </summary>
            <param name="ray"></param>
            <param name="volume"></param>
            <returns>Struct that contains a bool (hit?) and distance.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Swap``1(``0@,``0@)">
            <summary>
            Swaps two values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:Axiom.Math.Utility.Clamp``1(``0,``0,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="max"></param>
            <param name="min"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.GaussianDistribution(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Generates a value based on the Gaussian (normal) distribution function
            with the given offset and scale parameters.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Math.Utility.SimpleMethodDelegate">
            <summary>
               Method delegate with a simple signature. 
               Used to measure execution time of a method for instance.
            </summary>
        </member>
        <member name="T:Axiom.Math.IntersectResult">
            <summary>
            	Simple struct to allow returning a complex intersection result.
            </summary>
        </member>
        <member name="F:Axiom.Math.IntersectResult.Hit">
            <summary>
            	Did the intersection test result in a hit?
            </summary>
        </member>
        <member name="F:Axiom.Math.IntersectResult.Distance">
            <summary>
            	If Hit was true, this will hold a query specific distance value.
            	i.e. for a Ray-Box test, the distance will be the distance from the start point
            	of the ray to the point of intersection.
            </summary>
        </member>
        <member name="M:Axiom.Math.IntersectResult.#ctor(System.Boolean,Axiom.Math.Real)">
            <summary>
            	Constructor.
            </summary>
            <param name="hit"></param>
            <param name="distance"></param>
        </member>
        <member name="T:Axiom.Math.Ray">
            <summary>
            	Representation of a ray in space, ie a line with an origin and direction.
            </summary>
        </member>
        <member name="M:Axiom.Math.Ray.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Math.Ray.#ctor(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
               Constructor.
            </summary>
            <param name="origin">Starting point of the ray.</param>
            <param name="direction">Direction the ray is pointing.</param>
        </member>
        <member name="M:Axiom.Math.Ray.GetPoint(Axiom.Math.Real)">
            <summary>
            Gets the position of a point t units along the ray.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
               Tests whether this ray intersects the given box.
            </summary>
            <param name="box"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.Plane)">
            <summary>
            	Tests whether this ray intersects the given plane. 
            </summary>
            <param name="plane"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Tests whether this ray intersects the given sphere. 
            </summary>
            <param name="sphere"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.PlaneBoundedVolume)">
            <summary>
            	Tests whether this ray intersects the given PlaneBoundedVolume. 
            </summary>
            <param name="volume"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.op_Multiply(Axiom.Math.Ray,Axiom.Math.Real)">
            <summary>
            Gets the position of a point t units along the ray.
            </summary>
            <param name="ray"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Ray.Item(Axiom.Math.Real)">
            <summary>
            Gets the position of a point t units along the ray.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Ray.Origin">
            <summary>
               Gets/Sets the origin of the ray.
            </summary>
        </member>
        <member name="P:Axiom.Math.Ray.Direction">
            <summary>
               Gets/Sets the direction this ray is pointing.
            </summary>
            <remarks>
               A ray has no length, so the direction goes to infinity.
            </remarks>
        </member>
        <member name="T:Axiom.Math.Matrix4">
            <summary>
            	Class encapsulating a standard 4x4 homogenous matrix.
            </summary>
            <remarks>
            	The engine uses column vectors when applying matrix multiplications,
            	This means a vector is represented as a single column, 4-row
            	matrix. This has the effect that the tranformations implemented
            	by the matrices happens right-to-left e.g. if vector V is to be
            	transformed by M1 then M2 then M3, the calculation would be
            	M3 * M2 * M1 * V. The order that matrices are concatenated is
            	vital since matrix multiplication is not cummatative, i.e. you
            	can get a different result if you concatenate in the wrong order.
            		<p/>
            	The use of column vectors and right-to-left ordering is the
            	standard in most mathematical texts, and is the same as used in
            	OpenGL. It is, however, the opposite of Direct3D, which has
            	inexplicably chosen to differ from the accepted standard and uses
            	row vectors and left-to-right matrix multiplication.
            	<p/>
            	The engine deals with the differences between D3D and OpenGL etc.
            	internally when operating through different render systems. The engine
            	users only need to conform to standard maths conventions, i.e.
            	right-to-left matrix multiplication, (The engine transposes matrices it
            	passes to D3D to compensate).
            	<p/>
            	The generic form M * V which shows the layout of the matrix 
            	entries is shown below:
            	<p/>
            	| m[0][0]  m[0][1]  m[0][2]  m[0][3] |   {x}
            	| m[1][0]  m[1][1]  m[1][2]  m[1][3] |   {y}
            	| m[2][0]  m[2][1]  m[2][2]  m[2][3] |   {z}
            	| m[3][0]  m[3][1]  m[3][2]  m[3][3] |   {1}
            </remarks>
            <ogre headerVersion="1.18" sourceVersion="1.8" />
        </member>
        <member name="M:Axiom.Math.Matrix4.#ctor(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Creates a new Matrix4 with all the specified parameters.
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix4.FromMatrix3(Axiom.Math.Matrix3)">
            <summary>
            	Used to allow assignment from a Matrix3 to a Matrix4 object.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Compose(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
            Creates a translation Matrix
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix4.ComposeInverse(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
            Creates an inverse translation Matrix
            </summary>
            <param name="translation"></param>
            <param name="scale"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.GetMatrix3">
            <summary>
               Returns a 3x3 portion of this 4x4 matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Inverse">
            <summary>
               Returns an inverted matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.InverseAffine">
            <summary>
                Returns an inverted affine matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Transpose">
            <summary>
               Swap the rows of the matrix with the columns.
            </summary>
            <returns>A transposed Matrix.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.TransformAffine(Axiom.Math.Vector3)">
            <summary>
            3-D Vector transformation specially for affine matrix.
            </summary>
            <remarks>
            Transforms the given 3-D vector by the matrix, projecting the
            result back into <i>w</i> = 1.
            The matrix must be an affine matrix. <see cref="P:Axiom.Math.Matrix4.IsAffine"/>.
            </remarks>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.TransformAffine(Axiom.Math.Vector4)">
            <summary>
            4-D Vector transformation specially for affine matrix.
            </summary>
            <remarks>
            The matrix must be an affine matrix. <see cref="P:Axiom.Math.Matrix4.IsAffine"/>.
            </remarks>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.MakeRealArray(Axiom.Math.Real[])">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.ExtractRotation">
            <summary>
                Extract the 3x3 matrix representing the current rotation. 
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix4.ExtractScale">
            <summary>
                Extract scaling information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Decompose(Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Quaternion@)">
            <summary>
               Decompose the matrix.
            </summary>
            <param name="translation"></param>
            <param name="scale"></param>
            <param name="orientation"></param>
        </member>
        <member name="M:Axiom.Math.Matrix4.Adjoint">
            <summary>
               Used to generate the adjoint of this matrix.
            </summary>
            <returns>The adjoint matrix of the current instance.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Multiply(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to multiply (concatenate) two 4x4 Matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to multiply (concatenate) two 4x4 Matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Multiply(Axiom.Math.Matrix4,Axiom.Math.Vector3)">
            <summary>
            	Transforms the given 3-D vector by the matrix, projecting the 
            	result back into <i>w</i> = 1.
            	<p/>
            	This means that the initial <i>w</i> is considered to be 1.0,
            	and then all the tree elements of the resulting 3-D vector are
            	divided by the resulting <i>w</i>.
            </summary>
            <param name="matrix">A Matrix4.</param>
            <param name="vector">A Vector3.</param>
            <returns>A new vector.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Multiply(Axiom.Math.Matrix4,Axiom.Math.Plane)">
            <summary>
            	Transforms a plane using the specified transform.
            </summary>
            <param name="matrix">Transformation matrix.</param>
            <param name="plane">Plane to transform.</param>
            <returns>A transformed plane.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Vector3)">
            <summary>
            	Transforms the given 3-D vector by the matrix, projecting the 
            	result back into <i>w</i> = 1.
            	<p/>
            	This means that the initial <i>w</i> is considered to be 1.0,
            	and then all the tree elements of the resulting 3-D vector are
            	divided by the resulting <i>w</i>.
            </summary>
            <param name="matrix">A Matrix4.</param>
            <param name="vector">A Vector3.</param>
            <returns>A new vector.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Real)">
            <summary>
            	Used to multiply a Matrix4 object by a scalar value..
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Plane)">
            <summary>
            	Used to multiply a transformation to a Plane.
            </summary>
            <param name="left"></param>
            <param name="plane"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Add(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Addition(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Subtract(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Subtraction(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Equality(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            Compares two Matrix4 instances for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true if the Matrix 4 instances are equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Inequality(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            Compares two Matrix4 instances for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true if the Matrix 4 instances are not equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Implicit(Axiom.Math.Matrix3)~Axiom.Math.Matrix4">
            <summary>
            	Used to allow assignment from a Matrix3 to a Matrix4 object.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Matrix4.
            </summary>
            <returns>A string representation of a vector3.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Equals(System.Object)">
            <summary>
            	Compares this Matrix to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Matrix4.Identity">
            <summary>
               Returns a matrix with the following form:
               | 1,0,0,0 |
               | 0,1,0,0 |
               | 0,0,1,0 |
               | 0,0,0,1 |
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Zero">
            <summary>
               Returns a matrix with all elements set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Translation">
            <summary>
            	Gets/Sets the Translation portion of the matrix.
            	| 0 0 0 Tx|
            	| 0 0 0 Ty|
            	| 0 0 0 Tz|
            	| 0 0 0  1 |
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Scale">
            <summary>
            	Gets/Sets the Scale portion of the matrix.
            	|Sx 0  0  0 |
            	| 0 Sy 0  0 |
            	| 0  0 Sz 0 |
            	| 0  0  0  0 |
            </summary>
            <remarks>
                Note that the property reflects the real scale only when there isn't any rotation, 
            i.e. the 3x3 rotation portion of the matrix was a <see cref="P:Axiom.Math.Matrix3.Identity"/> before a scale was set.
            If you need to obtain the current scale of a rotated matrix, use the more expensive <see cref="M:Axiom.Math.Matrix4.ExtractRotation"/> method.
            </remarks>
        </member>
        <member name="P:Axiom.Math.Matrix4.IsAffine">
            <summary>
            Check whether or not the matrix is affine matrix.
            </summary>
            <remarks>
            An affine matrix is a 4x4 matrix with row 3 equal to (0, 0, 0, 1),
            e.g. no projective coefficients.
            </remarks>
        </member>
        <member name="P:Axiom.Math.Matrix4.Determinant">
            <summary>
               Gets the determinant of this matrix.
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Item(System.Int32,System.Int32)">
            <summary>
               Allows the Matrix to be accessed like a 2d array (i.e. matrix[2,3])
            </summary>
            <remarks>
               This indexer is only provided as a convenience, and is <b>not</b> recommended for use in
               intensive applications.  
            </remarks>
        </member>
        <member name="P:Axiom.Math.Matrix4.Item(System.Int32)">
            <summary>
            	Allows the Matrix to be accessed linearly (m[0] -> m[15]).  
            </summary>
            <remarks>
               This indexer is only provided as a convenience, and is <b>not</b> recommended for use in
               intensive applications.  
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.VertexDeclaration">
            <summary>
            	This class declares the format of a set of vertex inputs, which
            	can be issued to the rendering API through a <see cref="T:Axiom.Graphics.RenderOperation"/>.
            </summary>
            <remarks>
            	You should be aware that the ordering and structure of the
            	VertexDeclaration can be very important on DirectX with older
            	cards, so if you want to maintain maximum compatibility with
            	all render systems and all cards you should be careful to follow these
            	rules:<ol>
            	<li>VertexElements should be added in the following order, and the order of the
            	elements within a shared buffer should be as follows:
            	position, blending weights, normals, diffuse colours, specular colours,
            	texture coordinates (in order, with no gaps)</li>
            	<li>You must not have unused gaps in your buffers which are not referenced
            	by any <see cref="T:Axiom.Graphics.VertexElement"/></li>
            	<li>You must not cause the buffer &amp; offset settings of 2 VertexElements to overlap</li>
            	</ol>
            	Whilst GL and more modern graphics cards in D3D will allow you to defy these rules,
            	sticking to them will ensure that your buffers have the maximum compatibility.
            	<p/>
            	Like the other classes in this functional area, these declarations should be created and
            	destroyed using the <see cref="T:Axiom.Graphics.HardwareBufferManager"/>.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.VertexDeclaration.elements">
            <summary>
                List of elements that make up this declaration.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.AddElement(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
                Adds a new VertexElement to this declaration.
            </summary>
            <remarks>
                This method adds a single element (positions, normals etc) to the
                vertex declaration. <b>Please read the information in <see cref="T:Axiom.Graphics.VertexDeclaration"/> about
                the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="source">
                The binding index of HardwareVertexBuffer which will provide the source for this element.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.AddElement(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
                Adds a new VertexElement to this declaration.
            </summary>
            <remarks>
                This method adds a single element (positions, normals etc) to the
                vertex declaration. <b>Please read the information in <see cref="T:Axiom.Graphics.VertexDeclaration"/> about
                the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="source">
                The binding index of HardwareVertexBuffer which will provide the source for this element.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">Optional index for multi-input elements like texture coordinates.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.FindElementBySemantic(Axiom.Graphics.VertexElementSemantic)">
            <summary>
                Finds a <see cref="T:Axiom.Graphics.VertexElement"/> with the given semantic, and index if there is more than
                one element with the same semantic.
            </summary>
            <param name="semantic">Semantic to search for.</param>
            <returns>If the element is not found, this method returns null.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.FindElementBySemantic(Axiom.Graphics.VertexElementSemantic,System.Int16)">
            <summary>
                Finds a <see cref="T:Axiom.Graphics.VertexElement"/> with the given semantic, and index if there is more than
                one element with the same semantic.
            </summary>
            <param name="semantic">Semantic to search for.</param>
            <param name="index">Index of item to looks for using the supplied semantic (applicable to tex coords and colors).</param>
            <returns>If the element is not found, this method returns null.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.FindElementBySource(System.Int16)">
            <summary>
                Gets a list of elements which use a given source.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetElement(System.Int32)">
            <summary>
            	Gets the <see cref="T:Axiom.Graphics.VertexElement"/> at the specified index.
            </summary>
            <param name="index">Index of the element to retrieve.</param>
            <returns>Element at the requested index.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetVertexSize">
            <summary>
            Gets the vertex size defined by this declaration.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetVertexSize(System.Int16)">
            <summary>
                Gets the vertex size defined by this declaration for a given source.
            </summary>
            <param name="source">The buffer binding index for which to get the vertex size.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.InsertElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
            	Inserts a new <see cref="T:Axiom.Graphics.VertexElement"/> at a given position in this declaration.
            </summary>
            <remarks>
            	This method adds a single element (positions, normals etc) at a given position in this
            	vertex declaration. <b>Please read the information in VertexDeclaration about
            	the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="position">Position to insert into.</param>
            <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element.</param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color, etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <returns>A reference to the newly created element.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.InsertElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
            	Inserts a new <see cref="T:Axiom.Graphics.VertexElement"/> at a given position in this declaration.
            </summary>
            <remarks>
            	This method adds a single element (positions, normals etc) at a given position in this
            	vertex declaration. <b>Please read the information in VertexDeclaration about
            	the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="position">Position to insert into.</param>
            <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element.</param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color, etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">Optional index for multi-input elements like texture coordinates.</param>
            <returns>A reference to the newly created element.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveElement(System.Int32)">
            <summary>
            	Gets the <see cref="T:Axiom.Graphics.VertexElement"/> at the specified index.
            </summary>
            <param name="index">Index of the element to retrieve.</param>
            <returns>Element at the requested index.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveAllElements">
            <summary>
            	Removes all <see cref="T:Axiom.Graphics.VertexElement"/> from the declaration.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.ModifyElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
            	Modifies the definition of a <see cref="T:Axiom.Graphics.VertexElement"/>.
            </summary>
            <param name="elemIndex">Index of the element to modify.</param>
            <param name="source">Source of the element.</param>
            <param name="offset">Offset of the element.</param>
            <param name="type">Type of the element.</param>
            <param name="semantic">Semantic of the element.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.ModifyElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
            	Modifies the definition of a <see cref="T:Axiom.Graphics.VertexElement"/>.
            </summary>
            <param name="elemIndex">Index of the element to modify.</param>
            <param name="source">Source of the element.</param>
            <param name="offset">Offset of the element.</param>
            <param name="type">Type of the element.</param>
            <param name="semantic">Semantic of the element.</param>
            <param name="index">Usage index of the element.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveElement(Axiom.Graphics.VertexElementSemantic)">
            <summary>
            	Remove the element with the given semantic.
            </summary>
            <remarks>
            	For elements that have usage indexes, the default of 0 is used.
            </remarks>
            <param name="semantic">Semantic to remove.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveElement(Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
            	Remove the element with the given semantic and usage index.
            </summary>
            <param name="semantic">Semantic to remove.</param>
            <param name="index">Usage index to remove, typically only applies to tex coords.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.op_Equality(Axiom.Graphics.VertexDeclaration,Axiom.Graphics.VertexDeclaration)">
            <summary>
                Tests equality of 2 <see cref="T:Axiom.Graphics.VertexElement"/> objects.
            </summary>
            <param name="left">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <param name="right">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <returns>true if equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.op_Inequality(Axiom.Graphics.VertexDeclaration,Axiom.Graphics.VertexDeclaration)">
            <summary>
                Tests in-equality of 2 <see cref="T:Axiom.Graphics.VertexElement"/> objects.
            </summary>
            <param name="left">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <param name="right">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <returns>true if not equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.Equals(System.Object)">
            <summary>
               Override to determine equality between 2 VertexDeclaration objects,
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetHashCode">
            <summary>
               Override GetHashCode.
            </summary>
            <remarks>
               Done mainly to quash warnings, no real need for it.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.Clone">
            <summary>
                Clones this declaration, including a copy of all <see cref="T:Axiom.Graphics.VertexElement"/> objects this declaration holds.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.Clone(System.Int16)">
            <summary>
            Clones this declaration, including a copy of all <see cref="T:Axiom.Graphics.VertexElement"/> objects this declaration holds for the given source.
            </summary>
            <param name="source">the source elements to clone</param>
            <returns>a new <see cref="T:Axiom.Graphics.VertexDeclaration"/> containing only those <see cref="T:Axiom.Graphics.VertexElement"/>s</returns>
            <remarks>all elements in the cloned <see cref="T:Axiom.Graphics.VertexDeclaration"/> will have a source of 0.</remarks>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Graphics.VertexDeclaration.Elements">
            <summary>
             Returns the entire vertexelement list
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexDeclaration.ElementCount">
            <summary>
                Gets the number of elements in the declaration.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderQueue">
            <summary>
            	Class to manage the scene object rendering queue.
            </summary>
            <remarks>
            	Objects are grouped by material to minimize rendering state changes. The map from
            	material to renderable object is wrapped in a class for ease of use.
            	<p/>
            	This class includes the concept of 'queue groups' which allows the application
            	adding the renderable to specifically schedule it so that it is included in 
            	a discrete group. Good for separating renderables into the main scene,
            	backgrounds and overlays, and also could be used in the future for more
            	complex multipass routines like stenciling.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.DEFAULT_PRIORITY">
            <summary>
            	Default priority of items added to the render queue.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.renderGroups">
            <summary>
            	Cached list of render groups, indexed by RenderQueueGroupID.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.defaultGroup">
            <summary>
            	Default render group for this queue.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.splitPassesByLightingType">
            <summary>
            	Should passes be split by their lighting stage?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.splitNoShadowPasses">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.shadowCastersCannotBeReceivers">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.defaultRenderablePriority">
            <summary>
            	Default priority of items added to the render queue.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable,System.UInt16,Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Adds a renderable item to the queue.
            </summary>
            <param name="renderable">IRenderable object to add to the queue.</param>
            <param name="groupID">Group to add the item to.</param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable,Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
            <param name="groupID"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable,System.UInt16)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.Clear">
            <summary>
            	Clears all 
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.Clear(System.Boolean)">
            <summary>
            	Clears all 
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.GetQueueGroup(Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Get a render queue group.
            </summary>
            <remarks>
            	New queue groups are registered as they are requested, 
            	therefore this method will always return a valid group.
            </remarks>
            <param name="queueID">ID of the queue group to retreive.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.GetQueueGroupByIndex(System.Int32)">
            <summary>
               
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.DefaultRenderGroup">
            <summary>
            	Gets/Sets the default priority for rendering objects in the queue.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.DefaultRenderablePriority">
            <summary>
            	Gets/Sets the default priority for rendering objects in the queue.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.NumRenderQueueGroups">
            <summary>
               Gets the number of render queue groups contained within this queue.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.SplitPassesByLightingType">
            <summary>
            	Gets/Sets whether or not the queue will split passes by their lighting type,
            	ie ambient, per-light and decal. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.SplitNoShadowPasses">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.ShadowCastersCannotBeReceivers">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderablePass">
            <summary>
               Internal structure reflecting a single Pass for a Renderable
            </summary>
        </member>
        <member name="T:Axiom.Core.Texture">
            <summary>
            	Abstract class representing a Texture resource.
            </summary>
            <remarks>
            	The actual concrete subclass which will exist for a texture
            	is dependent on the rendering system in use (Direct3D, OpenGL etc).
            	This class represents the commonalities, and is the one 'used'
            	by programmers even though the real implementation could be
            	different in reality. Texture objects are created through
            	the 'Create' method of the TextureManager concrete subclass.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Texture._width">
            <summary>Width of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._height">
            <summary>Height of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._depth">
            <summary>Depth of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._finalBpp">
            <summary>Bits per pixel in this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._hasAlpha">
            <summary>Does this texture have an alpha component?</summary>
        </member>
        <member name="F:Axiom.Core.Texture._gamma">
            <summary>Gamma setting for this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._format">
            <summary>Pixel format of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._mipmapCount">
            <summary>Number of mipmaps present in this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._requestedMipmapCount">
            <summary>Number of mipmaps requested for this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._mipmapsHardwareGenerated">
            <summary>Are the mipmaps generated in hardware?</summary>
        </member>
        <member name="F:Axiom.Core.Texture._textureType">
            <summary>Type of texture, i.e. 1D, 2D, Cube, Volume.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._usage">
            <summary>Specifies how this texture will be used.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._srcWidth">
            <summary>Original source width if this texture had been modified.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._srcHeight">
            <summary>Original source height if this texture had been modified.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._srcBpp">
            <summary>Original source bits per pixel if this texture had been modified.</summary>
        </member>
        <member name="F:Axiom.Core.Texture._srcDepth">
            <summary>Original depth of the input texture (only applicable for 3D textures).</summary>
        </member>
        <member name="F:Axiom.Core.Texture._srcFormat">
            <summary>Original format of the input texture (only applicable for 3D textures).</summary>
        </member>
        <member name="F:Axiom.Core.Texture._desiredFormat">
            <summary>Desired format of the input texture (only applicable for 3D textures).</summary>
        </member>
        <member name="M:Axiom.Core.Texture.SetDesiredBitDepths(System.UInt16,System.UInt16)">
            <summary>
            Sets desired bit depth for integer and float pixel format.
            </summary>
            <param name="integerBitDepth"></param>
            <param name="floatBitDepth"></param>
        </member>
        <member name="F:Axiom.Core.Texture._fsaa">
            <summary></summary>
        </member>
        <member name="M:Axiom.Core.Texture.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Axiom.Core.Texture"/> class.
            </summary>
            <param name="parent">The parent.</param>
            <param name="name">The name.</param>
            <param name="handle">The handle.</param>
            <param name="group">The group.</param>
        </member>
        <member name="M:Axiom.Core.Texture.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <summary>
            Initializes a new instance of the <see cref="T:Axiom.Core.Texture"/> class.
            </summary>
            <param name="parent">The parent.</param>
            <param name="name">The name.</param>
            <param name="handle">The handle.</param>
            <param name="group">The group.</param>
            <param name="isManual">if set to <c>true</c> [is manual].</param>
            <param name="loader">The loader.</param>
        </member>
        <member name="M:Axiom.Core.Texture.LoadImage(Axiom.Media.Image)">
            <summary>
               Loads data from an Image directly into this texture.
            </summary>
            <param name="image"></param>
            <ogre name="loadImage" />
        </member>
        <member name="M:Axiom.Core.Texture.LoadRawData(System.IO.Stream,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from the stream into this texture.
            </summary>
            <param name="data">The raw, decoded image data.</param>
            <param name="width">Width of the texture data.</param>
            <param name="height">Height of the texture data.</param>
            <param name="format">Format of the supplied image data.</param>
            <ogre name="loadRawData" />
        </member>
        <member name="M:Axiom.Core.Texture.LoadImages(Axiom.Media.Image[])">
             <summary>
             Generic method to load the texture from a set of images. This can be
             used by the specific implementation for convience. Implementations
             might decide not to use this function if they can use their own image loading
             functions.
             </summary>
            <param name="images">
             Vector of pointers to Images. If there is only one image
             in this vector, the faces of that image will be used. If there are multiple
             images in the vector each image will be loaded as a face.
             </param>
        </member>
        <member name="M:Axiom.Core.Texture.GetBuffer(System.Int32,System.Int32)">
            <summary>
               Return hardware pixel buffer for a surface. This buffer can then
               be used to copy data from and to a particular level of the texture.
            </summary>
            <param name="face">
               Face number, in case of a cubemap texture. Must be 0
               for other types of textures.
               For cubemaps, this is one of
               +X (0), -X (1), +Y (2), -Y (3), +Z (4), -Z (5)
            </param>
            <param name="mipmap">
               Mipmap level. This goes from 0 for the first, largest
               mipmap level to getNumMipmaps()-1 for the smallest.
            </param>
            <remarks>
               The buffer is invalidated when the resource is unloaded or destroyed.
               Do not use it after the lifetime of the containing texture.
            </remarks>
            <returns>A shared pointer to a hardware pixel buffer</returns>
        </member>
        <member name="P:Axiom.Core.Texture.internalResourcesCreated">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Width">
            <summary>
               Gets the width (in pixels) of this texture.
            </summary>
            <ogre name="getWidth" />
            <ogre name="setWidth" />
        </member>
        <member name="P:Axiom.Core.Texture.Height">
            <summary>
               Gets the height (in pixels) of this texture.
            </summary>
            <ogre name="setHeight" />
            <ogre name="getHeight" />
        </member>
        <member name="P:Axiom.Core.Texture.Depth">
            <summary>
               Gets the depth of this texture (for volume textures).
            </summary>
            <ogre name="setDepth" />
            <ogre name="getDepth" />
        </member>
        <member name="P:Axiom.Core.Texture.Bpp">
            <summary>
               Gets the bits per pixel found within this texture data.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.HasAlpha">
            <summary>
               Gets whether or not the PixelFormat of this texture contains an alpha component.
            </summary>
            <ogre name="hasAlpha" />
        </member>
        <member name="P:Axiom.Core.Texture.TreatLuminanceAsAlpha">
            <summary>
            Gets or sets a value indicating whether to treat luminence as aplha.
            </summary>
            <value>
            	<c>true</c> if treat luminence as aplha; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Axiom.Core.Texture.Gamma">
            <summary>
               Gets/Sets the gamma adjustment factor for this texture.
            </summary>
            <remarks>
               Must be called before any variation of Load.
            </remarks>
            <ogre name="setGamma" />
            <ogre name="getGamma" />
        </member>
        <member name="P:Axiom.Core.Texture.Format">
            <summary>
               Gets the PixelFormat of this texture.
            </summary>
            <ogre name="getFormat" />
        </member>
        <member name="P:Axiom.Core.Texture.MipmapCount">
            <summary>
               Number of mipmaps present in this texture.
            </summary>
            <ogre name="setNumMipmaps" />
            <ogre name="getNumMipmaps" />
        </member>
        <member name="P:Axiom.Core.Texture.RequestedMipmapCount">
            <summary>
            Gets or sets the requested mipmap count.
            </summary>
            <value>The requested mipmap count.</value>
        </member>
        <member name="P:Axiom.Core.Texture.MipmapsHardwareGenerated">
            <summary>
            Gets or sets a value indicating whether mipmaps are hardware generated.
            </summary>
            <value>
            	<c>true</c> if mipmaps are hardware generated; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Axiom.Core.Texture.TextureType">
            <summary>
               Type of texture, i.e. 2d, 3d, cubemap.
            </summary>
            <ogre name="setTextureType" />
            <ogre name="getTextureType" />
        </member>
        <member name="P:Axiom.Core.Texture.Usage">
            <summary>
                Gets the intended usage of this texture, whether for standard usage
                or as a render target.
            </summary>
            <ogre name="setUsage" />
            <ogre name="getUsage" />
        </member>
        <member name="P:Axiom.Core.Texture.SrcWidth">
            <summary>Original source width if this texture had been modified.</summary>
            <ogre name="geteSrcWidth" />
        </member>
        <member name="P:Axiom.Core.Texture.SrcHeight">
            <summary>Original source height if this texture had been modified.</summary>
            <ogre name="getSrcHeight" />
        </member>
        <member name="P:Axiom.Core.Texture.srcBpp">
            <summary>Original source bits per pixel if this texture had been modified.</summary>
        </member>
        <member name="P:Axiom.Core.Texture.SrcDepth">
            <summary>Original depth of the input texture (only applicable for 3D textures).</summary>
            <ogre name="getSrcDepth" />
        </member>
        <member name="P:Axiom.Core.Texture.SrcFormat">
            <summary>Original format of the input texture (only applicable for 3D textures).</summary>
            <ogre name="getSrcDepth" />
        </member>
        <member name="P:Axiom.Core.Texture.DesiredFormat">
            <summary>Desired format of the input texture (only applicable for 3D textures).</summary>
            <ogre name="getSrcDepth" />
        </member>
        <member name="P:Axiom.Core.Texture.DesiredIntegerBitDepth">
            <summary>
            Desired bit depth for integer pixel format textures.
            </summary>
            <remarks>
            Available values: 0, 16 and 32, where 0 (the default) means keep original format
            as it is. This value is number of bits for a channel of the pixel.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Texture.DesiredFloatBitDepth">
            <summary>
            Desired bit depth for float pixel format textures.
            </summary>
            <remarks>
            Available values: 0, 16 and 32, where 0 (the default) means keep original format
            as it is. This value is number of bits for a channel of the pixel.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Texture.FSAA">
            <summary></summary>
            <ogre name="getFSAA" />
        </member>
        <member name="P:Axiom.Core.Texture.HardwareGammaEnabled">
            <summary>
            Gets/Sets whether this texture will be set up so that on sampling it, hardware gamma correction is applied.
            </summary>
            <remarks>
            24-bit textures are often saved in gamma color space; this preserves
            precision in the 'darks'. However, if you're performing blending on
            the sampled colors, you really want to be doing it in linear space.
            One way is to apply a gamma correction value on loading <see cref="P:Axiom.Core.Texture.Gamma"/>,
            but this means you lose precision in those dark colors. An alternative
            is to get the hardware to do the gamma correction when reading the
            texture and converting it to a floating point value for the rest of
            the pipeline. This option allows you to do that; it's only supported
            in relatively recent hardware (others will ignore it) but can improve
            the quality of color reproduction.
            Note:
            Must be called before any 'load' method since it may affect the
            construction of the underlying hardware resources.
            Also note this only useful on textures using 8-bit color channels.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Texture.Is32Bit">
            <summary>
               Specifies whether this texture is 32 bits or not.
            </summary>
            <ogre name="enable32Bit" />
        </member>
        <member name="P:Axiom.Core.Texture.faceCount">
            <summary>
            Return the number of faces this texture has. This will be 6 for a cubemap texture and 1 for a 1D, 2D or 3D one.
            </summary>
        </member>
        <member name="T:Axiom.Core.IPlatformManager">
            <summary>
            Summary description for IPlatformManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.IPlatformManager.CreateInputReader">
            <summary>
            	Creates a new input reader implementation specific to this platform.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Controllers.WaveformType">
            <summary>
            Enumerates the wave types usable with the engine.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Sine">
            <summary>Standard sine wave which smoothly changes from low to high and back again.</summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Triangle">
            <summary>An angular wave with a constant increase / decrease speed with pointed peaks.</summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Square">
            <summary>Half of the time is spent at the min, half at the max with instant transition between. </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Sawtooth">
            <summary>Gradual steady increase from min to max over the period with an instant return to min at the end. </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.InverseSawtooth">
            <summary>Gradual steady decrease from max to min over the period, with an instant return to max at the end. </summary>
        </member>
        <member name="T:Axiom.Collections.SubEntityCollection">
            <summary>
            Summary description for SubEntityCollection.
            </summary>
        </member>
        <member name="T:Axiom.Animating.SkeletonManager">
            <summary>
            Summary description for SkeletonManager.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager.Initialize(System.Object[])">
            <summary>
            Initializes the Skeleton Manager
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager._create(System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader,Axiom.Collections.NameValuePairList)">
            <summary>
               Creates a new skeleton object.
            </summary>
        </member>
        <member name="P:Axiom.Animating.SkeletonManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Bone">
            <summary>
               A bone in a skeleton.
            </summary>
            <remarks>
               See Skeleton for more information about the principles behind skeletal animation.
               This class is a node in the joint hierarchy. Mesh vertices also have assignments
               to bones to define how they move in relation to the skeleton.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Node">
             <summary>
            		Class representing a general-purpose node an articulated scene graph.
             </summary>
             <remarks>
            		A node in the scene graph is a node in a structured tree. A node contains
            		information about the transformation which will apply to
            		it and all of it's children. Child nodes can have transforms of their own, which
            		are combined with their parent's transformations.
            
            		This is an abstract class - concrete classes are based on this for specific purposes,
            		e.g. SceneNode, Bone
            	</remarks>
            	<ogre headerVersion="1.39" sourceVersion="1.53" />
        </member>
        <member name="F:Axiom.Core.Node.name">
            <summary>Name of this node.</summary>
        </member>
        <member name="F:Axiom.Core.Node.parent">
            <summary>Parent node (if any)</summary>
        </member>
        <member name="F:Axiom.Core.Node.childNodes">
            <summary>Collection of this nodes child nodes.</summary>
        </member>
        <member name="F:Axiom.Core.Node.childrenToUpdate">
            <summary>Collection of this nodes child nodes.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needParentUpdate">
            <summary>Flag to indicate own transform from parent is out of date.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needChildUpdate">
            <summary>Flag to indicate all children need to be updated.</summary>
        </member>
        <member name="F:Axiom.Core.Node.isParentNotified">
            <summary>Flag indicating that parent has been notified about update request.</summary>
        </member>
        <member name="F:Axiom.Core.Node.orientation">
            <summary>Orientation of this node relative to its parent.</summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedOrientation">
            <summary>World orientation of this node based on parents orientation.</summary>
        </member>
        <member name="F:Axiom.Core.Node.initialOrientation">
            <summary>Original orientation of this node, used for resetting to original.</summary>
        </member>
        <member name="F:Axiom.Core.Node.rotationFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.position">
            <summary>Position of this node relative to its parent.</summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedPosition">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.initialPosition">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.translationFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.scale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.initialScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.scaleFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.inheritScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.inheritOrientation">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.accumAnimWeight">
            <summary>Weight of applied animations so far, used for blending.</summary>
        </member>
        <member name="F:Axiom.Core.Node.cachedTransform">
            <summary>Cached derived transform as a 4x4 matrix.</summary>
        </member>
        <member name="F:Axiom.Core.Node.cachedRelativeTransform">
            <summary>Cached relative transform as a 4x4 matrix.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needTransformUpdate">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.needRelativeTransformUpdate">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.nodeMaterial">
            <summary>Material to be used is this node itself will be rendered (axes, or bones).</summary>
        </member>
        <member name="F:Axiom.Core.Node.nodeSubMesh">
            <summary>SubMesh to be used is this node itself will be rendered (axes, or bones).</summary>
        </member>
        <member name="F:Axiom.Core.Node.emptyLightList">
            <summary>
               Empty list of lights to return for IRenderable.Lights, since nodes are not lit.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Core.Node.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Node.RemoveFromParent">
            <summary>
               Removes the node from parent node if any
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.AddChild(Axiom.Core.Node)">
            <summary>
               Adds a node to the list of children of this node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Clear">
            <summary>
               Simply clears the collection of children.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.RemoveAllChildren">
            <summary>
            	Removes all child nodes attached to this node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.HasChild(Axiom.Core.Node)">
            <summary>
               Whether the specified node is a child of this node.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.HasChild(System.String)">
            <summary>
               Whether this node contains a child of the specified name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.GetChild(System.String)">
            <summary>
               Gets a child node by name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.RemoveChild(System.String)">
            <summary>
                Removes the child node with the specified name.
            </summary>
            <param name="name">Name of the child node</param>
            <returns>The child node that was removed</returns>
        </member>
        <member name="M:Axiom.Core.Node.RemoveChild(Axiom.Core.Node)">
            <summary>
               Removes the specifed node that is a child of this node.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.RemoveChild(Axiom.Core.Node,System.Boolean)">
            <summary>
            Internal method to remove a child of this node, keeping it in the list of child nodes by option.
            Useful when enumerating the list of children while removing them too.
            </summary>
            <param name="child"></param>
            <param name="removeFromInternalList"></param>
        </member>
        <member name="M:Axiom.Core.Node.ScaleBy(Axiom.Math.Vector3)">
             <summary>
             Scales the node, combining its current scale with the passed in scaling factor.
             </summary>
             <remarks>
            	This method applies an extra scaling factor to the node's existing scale, (unlike setScale
            	which overwrites it) combining its current scale with the new one. E.g. calling this
            	method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if
             the existing scale was 1.
            
            	Note that like rotations, scalings are oriented around the node's origin.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Vector3)">
             <summary>
             Moves the node along the cartesian axes.
            
            	This method moves the node by the supplied vector along the
            	world cartesian axes, i.e. along world x,y,z
             </summary>
             <param name="translate">Vector with x,y,z values representing the translation.</param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Vector3,Axiom.Core.TransformSpace)">
             <summary>
             Moves the node along the cartesian axes.
            
            	This method moves the node by the supplied vector along the
            	world cartesian axes, i.e. along world x,y,z
             </summary>
             <param name="translate">Vector with x,y,z values representing the translation.</param>
            <param name="relativeTo"></param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Matrix3,Axiom.Math.Vector3)">
            <summary>
            Moves the node along arbitrary axes.
            </summary>
            <remarks>
            This method translates the node by a vector which is relative to
            a custom set of axes.
            </remarks>
            <param name="axes">3x3 Matrix containg 3 column vectors each representing the
            X, Y and Z axes respectively. In this format the standard cartesian axes would be expressed as:
            	1 0 0
            	0 1 0
            	0 0 1
            	i.e. The Identity matrix.
            </param>
            <param name="move">Vector relative to the supplied axes.</param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Matrix3,Axiom.Math.Vector3,Axiom.Core.TransformSpace)">
            <summary>
            Moves the node along arbitrary axes.
            </summary>
            <remarks>
            This method translates the node by a vector which is relative to
            a custom set of axes.
            </remarks>
            <param name="axes">3x3 Matrix containg 3 column vectors each representing the
            X, Y and Z axes respectively. In this format the standard cartesian axes would be expressed as:
            	1 0 0
            	0 1 0
            	0 0 1
            	i.e. The Identity matrix.
            </param>
            <param name="move">Vector relative to the supplied axes.</param>
            <param name="relativeTo"></param>
        </member>
        <member name="M:Axiom.Core.Node.Pitch(System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around the X-axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Pitch(System.Single)">
            <summary>
            Rotate the node around the X-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Roll(System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around the Z-axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Roll(System.Single)">
            <summary>
            Rotate the node around the Z-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Yaw(System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around the Y-axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Yaw(System.Single)">
            <summary>
            Rotate the node around the Y-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Vector3,System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around an arbitrary axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Vector3,System.Single)">
            <summary>
            Rotate the node around an arbitrary axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Quaternion,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around an arbitrary axis using a Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Quaternion)">
            <summary>
            Rotate the node around an arbitrary axis using a Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.ResetOrientation">
            <summary>
            Resets the nodes orientation (local axes as world axes, no rotation).
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.ResetToInitialState">
            <summary>
            Resets the position / orientation / scale of this node to its initial state, see SetInitialState for more info.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.SetInitialState">
             <summary>
             Sets the current transform of this node to be the 'initial state' ie that
            	position / orientation / scale to be used as a basis for delta values used
             in keyframe animation.
             </summary>
             <remarks>
            	You never need to call this method unless you plan to animate this node. If you do
            	plan to animate it, call this method once you've loaded the node with its base state,
            	ie the state on which all keyframes are based.
            
            	If you never call this method, the initial state is the identity transform (do nothing) and a position of zero
             </remarks>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String)">
            <summary>
               Creates a new name child node.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String,Axiom.Math.Vector3)">
            <summary>
               Creates a new named child node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new named child node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild">
            <summary>
               Creates a new Child node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(Axiom.Math.Vector3)">
            <summary>
               Creates a new child node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new child node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.GetSquaredViewDepth(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.Node.NeedUpdate">
            <summary>
            	To be called in the event of transform changes to this node that require its recalculation.
            </summary>
            <remarks>
            	This not only tags the node state as being 'dirty', it also requests its parent to
            	know about its dirtiness so it will get an update next time.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.RequestUpdate(Axiom.Core.Node)">
            <summary>
            	Called by children to notify their parent that they need an update.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.CancelUpdate(Axiom.Core.Node)">
            <summary>
            	Called by children to notify their parent that they no longer need an update.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.OnRename(System.String)">
            <summary>
            Can be overriden in derived classes to fire an event or rekey this node in the collections which contain it
            </summary>
            <param name="oldName"></param>
        </member>
        <member name="M:Axiom.Core.Node.UpdateFromParent">
             <summary>
            	Triggers the node to update its combined transforms.
            
            	This method is called internally by the engine to ask the node
            	to update its complete transformation based on its parents
            	derived transform.
             </summary>
        </member>
        <member name="M:Axiom.Core.Node.MakeTransform(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Matrix4@)">
            <summary>
            Internal method for building a Matrix4 from orientation / scale / position.
            </summary>
            <remarks>
            Transform is performed in the order scale, rotate, translation, i.e. translation is independent
            of orientation axes, scale does not affect size of translation, rotation and scaling are always
            centered on the origin.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.MakeInverseTransform(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Matrix4@)">
            <summary>
            Internal method for building an inverse Matrix4 from orientation / scale / position.
            </summary>
            <remarks>
            As makeTransform except it build the inverse given the same data as makeTransform, so
            performing -translation, 1/scale, -rotate in that order.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.CreateChildImpl">
            <summary>
            Must be overridden in subclasses.  Specifies how a Node is created.  CreateChild uses this to create a new one and add it
            to the list of child nodes.  This allows subclasses to not have to override CreateChild and duplicate all its functionality.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.CreateChildImpl(System.String)">
            <summary>
            Must be overridden in subclasses.  Specifies how a Node is created.  CreateChild uses this to create a new one and add it
            to the list of child nodes.  This allows subclasses to not have to override CreateChild and duplicate all its functionality.
            </summary>
            <param name="name">The name of the node to add.</param>
        </member>
        <member name="M:Axiom.Core.Node.Update(System.Boolean,System.Boolean)">
            <summary>
            Internal method to update the Node.
            Updates this node and any relevant children to incorporate transforms etc.
            Don't call this yourself unless you are writing a SceneManager implementation.
            </summary>
            <param name="updateChildren">If true, the update cascades down to all children. Specify false if you wish to
            update children separately, e.g. because of a more selective SceneManager implementation.</param>
            <param name="hasParentChanged">if true then this will update its derived properties (scale, orientation, position) accoarding to the parent's</param>
        </member>
        <member name="M:Axiom.Core.Node.WeightedTransform(System.Single,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            This method transforms a Node by a weighted amount from its
            initial state. If weighted transforms have already been applied,
            the previous transforms and this one are blended together based
            on their relative weight. This method should not be used in
            combination with the unweighted rotate, translate etc methods.
            </summary>
            <param name="weight"></param>
            <param name="translate"></param>
            <param name="rotate"></param>
            <param name="scale"></param>
        </member>
        <member name="M:Axiom.Core.Node.WeightedTransform(System.Single,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Vector3,System.Boolean)">
            <summary>
            This method transforms a Node by a weighted amount from its
            initial state. If weighted transforms have already been applied,
            the previous transforms and this one are blended together based
            on their relative weight. This method should not be used in
            combination with the unweighted rotate, translate etc methods.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="E:Axiom.Core.Node.UpdatedFromParent">
            <summary>
            Event which provides the newly-updated derived properties for syncronization in a physics engine for instance
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.ChildCount">
            <summary>
            	Gets the number of children attached to this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Name">
            <summary>
            Gets or sets the name of this Node object.
            </summary>
            <remarks>This is autogenerated initially, so setting it is optional.</remarks>
        </member>
        <member name="P:Axiom.Core.Node.Parent">
            <summary>
            Get the Parent Node of the current Node.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Orientation">
            <summary>
               A Quaternion representing the nodes orientation.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Position">
            <summary>
            The position of the node relative to its parent.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Scale">
             <summary>
             The scaling factor applied to this node.
             </summary>
             <remarks>
            	Scaling factors, unlike other transforms, are not always inherited by child nodes.
            	Whether or not scalings affect both the size and position of the child nodes depends on
            	the setInheritScale option of the child. In some cases you want a scaling factor of a parent node
            	to apply to a child node (e.g. where the child node is a part of the same object, so you
            	want it to be the same relative size and position based on the parent's size), but
            	not in other cases (e.g. where the child node is just for positioning another object,
            	you want it to maintain its own size and relative position). The default is to inherit
            	as with other transforms.
            
            	Note that like rotations, scalings are oriented around the node's origin.
            	</remarks>
        </member>
        <member name="P:Axiom.Core.Node.InheritScale">
             <summary>
             Tells the node whether it should inherit scaling factors from its parent node.
             </summary>
             <remarks>
            	Scaling factors need not to be always inherited by child nodes.
            	Whether or not scalings affect both the size and position of the child nodes depends on
            	the InheritScale option of the child. In some cases you want a scaling factor of a parent node
            	to apply to a child node (e.g. where the child node is a part of the same object, so you
            	want it to be the same relative size and position based on the parent's size), but
            	not in other cases (e.g. where the child node is just for positioning another object,
            	you want it to maintain its own size and relative position). The default is to inherit
            	as with other transforms.
            	If true, this node's scale and position will be affected by its parent's scale. If false,
            	it will not be affected.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.InheritOrientation">
            <summary>
            Tells the node whether it should inherit the orientation from its parent node.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.LocalAxes">
            <summary>
            Gets a matrix whose columns are the local axes based on
            the nodes orientation relative to its parent.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedOrientation">
            <summary>
            Gets the orientation of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedPosition">
            <summary>
            Gets the position of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedScale">
            <summary>
            Gets the scaling factor of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.FullTransform">
            <summary>
            Gets the full transformation matrix for this node.
            </summary>
            <remarks>
            This method returns the full transformation matrix
            for this node, including the effect of any parent node
            transformations, provided they have been updated using the Node.Update() method.
            This should only be called by a SceneManager which knows the
            derived transforms have been updated before calling this method.
            Applications using the engine should just use the relative transforms.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.RelativeTransform">
            <summary>
            Gets the full transformation matrix for this node.
            </summary>
            <remarks>
            This method returns the full transformation matrix
            for this node, including the effect of any parent node
            transformations, provided they have been updated using the Node.Update() method.
            This should only be called by a SceneManager which knows the
            derived transforms have been updated before calling this method.
            Applications using the engine should just use the relative transforms.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.Axiom#Graphics#IRenderable#WorldOrientation">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.Axiom#Graphics#IRenderable#WorldPosition">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.RenderOperation">
            <summary>
            	This is only used if the SceneManager chooses to render the node. This option can be set
            	for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal
            	models using Entity.DisplaySkeleton = true.
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.Material">
             <summary>
            
             </summary>
             <remarks>
            		This is only used if the SceneManager chooses to render the node. This option can be set
            		for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal
            		models using Entity.DisplaySkeleton = true.
             </remarks>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.NumWorldTransforms">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.UseIdentityProjection">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.UseIdentityView">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.DebugRenderable.Lights">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Animating.Bone.handle">
            <summary>Numeric handle of this bone.</summary>
        </member>
        <member name="F:Axiom.Animating.Bone.isManuallyControlled">
            <summary>Bones set as manuallyControlled are not reseted in Skeleton.Reset().</summary>
        </member>
        <member name="F:Axiom.Animating.Bone.creator">
            <summary>The skeleton that created this bone.</summary>
        </member>
        <member name="F:Axiom.Animating.Bone.bindDerivedInverseTransform">
            <summary>The inverse derived transform of the bone in the binding pose.</summary>
        </member>
        <member name="M:Axiom.Animating.Bone.#ctor(System.UInt16,Axiom.Animating.Skeleton)">
            <summary>
               Constructor, not to be used directly (use Bone.CreateChild or Skeleton.CreateBone)
            </summary>
        </member>
        <member name="M:Axiom.Animating.Bone.#ctor(System.String,System.UInt16,Axiom.Animating.Skeleton)">
            <summary>
               Constructor, not to be used directly (use Bone.CreateChild or Skeleton.CreateBone)
            </summary>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChildImpl">
            <summary>
               Creates a new Bone as a child of this bone.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChildImpl(System.String)">
            <summary>
               Creates a new Bone as a child of this bone.
            </summary>
            <param name="name">Name of the bone to create.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChild(System.UInt16)">
            <summary>
               Overloaded method.  Passes in Zero and Identity for the last 2 params.
            </summary>
            <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChild(System.UInt16,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new Bone as a child of this bone.
            </summary>
            <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton.</param>
            <param name="translate">Initial translation offset of child relative to parent.</param>
            <param name="rotate">Initial rotation relative to parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.Reset">
            <summary>
               Resets the position and orientation of this Bone to the original binding position.
            </summary>
            <remarks>
               Bones are bound to the mesh in a binding pose. They are then modified from this
               position during animation. This method returns the bone to it's original position and
               orientation.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Bone.SetBindingPose">
            <summary>
               Sets the current position / orientation to be the 'binding pose' ie the layout in which 
               bones were originally bound to a mesh.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Bone.IsManuallyControlled">
            <summary>
            	Determines whether this bone is controlled at runtime.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Bone.BindDerivedInverseTransform">
            <summary>
               Gets the inverse transform which takes bone space to origin from the binding pose. 
            </summary>
        </member>
        <member name="P:Axiom.Animating.Bone.Handle">
            <summary>
               Gets the numeric handle of this bone.
            </summary>
        </member>
        <member name="T:Axiom.Animating.VertexBoneAssignment">
            <summary>
            	Records the assignment of a single vertex to a single bone with the corresponding weight.
             </summary>
             <remarks>
            	This simple struct simply holds a vertex index, bone index and weight representing the
            	assignment of a vertex to a bone for skeletal animation. There may be many of these
            	per vertex if blended vertex assignments are allowed.
            	This is a class because we need it as a reference type to allow for modification
            	in places where we would only have a copy of the data if it were a struct. 
            </remarks>
        </member>
        <member name="M:Axiom.Animating.VertexBoneAssignmentWeightComparer.Compare(Axiom.Animating.VertexBoneAssignment,Axiom.Animating.VertexBoneAssignment)">
            <summary>Compares two objects and returns a value indicating whether one is less than, equal to or greater than the other.</summary>
            <returns>Value Condition Less than zero x is less than y. Zero x equals y. Greater than zero x is greater than y. </returns>
            <param name="yVba">Second object to compare. </param>
            <param name="xVba">First object to compare. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Axiom.Graphics.ICustomCompositionPass">
            <summary>
            Interface for custom composition passes, allowing custom operations (in addition to
            the quad, scene and clear operations) in composition passes.
            <seealso cref="M:Axiom.Graphics.CompositorManager.RegisterCustomCompositorPass(System.String,Axiom.Graphics.ICustomCompositionPass)"/>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ICustomCompositionPass.CreateOperation(Axiom.Graphics.CompositorInstance,Axiom.Graphics.CompositionPass)">
            <summary>
            Create a custom composition operation.
            </summary>
            <param name="instance">The compositor instance that this operation will be performed in</param>
            <param name="pass">The CompositionPass that triggered the request</param>
            <returns></returns>
            <remarks>
            This call only happens once during creation. The CompositeRenderSystemOperation will
            get called each render.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.vertexBuffers">
            <summary>
                A list of vertex buffers created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.indexBuffers">
            <summary>
                A list of index buffers created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.vertexDeclarations">
            <summary>
                A list of vertex declarations created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.vertexBufferBindings">
            <summary>
                A list of vertex buffer bindings created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.freeTempVertexBufferMap">
            <summary>
            	Map from original buffer to list of temporary buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.tempVertexBufferLicenses">
            <summary>
            	List of currently licensed temp buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.underUsedFrameCount">
            <summary>
            	Number of frames elapsed since temporary buffers utilization was above half the available
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.UnderUsedFrameThreshold">
            <summary>
            	Number of frames to wait before free unused temporary buffers
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManagerBase.expiredDelayFrameThreshold">
            <summary>
            	Frame delay for BLT_AUTOMATIC_RELEASE temporary buffers
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.CreateVertexBuffer(Axiom.Graphics.VertexDeclaration,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
            	Creates a hardware vertex buffer.
            </summary>
            <remarks>
            	This method creates a new vertex buffer; this will act as a source of geometry
            	data for rendering objects. Note that because the meaning of the contents of
            	the vertex buffer depends on the usage, this method does not specify a
            	vertex format; the user of this buffer can actually insert whatever data 
            	they wish, in any format. However, in order to use this with a RenderOperation,
            	the data in this vertex buffer will have to be associated with a semantic element
            	of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            	using the VertexDeclaration class, which itself contains VertexElement structures
            	referring to the source data.
            	<p/>
            	Note that because vertex buffers can be shared, they are reference
            	counted so you do not need to worry about destroying them this will be done
            	automatically.
            </remarks>
            <param name="vertexDeclaration">The <see cref="T:Axiom.Graphics.VertexDeclaration"/> used for this buffer,
            	this based on the kind of data you expect to populate this buffer with.</param>
            <param name="numVerts">The number of vertices in this buffer.</param>
            <param name="usage">One or more members of the BufferUsage enumeration; you are
            	strongly advised to use StaticWriteOnly wherever possible, if you need to 
            	update regularly, consider WriteOnly and useShadowBuffer=true.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.CreateVertexBuffer(Axiom.Graphics.VertexDeclaration,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Creates a hardware vertex buffer.
            </summary>
            <remarks>
            	This method creates a new vertex buffer; this will act as a source of geometry
            	data for rendering objects. Note that because the meaning of the contents of
            	the vertex buffer depends on the usage, this method does not specify a
            	vertex format; the user of this buffer can actually insert whatever data 
            	they wish, in any format. However, in order to use this with a RenderOperation,
            	the data in this vertex buffer will have to be associated with a semantic element
            	of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            	using the VertexDeclaration class, which itself contains VertexElement structures
            	referring to the source data.
            	<p/>
            	Note that because vertex buffers can be shared, they are reference
            	counted so you do not need to worry about destroying them this will be done
            	automatically.
            </remarks>
            <param name="vertexDeclaration">The <see cref="T:Axiom.Graphics.VertexDeclaration"/> used for this buffer,
            	this based on the kind of data you expect to populate this buffer with.</param>
            <param name="numVerts">The number of vertices in this buffer.</param>
            <param name="usage">One or more members of the BufferUsage enumeration; you are
            	strongly advised to use StaticWriteOnly wherever possible, if you need to 
            	update regularly, consider WriteOnly and useShadowBuffer=true.</param>
            <param name="useShadowBuffer"></param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
                Create a hardware index buffer.
            </summary>
            <param name="type">
                The type in index, either 16- or 32-bit, depending on how many vertices
                you need to be able to address.
            </param>
            <param name="numIndices">The number of indexes in the buffer.</param>
            <param name="usage">One or more members of the <see cref="T:Axiom.Graphics.BufferUsage"/> enumeration.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
                Create a hardware index buffer.
            </summary>
            <param name="type">
                The type in index, either 16- or 32-bit, depending on how many vertices
                you need to be able to address.
            </param>
            <param name="numIndices">The number of indexes in the buffer.</param>
            <param name="usage">One or more members of the <see cref="T:Axiom.Graphics.BufferUsage"/> enumeration.</param>
            <param name="useShadowBuffer">
                If set to true, this buffer will be 'shadowed' by one stored in 
                system memory rather than GPU or AGP memory. You should set this flag if you intend 
                to read data back from the index buffer, because reading data from a buffer
                in the GPU or AGP memory is very expensive, and is in fact impossible if you
                specify <see cref="F:Axiom.Graphics.BufferUsage.WriteOnly"/> for the main buffer. If you use this option, all 
                reads and writes will be done to the shadow buffer, and the shadow buffer will
                be synchronized with the real buffer at an appropriate time.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.CreateVertexDeclaration">
            <summary>
                Creates a vertex declaration, may be overridden by certain rendering APIs.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.CreateVertexBufferBinding">
            <summary>
                Creates a new VertexBufferBinding.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.DestroyVertexBufferBinding(Axiom.Graphics.VertexBufferBinding)">
            <summary>
            	Creates a new <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.
            </summary>
            <param name="binding"></param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.DestroyVertexDeclaration(Axiom.Graphics.VertexDeclaration)">
            <summary>
            	Destroys a vertex declaration.
            </summary>
            <remarks>
            	Subclasses wishing to override this methods should call the base class implementation
            	first, which removes the object the collection of created objects.
            </remarks>
            <param name="decl">VertexDeclaration object to destroy.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.AllocateVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.IHardwareBufferLicensee)">
            <summary>
                Allocates a copy of a given vertex buffer.
            </summary>
            <remarks>
                This method allocates a temporary copy of an existing vertex buffer.
                This buffer is subsequently stored and can be made available for 
                other purposes later without incurring the cost of construction / 
                destruction.
            </remarks>
            <param name="sourceBuffer">The source buffer to use as a copy.</param>
            <param name="licenseType">
                The type of license required on this buffer - automatic
                release causes this class to release licenses every frame so that 
                they can be reallocated anew.
            </param>
            <param name="licensee">
                Reference back to the class requesting the copy, which must
                implement <see cref="T:Axiom.Graphics.IHardwareBufferLicensee"/> in order to be notified when the license
                expires.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.AllocateVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.IHardwareBufferLicensee,System.Boolean)">
            <summary>
                Allocates a copy of a given vertex buffer.
            </summary>
            <remarks>
                This method allocates a temporary copy of an existing vertex buffer.
                This buffer is subsequently stored and can be made available for 
                other purposes later without incurring the cost of construction / 
                destruction.
            </remarks>
            <param name="sourceBuffer">The source buffer to use as a copy.</param>
            <param name="licenseType">
                The type of license required on this buffer - automatic
                release causes this class to release licenses every frame so that 
                they can be reallocated anew.
            </param>
            <param name="licensee">
                Reference back to the class requesting the copy, which must
                implement <see cref="T:Axiom.Graphics.IHardwareBufferLicensee"/> in order to be notified when the license
                expires.
            </param>
            <param name="copyData">If true, the current data is copied as well as the structure of the buffer.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.ReleaseVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
                Manually release a vertex buffer copy for others to subsequently use.
            </summary>
            <remarks>
                Only required if the original call to 
                <see cref="M:Axiom.Graphics.HardwareBufferManagerBase.AllocateVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.IHardwareBufferLicensee,System.Boolean)"/>
                included a licenseType of <see cref="F:Axiom.Graphics.BufferLicenseRelease.Manual"/>. 
            </remarks>
            <param name="bufferCopy">
                The buffer copy. The caller is expected to no longer use this reference, 
                since another user may well begin to modify the contents of the buffer.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.TouchVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
                Tell engine that the vertex buffer copy intent to reuse.
            </summary>
            <remarks>
                Ogre internal keep an expired delay counter of BLT_AUTOMATIC_RELEASE
                buffers, when the counter count down to zero, it'll release for other
                purposes later. But you can use this function to reset the counter to
                the internal configured value, keep the buffer not get released for
                some frames.
            </remarks>
            <param name="bufferCopy"> The buffer copy. The caller is expected to keep this
                buffer copy for use.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.FreeUnusedBufferCopies">
            <summary>
                Free all unused vertex buffer copies.
            </summary>
            <remarks>
                This method free all temporary vertex buffers that not in used.
                In normally, temporary vertex buffers are subsequently stored and can
                be made available for other purposes later without incurring the cost
                of construction / destruction. But in some cases you want to free them
                to save hardware memory (e.g. application was runs in a long time, you
                might free temporary buffers periodically to avoid memory overload).
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.ReleaseBufferCopies(System.Boolean)">
            <summary>
                Internal method for releasing all temporary buffers which have been 
                allocated using <see cref="F:Axiom.Graphics.BufferLicenseRelease.Automatic"/> is called by Axiom.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.ForceReleaseBufferCopies(Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
            	Internal method that forces the release of copies of a given buffer.
            </summary>
            <remarks>
            	This usually means that the buffer which the copies are based on has
            	been changed in some fundamental way, and the owner of the original 
            	wishes to make that known so that new copies will reflect the changes.
            </remarks>
            <param name="sourceBuffer">Buffer to release temp copies of.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.MakeBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Creates  a new buffer as a copy of the source, does not copy data.
            </summary>
            <param name="source">Source vertex buffer.</param>
            <param name="usage">New usage type.</param>
            <param name="useShadowBuffer">New shadow buffer choice.</param>
            <returns>A copy of the vertex buffer, but data is not copied.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.dispose(System.Boolean)">
            <summary>
            Class level dispose method
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.NotifyVertexBufferDestroyed(Axiom.Graphics.HardwareVertexBuffer)">
            Notification that a hardware vertex buffer has been destroyed
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.NotifyIndexBufferDestroyed(Axiom.Graphics.HardwareIndexBuffer)">
            Notification that a hardware index buffer has been destroyed
        </member>
        <member name="T:Axiom.Graphics.HardwareBufferManagerBase.BufferComparer">
            <summary>
                Used for buffer comparison.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManagerBase.BufferComparer.Compare(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
                Comparse 2 HardwareBuffers for equality.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.CompositorInstanceMaterialEventHandler">
            <summary>
            Delegate for handling material events.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorInstanceResourceEventHandler">
            <summary>
            Delegate for handling resource events.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorInstanceMaterialEventArgs">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstanceMaterialEventArgs.PassID">
            <summary>
            Pass identifier within Compositor instance, this is specified
            by the user by CompositionPass.SetIdentifier().
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstanceMaterialEventArgs.Material">
            <summary>
            Material, this may be changed at will and will only affect
            the current instance of the Compositor, not the global material
            it was cloned from.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstanceMaterialEventArgs.#ctor(System.UInt32,Axiom.Graphics.Material)">
             <summary>
            
             </summary>
             <param name="passId"></param>
             <param name="material"></param>
        </member>
        <member name="T:Axiom.Graphics.CompositorInstanceResourceEventArgs">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstanceResourceEventArgs.ForResizeOnly">
            <summary>
            Was the creation because the viewport was resized?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstanceResourceEventArgs.#ctor(System.Boolean)">
             <summary>
            
             </summary>
             <param name="forResizeOnly"></param>
        </member>
        <member name="T:Axiom.Graphics.CompositorInstance">
            <summary>
                An instance of a Compositor object for one Viewport. It is part of the CompositorChain
                for a Viewport.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.compositor">
            <summary>
                Compositor of which this is an instance
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.technique">
            <summary>
                Composition technique used by this instance
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.chain">
            <summary>
                Composition chain of which this instance is part
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.enabled">
            <summary>
                Is this instance enabled?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.localTextures">
            <summary>
                Map from name->local texture
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.localMrts">
            <summary>
            Store a list of MRTs we've created
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.reservedTextures">
            <summary>
            Textures that are not currently in use, but that we want to keep for now,
            for example if we switch techniques but want to keep all textures available
            in case we switch back.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.renderSystemOperations">
            <summary>
                Render System operations queued by last compile, these are created by this
                instance thus managed and deleted by it. The list is cleared with
                clearCompilationState()
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorInstance.previousInstance">
            <summary>
                Previous instance (set by chain)
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.CollectPasses(Axiom.Graphics.CompositeTargetOperation,Axiom.Graphics.CompositionTargetPass)">
            <summary>
                Collect rendering passes. Here, passes are converted into render target operations
                and queued with queueRenderSystemOp.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.CompileTargetOperations(System.Collections.Generic.List{Axiom.Graphics.CompositeTargetOperation})">
            <summary>
                Recursively collect target states (except for final Pass).
            </summary>
            <param name="compiledState">This vector will contain a list of TargetOperation objects</param>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.CompileOutputOperation(Axiom.Graphics.CompositeTargetOperation)">
            <summary>
                Compile the final (output) operation. This is done seperately because this
                is combined with the input in chained filters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.GetTextureInstance(System.String)">
            <summary>
                Get the instance for a local texture.
            </summary>
            <remarks>
                It is only valid to call this when local textures have been loaded,
                which in practice means that the compositor instance is active. Calling
                it at other times will cause an exception. Note that since textures
                are cleaned up aggressively, this name is not guaranteed to stay the
                same if you disable and renable the compositor instance.
            </remarks>
            <param name="name">The name of the texture in the original compositor definition</param>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.GetTextureInstance(System.String,System.Int32)">
            <summary>
                Get the instance for a local texture.
            </summary>
            <remarks>
                It is only valid to call this when local textures have been loaded,
                which in practice means that the compositor instance is active. Calling
                it at other times will cause an exception. Note that since textures
                are cleaned up aggressively, this name is not guaranteed to stay the
                same if you disable and renable the compositor instance.
            </remarks>
            <param name="name">The name of the texture in the original compositor definition</param>
             <param name="mrtIndex">If name identifies a MRT, which texture attachment to retrieve</param>
            <returns>The instance for the texture, corresponds to a real texture</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.CreateLocalMaterial(System.String)">
            <summary>
                Create a local dummy material with one technique but no passes.
                The material is detached from the Material Manager to make sure it is destroyed
                when going out of scope.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.CreateResources(System.Boolean)">
            <summary>
                Create local rendertextures and other resources. Builds mLocalTextures.
            </summary>
             <param name="forResizeOnly"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.FreeResources(System.Boolean,System.Boolean)">
            <summary>
                Destroy local rendertextures and other resources.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.QueueRenderSystemOp(Axiom.Graphics.CompositeTargetOperation,Axiom.Graphics.CompositeRenderSystemOperation)">
            <summary>
                Queue a render system operation.
            </summary>
            <returns>destination pass</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.DeriveTextureRenderTargetOptions(System.String,System.Boolean@,System.Int32@,System.String@)">
            <summary>
            Search for options like AA and hardware gamma which we may want to
            inherit from the main render target to which we're attached.
            </summary>
            <param name="texname"></param>
            <param name="hwGammaWrite"></param>
            <param name="fsaa"></param>
            <param name="fsaaHint"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.OnMaterialSetup(Axiom.Graphics.CompositorInstanceMaterialEventArgs)">
            <summary>
                Notify listeners of a material compilation.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.OnMaterialRender(Axiom.Graphics.CompositorInstanceMaterialEventArgs)">
            <summary>
                Notify listeners of a material render.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorInstance.OnResourceCreated(Axiom.Graphics.CompositorInstanceResourceEventArgs)">
            <summary>
            Notify listeners of a material render.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.CompositorInstance.MaterialSetup">
            <summary>
            Notification of when a render target operation involving a material (like
            rendering a quad) is compiled, so that miscellaneous parameters that are different
            per Compositor instance can be set up.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.CompositorInstance.MaterialRender">
            <summary>
            Notification before a render target operation involving a material (like
            rendering a quad), so that material parameters can be varied.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.CompositorInstance.ResourceCreated">
            <summary>
            Notification after resources have been created (or recreated).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositorInstance.IsEnabled">
            <summary>
            The compositor instance will only render if it is enabled, otherwise it is pass-through.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorInstance.QueueIDAndOperation">
            <summary>
                A pairing of int and CompositeRenderSystemOperation, needed because the collection
                in TargetOperation must be ordered
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositeTargetOperation">
            <summary>
                Operation setup for a RenderTarget (collected).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.Target">
            <summary>
                Target
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.CurrentQueueGroupId">
            <summary>
                Current group ID
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.RenderSystemOperations">
            <summary>
                RenderSystem operations to queue into the scene manager
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.VisibilityMask">
            <summary>
                Scene visibility mask
                If this is 0, the scene is not rendered at all
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.LodBias">
            <summary>
                LOD offset. This is multiplied with the camera LOD offset
                1.0 is default, lower means lower detail, higher means higher detail
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.RenderQueues">
            <summary>
                A set of render queues to either include or exclude certain render queues.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.OnlyInitial">
            <summary>
             <see>CompositionTargetPass.OnlyInitial</see>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.HasBeenRendered">
            <summary>
                "Has been rendered" flag; used in combination with
                onlyInitial to determine whether to skip this target operation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.FindVisibleObjects">
            <summary>
                Whether this op needs to find visible scene objects or not
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.MaterialScheme">
            <summary>
                Which material scheme this op will use */
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositeTargetOperation.ShadowsEnabled">
            <summary>
            Whether shadows will be enabled or not
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositeRenderSystemOperation">
            <summary>
                Base class for other render system operations
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositeRenderSystemOperation.Execute(Axiom.Core.SceneManager,Axiom.Graphics.RenderSystem)">
            Set state to SceneManager and RenderSystem
        </member>
        <member name="T:Axiom.Graphics.RSClearOperation">
            <summary>
                Clear framebuffer RenderSystem operation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RSClearOperation.buffers">
            <summary>
                Which buffers to clear (FrameBuffer)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RSClearOperation.color">
            <summary>
                Color to clear in case FrameBuffer.Color is set
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RSClearOperation.depth">
            <summary>
                Depth to set in case FrameBuffer.Depth is set
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RSClearOperation.stencil">
            <summary>
                Stencil value to set in case FrameBuffer.Stencil is set
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RSStencilOperation">
            <summary>
                "Set stencil state" RenderSystem operation
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RSQuadOperation">
            <summary>
                "Render quad" RenderSystem operation
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RSQuadOperation.SetQuadCorners(System.Single,System.Single,System.Single,System.Single)">
             <summary>
            
             </summary>
             <param name="left"></param>
             <param name="top"></param>
             <param name="right"></param>
             <param name="bottom"></param>
        </member>
        <member name="M:Axiom.Graphics.RSQuadOperation.SetQuadFarCorners(System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="farCorners"></param>
             <param name="farCornersViewSpace"></param>
        </member>
        <member name="M:Axiom.Graphics.RSQuadOperation.Execute(Axiom.Core.SceneManager,Axiom.Graphics.RenderSystem)">
             <summary>
            
             </summary>
             <param name="sm"></param>
             <param name="rs"></param>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.Material">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.Technique">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.Instance">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.PassId">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadCornerModified">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadFarCorners">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadFarCornersViewSpace">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadLeft">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadTop">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadRight">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSQuadOperation.QuadBottom">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Graphics.RSSetSchemeOperation">
            <summary>
            "Set material scheme" RenderSystem operation
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RSSetSchemeOperation.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="schemeName"></param>
        </member>
        <member name="M:Axiom.Graphics.RSSetSchemeOperation.Execute(Axiom.Core.SceneManager,Axiom.Graphics.RenderSystem)">
             <summary>
            
             </summary>
             <param name="sm"></param>
             <param name="rs"></param>
        </member>
        <member name="P:Axiom.Graphics.RSSetSchemeOperation.PreviousSchemeName">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSSetSchemeOperation.PreviousLateResolving">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Graphics.RSSetSchemeOperation.SchemeName">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Graphics.RSRestoreSchemeOperation">
            <summary>
            Restore the settings changed by the set scheme operation
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RSRestoreSchemeOperation.#ctor(Axiom.Graphics.RSSetSchemeOperation)">
             <summary>
            
             </summary>
             <param name="setoperation"></param>
        </member>
        <member name="M:Axiom.Graphics.RSRestoreSchemeOperation.Execute(Axiom.Core.SceneManager,Axiom.Graphics.RenderSystem)">
             <summary>
            
             </summary>
             <param name="sm"></param>
             <param name="rs"></param>
        </member>
        <member name="P:Axiom.Graphics.RSRestoreSchemeOperation.SetOperation">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Core.ShadowTextureConfig">
            <summary>
                Structure containing the configuration for one shadow texture.
            </summary>
        </member>
        <member name="T:Axiom.Core.ShadowTextureManager">
            <summary>
                Class to manage the available shadow textures which may be shared between
                many SceneManager instances if formats agree.
            </summary>
            <remarks>
                The management of the list of shadow textures has been separated out into
                a dedicated class to enable the clean management of shadow textures
                across many scene manager instances. Where multiple scene managers are
                used with shadow textures, the configuration of those shadows may or may
                not be consistent - if it is, it is good to centrally manage the textures
                so that creation and destruction responsibility is clear.
            </remarks>
        </member>
        <member name="F:Axiom.Core.ShadowTextureManager.textureList">
            <summary>
                A list of textures available for shadow use.
            </summary>
        </member>
        <member name="M:Axiom.Core.ShadowTextureManager.GetShadowTextures(System.Collections.Generic.IList{Axiom.Core.ShadowTextureConfig},System.Collections.Generic.IList{Axiom.Core.Texture})">
            <summary>
            Populate an incoming list with shadow texture references as requested
            in the configuration list.
            </summary>
        </member>
        <member name="M:Axiom.Core.ShadowTextureManager.GetNullShadowTexture(Axiom.Media.PixelFormat)">
            <summary>
            Get an appropriately defined 'null' texture, ie one which will always result in no shadows.
            </summary>
        </member>
        <member name="M:Axiom.Core.ShadowTextureManager.ClearUnused">
            <summary>
                Remove any shadow textures that are no longer being referenced.
            </summary>
            <remarks>
                This should be called fairly regularly since references may take a
                little while to disappear in some cases (if referenced by materials)
            </remarks>
        </member>
        <member name="M:Axiom.Core.ShadowTextureManager.ClearAll">
            <summary>
                Dereference all the shadow textures kept in this class and remove them
                from TextureManager; note that it is up to the SceneManagers to clear
                their local references.
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.NodeCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.Node">Nodes</see> that are sorted by name.
            </summary>
        </member>
        <member name="M:Axiom.Core.Collections.NodeCollection.Add(Axiom.Core.Node)">
            <summary>
            Adds a <see cref="T:Axiom.Core.Node"/> to the collection and uses its name automatically as key.
            </summary>
            <param name="item">A <see cref="T:Axiom.Core.Node"/> to add to the collection.</param>
        </member>
        <member name="M:Axiom.Core.Collections.NodeCollection.Remove(Axiom.Core.Node)">
            <summary>
            Removes the specified <see cref="T:Axiom.Core.Node"/>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Core.Node"/> to remove.</param>
        </member>
        <member name="T:Axiom.Collections.RadixSortSingle`2">
             <summary>
             Class for performing a radix sort (fast comparison-less sort based on
             byte value) on various standard containers.
             </summary>
             <remarks>
             A radix sort is a very fast sort algorithm. It only uses a single comparison
             and thus is able to break the theoretical minimum O(N*logN) complexity.
             Radix sort is complexity O(k*N), where k is a constant. Note that radix
             sorting is not in-place, it requires additional storage, so it trades
             memory for speed. The overhead of copying means that it is only faster
             for fairly large datasets, so you are advised to only use it for collections
             of at least a few thousand items.
             <para/>
             This is a generic class to allow it to deal with a variety of containers,
             and a variety of value types to sort on. In addition to providing the
             container and value type on construction, you also need to supply a
             functor object which will retrieve the value to compare on for each item
             in the list. For example, if you had an <see cref="T:System.Collections.Generic.IList`1"/> of instances
             of an object of class 'Bibble', and you wanted to sort on
             Bibble.Doobrie, you'd have to create a delegate like this:
             <code>
             class BibbleSortDelegate
             {
            		static float Doobrie( Bibble val)
            		{
            			return val.Doobrie;
            		}
            	}
             </code>
             Then, you need to declare a RadixSort class which names the container type,
             the value type in the container, and the type of the value you want to
             sort by. You can then call the sort function. E.g.
             <code>
             RadixSortSingle&lt;BibbleList, Bibble&gt; radixSorter;
            
             radixSorter.Sort(myBibbleList, BibbleSortDelegate.Doobrie);
             </code>
             You should try to reuse RadixSort instances, since repeated allocation of the
             internal storage is then avoided.
            
             </remarks>
        </member>
        <member name="F:Axiom.Collections.RadixSortSingle`2._counters">
            Alpha-pass counters of values (histogram)
            4 of them so we can radix sort a maximum of a 32bit value
        </member>
        <member name="F:Axiom.Collections.RadixSortSingle`2._offsets">
            Beta-pass offsets
        </member>
        <member name="F:Axiom.Collections.RadixSortSingle`2._sortSize">
            Sort area size
        </member>
        <member name="F:Axiom.Collections.RadixSortSingle`2._passCount">
            Number of passes for this type
        </member>
        <member name="M:Axiom.Collections.RadixSortSingle`2.Sort(`0,Axiom.Collections.RadixSortSingle{`0,`1}.TFunctor)">
            <summary>
             Main sort function
            </summary>
            <param name="container">A container of the type you declared when declaring</param>
            <param name="valueFunction">
            A delegate which returns the value for comparison when given a container value
            </param>
        </member>
        <member name="T:Axiom.Collections.RadixSortInt32`2">
             <summary>
             Class for performing a radix sort (fast comparison-less sort based on
             byte value) on various standard containers.
             </summary>
             <remarks>
             A radix sort is a very fast sort algorithm. It only uses a single comparison
             and thus is able to break the theoretical minimum O(N*logN) complexity.
             Radix sort is complexity O(k*N), where k is a constant. Note that radix
             sorting is not in-place, it requires additional storage, so it trades
             memory for speed. The overhead of copying means that it is only faster
             for fairly large datasets, so you are advised to only use it for collections
             of at least a few thousand items.
             <para/>
             This is a generic class to allow it to deal with a variety of containers,
             and a variety of value types to sort on. In addition to providing the
             container and value type on construction, you also need to supply a
             functor object which will retrieve the value to compare on for each item
             in the list. For example, if you had an <see cref="T:System.Collections.Generic.IList`1"/> of instances
             of an object of class 'Bibble', and you wanted to sort on
             Bibble.Doobrie, you'd have to create a delegate like this:
             <code>
             class BibbleSortDelegate
             {
            		static int Doobrie( Bibble val)
            		{
            			return val.Doobrie;
            		}
            	}
             </code>
             Then, you need to declare a RadixSort class which names the container type,
             the value type in the container, and the type of the value you want to
             sort by. You can then call the sort function. E.g.
             <code>
             RadixSortInt32&lt;BibbleList, Bibble&gt; radixSorter;
            
             radixSorter.Sort(myBibbleList, BibbleSortDelegate.Doobrie);
             </code>
             You should try to reuse RadixSort instances, since repeated allocation of the
             internal storage is then avoided.
            
             </remarks>
        </member>
        <member name="F:Axiom.Collections.RadixSortInt32`2._counters">
            Alpha-pass counters of values (histogram)
            4 of them so we can radix sort a maximum of a 32bit value
        </member>
        <member name="F:Axiom.Collections.RadixSortInt32`2._offsets">
            Beta-pass offsets
        </member>
        <member name="F:Axiom.Collections.RadixSortInt32`2._sortSize">
            Sort area size
        </member>
        <member name="F:Axiom.Collections.RadixSortInt32`2._passCount">
            Number of passes for this type
        </member>
        <member name="M:Axiom.Collections.RadixSortInt32`2.Sort(`0,Axiom.Collections.RadixSortInt32{`0,`1}.TFunctor)">
            <summary>
             Main sort function
            </summary>
            <param name="container">A container of the type you declared when declaring</param>
            <param name="valueFunction">
            A delegate which returns the value for comparison when given a container value
            </param>
        </member>
        <member name="T:Axiom.Collections.RadixSortUInt32`2">
             <summary>
             Class for performing a radix sort (fast comparison-less sort based on
             byte value) on various standard containers.
             </summary>
             <remarks>
             A radix sort is a very fast sort algorithm. It only uses a single comparison
             and thus is able to break the theoretical minimum O(N*logN) complexity.
             Radix sort is complexity O(k*N), where k is a constant. Note that radix
             sorting is not in-place, it requires additional storage, so it trades
             memory for speed. The overhead of copying means that it is only faster
             for fairly large datasets, so you are advised to only use it for collections
             of at least a few thousand items.
             <para/>
             This is a generic class to allow it to deal with a variety of containers,
             and a variety of value types to sort on. In addition to providing the
             container and value type on construction, you also need to supply a
             functor object which will retrieve the value to compare on for each item
             in the list. For example, if you had an <see cref="T:System.Collections.Generic.IList`1"/> of instances
             of an object of class 'Bibble', and you wanted to sort on
             Bibble.Doobrie, you'd have to create a delegate like this:
             <code>
             class BibbleSortDelegate
             {
            		static uint Doobrie( Bibble val)
            		{
            			return val.Doobrie;
            		}
            	}
             </code>
             Then, you need to declare a RadixSort class which names the container type,
             the value type in the container, and the type of the value you want to
             sort by. You can then call the sort function. E.g.
             <code>
             RadixSortUInt32&lt;BibbleList, Bibble&gt; radixSorter;
            
             radixSorter.Sort(myBibbleList, BibbleSortDelegate.Doobrie);
             </code>
             You should try to reuse RadixSort instances, since repeated allocation of the
             internal storage is then avoided.
            
             </remarks>
        </member>
        <member name="F:Axiom.Collections.RadixSortUInt32`2._counters">
            Alpha-pass counters of values (histogram)
            4 of them so we can radix sort a maximum of a 32bit value
        </member>
        <member name="F:Axiom.Collections.RadixSortUInt32`2._offsets">
            Beta-pass offsets
        </member>
        <member name="F:Axiom.Collections.RadixSortUInt32`2._sortSize">
            Sort area size
        </member>
        <member name="F:Axiom.Collections.RadixSortUInt32`2._passCount">
            Number of passes for this type
        </member>
        <member name="M:Axiom.Collections.RadixSortUInt32`2.Sort(`0,Axiom.Collections.RadixSortUInt32{`0,`1}.TFunctor)">
            <summary>
             Main sort function
            </summary>
            <param name="container">A container of the type you declared when declaring</param>
            <param name="valueFunction">
            A delegate which returns the value for comparison when given a container value
            </param>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter">
            <summary>
            	Abstract class defining the interface to be implemented by particle emitters.
            </summary>
            <remarks>
            	Particle emitters are the sources of particles in a particle system.
            	This class defines the ParticleEmitter interface, and provides a basic implementation
            	for tasks which most emitters will do (these are of course overridable).
            	Particle emitters can be  grouped into types, e.g. 'point' emitters, 'box' emitters etc; each type will
            	create particles with a different starting point, direction and velocity (although
            	within the types you can configure the ranges of these parameters).
            	<p/>
            	Because there are so many types of emitters you could use, the engine chooses not to dictate
            	the available types. It comes with some in-built, but allows plugins or games to extend the emitter types available.
            	This is done by subclassing ParticleEmitter to have the appropriate emission behavior you want,
            	and also creating a subclass of ParticleEmitterFactory which is responsible for creating instances
            	of your new emitter type. You register this factory with the ParticleSystemManager using
            	AddEmitterFactory, and from then on emitters of this type can be created either from code or through
            	XML particle scripts by naming the type.
            	<p/>
            	This same approach is used for ParticleAffectors (which modify existing particles per frame).
            	This means that the engine is particularly flexible when it comes to creating particle system effects,
            	with literally infinite combinations of emitter and affector types, and parameters within those
            	types.
            </remarks>
        </member>
        <member name="T:Axiom.ParticleSystems.Particle">
            <summary>
            	Class representing a single particle instance.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.hasOwnDimensions">
            Does this particle have it's own dimensions?
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.width">
            Personal width if mOwnDimensions == true
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.height">
            Personal height if mOwnDimensions == true
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.rotationInRadians">
            Current rotation value
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.Position">
            World position
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.Direction">
            Direction (and speed) 
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.Color">
            Current colour
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.timeToLive">
            <summary>Time (in seconds) before this particle is destroyed.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.totalTimeToLive">
            <summary>Total Time to live, number of seconds of particles natural life</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.rotationSpeed">
            <summary>Speed of rotation in radians</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.parentSystem">
            Parent ParticleSystem
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.visual">
            Additional visual data you might want to associate with the Particle
        </member>
        <member name="M:Axiom.ParticleSystems.Particle.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.position">
            <summary>
               Position relative to the center of the ParticleSystem.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.emissionRate">
            <summary>
                Rate in particles per second at which this emitter wishes to emit particles.
             </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.emittedEmitter">
            <summary>
            The name of the emitter to be emitted (optional)
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.emitted">
            <summary>
            If 'true', this emitter is emitted by another emitter.
            NB. That doesnt imply that the emitter itself emits other emitters (that could or could not be the case)
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.type">
            <summary>
               Name of the type of emitter, MUST be initialized by subclasses.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.direction">
            <summary>
               Base direction of the emitter, may not be used by some emitters.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.up">
            <summary>
               Notional up vector, just used to speed up generation of variant directions.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.angle">
            <summary>
               Angle around direction which particles may be emitted, internally radians but degrees for interface.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.fixedSpeed">
            <summary>
               Fixed speed of particles.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.minSpeed">
            <summary>
               Min speed of particles.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.maxSpeed">
            <summary>
               Max speed of particles.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.fixedTTL">
            <summary>
               Initial time-to-live of particles (fixed).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.minTTL">
            <summary>
               Initial time-to-live of particles (min).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.maxTTL">
            <summary>
               Initial time-to-live of particles (max).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorFixed">
            <summary>
               Initial color of particles (fixed).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorRangeStart">
            <summary>
               Initial color of particles (range start).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorRangeEnd">
            <summary>
               Initial color of particles (range end).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.isEnabled">
            <summary>
               Whether this emitter is currently enabled (defaults to true).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.startTime">
            <summary>
               Start time (in seconds from start of first call to ParticleSystem to update).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationFixed">
            <summary>
               Length of time emitter will run for (0 = forever).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationMin">
            <summary>
               Minimum length of time emitter will run for (0 = forever).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationMax">
            <summary>
               Maximum length of time the emitter will run for (0 = forever).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationRemain">
            <summary>
               Current duration remainder.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayFixed">
            <summary>
               Fixed time between each repeat.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayMin">
            <summary>
               Minimum time between each repeat.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayMax">
            <summary>
               Maximum time between each repeat.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayRemain">
            <summary>
               Repeat delay left.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.#ctor(Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GetEmissionCount(System.Single)">
            <summary>
            	Gets the number of particles which this emitter would like to emit based on the time elapsed.
             </summary>
             <remarks>
            	For efficiency the emitter does not actually create new Particle instances (these are reused
            	by the ParticleSystem as existing particles 'die'). The implementation for this method must
            	return the number of particles the emitter would like to emit given the number of seconds which
            	have elapsed (passed in as a parameter).
            	<p/>
            	Based on the return value from this method, the ParticleSystem class will call
            	InitParticle once for each particle it chooses to allow to be emitted by this emitter.
            	The emitter should not track these InitParticle calls, it should assume all emissions
            	requested were made (even if they could not be because of particle quotas).
             </remarks>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.InitParticle(Axiom.ParticleSystems.Particle)">
            <summary>
            	Initializes a particle based on the emitter's approach and parameters.
            </summary>
            <remarks>
            	See the GetEmissionCount method for details of why there is a separation between
            	'requested' emissions and actual initialized particles.
            </remarks>
            <param name="particle">Reference to a particle which must be initialized based on how this emitter starts particles</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionDirection(Axiom.Math.Vector3@)">
            <summary>
            	Utility method for generating particle exit direction
            </summary>
            <param name="dest">Normalized vector dictating new direction.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionVelocity(Axiom.Math.Vector3@)">
            <summary>
            	Utility method to apply velocity to a particle direction.
            </summary>
            <param name="dest">The normalized vector to scale by a randomly generated scale between min and max speed.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionTTL">
            <summary>
            	Utility method for generating a time-to-live for a particle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateConstantEmissionCount(System.Single)">
            <summary>
            	Utility method for generating an emission count based on a constant emission rate.
            </summary>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionColor(Axiom.Core.ColorEx@)">
            <summary>
            	Internal method for generating a color for a particle.
            </summary>
            <param name="color">
               The color object that will be altered depending on the method of generating the particle color.
            </param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.InitDurationRepeat">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.SetDuration(System.Single,System.Single)">
            <summary>
               Sets the min/max duration range for this emitter.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.CopyTo(Axiom.ParticleSystems.ParticleEmitter)">
             <summary>
            
             </summary>
             <param name="emitter"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.ScaleVelocity(System.Single)">
            <summary>
            	Scales the velocity of the emitters by the float argument
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.SetParam(System.String,System.String)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.RegisterCommands">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Position">
            <summary>
            	Gets/Sets the position of this emitter relative to the center of the particle system.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Direction">
            <summary>
            	Gets/Sets the direction of the emitter.
            </summary>
            <remarks>
            	Most emitters will have a base direction in which they emit particles (those which
            	emit in all directions will ignore this parameter). They may not emit exactly along this
            	vector for every particle, many will introduce a random scatter around this vector using
            	the angle property.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Angle">
            <summary>
            	Gets/Sets the maximum angle away from the emitter direction which particle will be emitted.
            </summary>
            <remarks>
            	Whilst the direction property defines the general direction of emission for particles, 
            	this property defines how far the emission angle can deviate away from this base direction.
            	This allows you to create a scatter effect - if set to 0, all particles will be emitted
            	exactly along the emitters direction vector, whereas if you set it to 180 or more, particles
            	will be emitted in a sphere, i.e. in all directions.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ParticleVelocity">
            <summary>
            	Gets/Sets the initial velocity of particles emitted.
            </summary>
            <remarks>
            	This property sets the range of starting speeds for emitted particles.
            	See the alternate Min/Max properties for velocities.  This emitter will randomly
            	choose a speed between the minimum and maximum for each particle.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinParticleVelocity">
            <summary>
            	Gets/Sets the minimum velocity of particles emitted.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxParticleVelocity">
            <summary>
            	Gets/Sets the maximum velocity of particles emitted.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.EmissionRate">
            <summary>
            	Gets/Sets the emission rate for this emitter.
            </summary>
            <remarks>
            	This tells the emitter how many particles per second should be emitted. The emitter
            	subclass does not have to emit these in a continuous burst - this is a relative parameter
            	and the emitter may choose to emit all of the second's worth of particles every half-second
            	for example. This is controlled by the emitter's EmissionCount property.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.EmittedEmitter">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.IsEmitted">
            <summary>
            If 'true', this emitter is emitted by another emitter.
            NB. That doesnt imply that the emitter itself emits other emitters (that could or could not be the case)
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.TimeToLive">
            <summary>
            	Gets/Sets the lifetime of all particles emitted.
            </summary>
            <remarks>
            	The emitter initializes particles with a time-to-live (TTL), the number of seconds a particle
            	will exist before being destroyed. This method sets a constant TTL for all particles emitted.
            	Note that affectors are able to modify the TTL of particles later.
            	<p/>
            	Also see the alternate Min/Max versions of this property which takes a min and max TTL in order to
            	have the TTL vary per particle.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinTimeToLive">
            <summary>
            	Gets/Sets the minimum time each particle will live for.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxTimeToLive">
            <summary>
            	Gets/Sets the maximum time each particle will live for.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Color">
            <summary>
            	Gets/Sets the initial color of particles emitted.
            </summary>
            <remarks>
            	Particles have an initial color on emission which the emitter sets. This property sets
            	this color. See the alternate Start/End versions of this property which takes 2 colors in order to establish
            	a range of colors to be assigned to particles.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ColorRangeStart">
            <summary>
            	Gets/Sets the color that a particle starts out when it is created.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ColorRangeEnd">
            <summary>
            	Gets/Sets the color that a particle ends at just before it's TTL expires.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Type">
            <summary>
            	Gets the name of the type of emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.IsEnabled">
            <summary>
            	Gets/Sets the flag indicating if this emitter is enabled or not.
            </summary>
            <remarks>
            	Setting this property to false will turn the emitter off completely.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.StartTime">
            <summary>
            	Gets/Sets the start time of this emitter.
            </summary>
            <remarks>
            	By default an emitter starts straight away as soon as a ParticleSystem is first created,
            	or also just after it is re-enabled. This parameter allows you to set a time delay so
            	that the emitter does not 'kick in' until later.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Duration">
            <summary>
            	Gets/Sets the duration of time (in seconds) that the emitter should run.
            </summary>
            <remarks>
            	By default emitters run indefinitely (unless you manually disable them). By setting this
            	parameter, you can make an emitter turn off on it's own after a set number of seconds. It
            	will then remain disabled until either Enabled is set to true, or if the 'repeatAfter' parameter
            	has been set it will also repeat after a number of seconds.
            	<p/>
            	Also see the alternative Min/Max versions of this property which allows you to set a min and max duration for
            	a random variable duration.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinDuration">
            <summary>
            	Gets/Sets the minimum running time of this emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxDuration">
            <summary>
            	Gets/Sets the maximum running time of this emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxRepeatDelay">
            <summary>
            	Gets/Sets the maximum repeat delay for the emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinRepeatDelay">
            <summary>
            	Gets/Sets the minimum repeat delay for the emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.RepeatDelay">
            <summary>
            	Gets/Sets the time between repeats of the emitter.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.AngleCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.PositionCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.EmissionRateCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.TtlCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.TtlMinCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.TtlMaxCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.DirectionCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.DurationCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.MinDurationCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.MaxDurationCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.RepeatDelayCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.RepeatDelayMinCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.RepeatDelayMaxCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.VelocityCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.VelocityMinCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.VelocityMaxCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.ColorCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.ColorRangeStartCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.ColorRangeEndCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.NameCommand">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Math.Quaternion">
            <summary>
            	Summary description for Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.#ctor(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Creates a new Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used to multiply 2 Quaternions together.
            </summary>
            <remarks>
            	Quaternion multiplication is not communative in most cases.
            	i.e. p*q != q*p
            </remarks>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used to multiply 2 Quaternions together.
            </summary>
            <remarks>
            	Quaternion multiplication is not communative in most cases.
            	i.e. p*q != q*p
            </remarks>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="quat"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="quat"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Real,Axiom.Math.Quaternion)">
            <summary>
            Used when a Real value is multiplied by a Quaternion.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Real,Axiom.Math.Quaternion)">
            <summary>
            Used when a Real value is multiplied by a Quaternion.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Quaternion,Axiom.Math.Real)">
            <summary>
            Used when a Quaternion is multiplied by a Real value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Quaternion,Axiom.Math.Real)">
            <summary>
            Used when a Quaternion is multiplied by a Real value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Add(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used when a Quaternion is added to another Quaternion.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Addition(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used when a Quaternion is added to another Quaternion.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_UnaryNegation(Axiom.Math.Quaternion)">
            <summary>
                Negates a Quaternion, which simply returns a new Quaternion
                with all components negated.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Slerp(Axiom.Math.Real,Axiom.Math.Quaternion,Axiom.Math.Quaternion,System.Boolean)">
            <summary>
            
            </summary>
            <param name="time"></param>
            <param name="quatA"></param>
            <param name="quatB"></param>
            <param name="useShortestPath"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Nlerp(Axiom.Math.Real,Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <overloads><summary>
            normalised linear interpolation - faster but less accurate (non-constant rotation velocity)
            </summary>
            <param name="fT"></param>
            <param name="rkP"></param>
            <param name="rkQ"></param>
            <returns></returns>
            </overloads>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromAngleAxis(Axiom.Math.Real,Axiom.Math.Vector3)">
            <summary>
            Creates a Quaternion from a supplied angle and axis.
            </summary>
            <param name="angle">Value of an angle in radians.</param>
            <param name="axis">Arbitrary axis vector.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Squad(Axiom.Math.Real,Axiom.Math.Quaternion,Axiom.Math.Quaternion,Axiom.Math.Quaternion,Axiom.Math.Quaternion,System.Boolean)">
            <summary>
            	Performs spherical quadratic interpolation.
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromEulerAngles(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Combines the euler angles in the order yaw, pitch, roll to create a rotation quaternion
            </summary>
            <param name="pitch"></param>
            <param name="yaw"></param>
            <param name="roll"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Dot(Axiom.Math.Quaternion)">
            <summary>
            Performs a Dot Product operation on 2 Quaternions.
            </summary>
            <param name="quat"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Normalize">
            <summary>
            	Normalizes elements of this quaterion to the range [0,1].
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToAngleAxis(Axiom.Math.Real@,Axiom.Math.Vector3@)">
            <summary>
               
            </summary>
            <param name="angle"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToRotationMatrix">
            <summary>
            Gets a 3x3 rotation matrix from this Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Inverse">
            <summary>
            Computes the inverse of a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToAxes(Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromAxes(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromRotationMatrix(Axiom.Math.Matrix3)">
            <summary>
            
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.Log">
            <summary>
            	Calculates the logarithm of a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Exp">
            <summary>
            	Calculates the Exponent of a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Quaternion.
            </summary>
            <returns>A string representation of a Quaternion.</returns>
        </member>
        <member name="P:Axiom.Math.Quaternion.Identity">
            <summary>
               An Identity Quaternion.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.Zero">
            <summary>
               A Quaternion with all elements set to 0.0f;
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.Norm">
            <summary>
            	Squared 'length' of this quaternion.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.XAxis">
            <summary>
               Local X-axis portion of this rotation.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.YAxis">
            <summary>
               Local Y-axis portion of this rotation.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.ZAxis">
            <summary>
               Local Z-axis portion of this rotation.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.UnitInverse">
            <summary>
              Variant of Inverse() that is only valid for unit quaternions.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Math.Matrix3">
            <summary>
            A 3x3 matrix which can represent rotations around axes.
            </summary>
        </member>
        <member name="F:Axiom.Math.Matrix3.m00">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Math.Matrix3.m01">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Math.Matrix3.m02">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix3.#ctor(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Creates a new Matrix3 with all the specified parameters.
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix3.#ctor(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            Create a new Matrix from 3 Vertex3 objects.
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Matrix3.Transpose">
            <summary>
            Swap the rows of the matrix with the columns.
            </summary>
            <returns>A transposed Matrix.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.GetColumn(System.Int32)">
            <summary>
            	Gets a matrix column by index.
            </summary>
            <param name="col"></param>
            <returns>A Vector3 representing one of the Matrix columns.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.SetColumn(System.Int32,Axiom.Math.Vector3)">
            <summary>
            	Sets one of the columns of the Matrix with a Vector3.
            </summary>
            <param name="col"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.FromAxes(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Creates a Matrix3 from 3 axes.
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Matrix3.FromEulerAnglesXYZ(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
               Constructs this Matrix from 3 euler angles, in degrees.
            </summary>
            <param name="yaw"></param>
            <param name="pitch"></param>
            <param name="roll"></param>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            Multiply (concatenate) two Matrix3 instances together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            Multiply (concatenate) two Matrix3 instances together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Vector3,Axiom.Math.Matrix3)">
            <summary>
            	vector * matrix [1x3 * 3x3 = 1x3]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Vector3,Axiom.Math.Matrix3)">
            <summary>
            	vector * matrix [1x3 * 3x3 = 1x3]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Matrix3,Axiom.Math.Vector3)">
            <summary>
            	matrix * vector [3x3 * 3x1 = 3x1]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Matrix3,Axiom.Math.Vector3)">
            <summary>
            	matrix * vector [3x3 * 3x1 = 3x1]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Matrix3,Axiom.Math.Real)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Matrix3,Axiom.Math.Real)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Real,Axiom.Math.Matrix3)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Real,Axiom.Math.Matrix3)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Add(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Addition(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Subtract(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Subtraction(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Negate(Axiom.Math.Matrix3)">
            <summary>
            Negates all the items in the Matrix.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_UnaryNegation(Axiom.Math.Matrix3)">
            <summary>
            Negates all the items in the Matrix.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Equality(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Test two matrices for (value) equality
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Matrix4.
            </summary>
            <returns>A string representation of a vector3.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Equals(System.Object)">
            <summary>
            	Compares this Matrix to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Matrix3.Identity">
            <summary>
            Identity Matrix
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix3.Zero">
            <summary>
            Zero matrix.
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix3.Item(System.Int32,System.Int32)">
            <summary>
            Indexer for accessing the matrix like a 2d array (i.e. matrix[2,3]).
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix3.Item(System.Int32)">
            <summary>
            	Allows the Matrix to be accessed linearly (m[0] -> m[8]).  
            </summary>
        </member>
        <member name="T:Axiom.Graphics.StaticFaceGroup">
            <summary>
                Collects a group of static ie immovable faces together which have common
                properties like the material they use, the plane they lie on.
            </summary>
            <remarks>
                Whilst for discrete geometry (i.e. movable/scene objects) groups of faces are
                held in the SubMesh class, for immovable objects like scenery there
                needs to ba little more flexibility in the grouping since the group is
                likely to be a small part of a huge set of geometry. In addition, because
                the faces are unmoving certain optimisations can be performed, e.g.
                precalculating a world-coordinate bounding box and normal.
                <p/>
                Exactly how this class is used depends on the format of the large
                static geometry used in the level. An example would be the use of this
                class in the BspNode class for indoor levels.
                For flexibility and efficiency, it is not assumed that this class holds
                details of the vertices itself, or in fact that it holds the vertex indices
                itself. Everything is manipulated via pointers so if you want this
                class to point into a block of geometry data it can.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.type">
            <summary>
                Type of face group.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.isSky">
            <summary>
                Is this a sky surface?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.vertexStart">
            <summary>
                Index into a buffer containing vertex definitions. Because we're
                dealing with subsets of large levels this is likely to be part-way
                through a huge vertex buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.numVertices">
            <summary>
                The range of vertices in the buffer this facegroup references.
                This is really for copying purposes only, so that we know which
                subset of vertices to copy from our large-level buffer into the rendering buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.elementStart">
            <summary>
                Index into a buffer containing vertex indices. This buffer
                may be individual to this group or shared for memory allocation
                efficiency.  The vertex indexes are relative the the vertexStart pointer,
                not to the start of the large-level buffer, allowing simple reindexing
                when copying data into rendering buffers.
                This is only applicable to FaceGroup.FaceList face groups.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.numElements">
            <summary>
                The number of vertex indices. This is only applicable to FaceGroup.FaceList face group types.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.materialHandle">
            <summary>
                Handle to material used by this group.
                Note the use of the material handle rather than the material
                name - this is for efficiency since there will be many of these.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.patchSurf">
            <remarks>
                Patch surface (only applicable when type == FaceGroup.Patch)
            </remarks>
        </member>
        <member name="T:Axiom.FileSystem.FileInfo">
            <summary>Information about a file/directory within the archive will be returned using a FileInfo struct.</summary>
            <see cref="F:Axiom.FileSystem.FileInfo.Archive"/>
            <ogre name="FileInfo">
                <file name="OgreArchive.h" revision="1.7" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis"/>
            </ogre> 
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.Archive">
            The archive in which the file has been found (for info when performing
            multi-Archive searches, note you should still open through ResourceGroupManager)
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.Filename">
            The file's fully qualified name
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.Path">
            Path name; separated by '/' and ending with '/'
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.Basename">
            Base filename
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.CompressedSize">
            Compressed size
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.UncompressedSize">
            Uncompressed size
        </member>
        <member name="F:Axiom.FileSystem.FileInfo.ModifiedTime">
            Last modification time
        </member>
        <member name="T:Axiom.FileSystem.FileInfoList">
            <ogre name="FileInfoList">
                <file name="OgreArchive.h"   revision="1.7" lastUpdated="5/18/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
        </member>
        <member name="T:Axiom.Core.IPlugin">
            <summary>
            	Any class that wants to entend the functionality of the engine can implement this
            	interface.  Classes implementing this interface will automatically be loaded and
            	started by the engine during the initialization phase.  Examples of plugins would be
            	RenderSystems, SceneManagers, etc, which can register themself using the
            	singleton instance of the Engine class.
            </summary>
            <remarks>
            Axiom is very plugin-oriented and you can customize much of its behaviour
            by registering new plugins, dynamically if you are using dynamic linking.
            This class abstracts the generic interface that all plugins must support.
            Within the implementations of this interface, the plugin must call other
            Axiom classes in order to register the detailed customizations it is
            providing, e.g. registering a new SceneManagerFactory, a new
            MovableObjectFactory, or a new RenderSystem.
            <para />
            Plugins can be linked statically or dynamically. If they are linked
            dynamically (ie the plugin is in a DLL ), then you load the plugin by
            calling the Root.LoadPlugin method (or some other mechanism which leads
            to that call, e.g. app.config), passing the name of the DLL. Axiom
            will then call a global init function on that DLL, and it will be
            expected to register one or more Plugin implementations using
            Root.InstallPlugin. The procedure is very similar if you use a static
            linked plugin, except that you simply instantiate the Plugin implementation
            yourself and pass it to Root.InstallPlugin.
            </remarks>
            <note>
            Lifecycle of a Plugin instance is very important. The Plugin instance must
            remain valid until the Plugin is uninstalled. Here are the things you
            must bear in  mind:
            <ul><li>Create the Plugin anytime you like</li>
            <li>Call Root.InstallPlugin any time whilst Root is valid</li>
            <li>Call Root.UninstallPlugin if you like so long as Root is valid. However,
            it will be done for you when Root is destroyed, so the Plugin instance must
            still be valid at that point if you haven't manually uninstalled it.</li></ul>
            The install and uninstall methods will be called when the plugin is
            installed or uninstalled. The initialize and shutdown will be called when
            there is a system initialization or shutdown, e.g. when Root.Initialize
            or Root.Shutdown are called.
            </note>
        </member>
        <member name="M:Axiom.Core.IPlugin.Initialize">
            <summary>
            Perform any tasks the plugin needs to perform on full system initialization.
            </summary>
            <remarks>
            An implementation must be supplied for this method. It is called
            just after the system is fully initialized (either after Root.Initialize
            if a window is created then, or after the first window is created)
            and therefore all rendersystem functionality is available at this
            time. You can use this hook to create any resources which are
            dependent on a rendersystem or have rendersystem-specific implementations.
            </remarks>
        </member>
        <member name="M:Axiom.Core.IPlugin.Shutdown">
            <summary>
            Perform any tasks the plugin needs to perform when the system is shut down.
            </summary>
            <remarks>
            An implementation must be supplied for this method.
            This method is called just before key parts of the system are unloaded,
            such as rendersystems being shut down. You should use this hook to free up
            resources and decouple custom objects from the Axiom system, whilst all the
            instances of other plugins (e.g. rendersystems) still exist.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Billboard">
            <summary>
            	A billboard is a primitive which always faces the camera in every frame.
            </summary>
            <remarks>
            	Billboards can be used for special effects or some other trickery which requires the
            	triangles to always facing the camera no matter where it is. The engine groups billboards into
            	sets for efficiency, so you should never create a billboard on it's own (it's ok to have a
            	set of one if you need it).
            	<p/>
            	Billboards have their geometry generated every frame depending on where the camera is. It is most
            	beneficial for all billboards in a set to be identically sized since the engine can take advantage of this and
            	save some calculations - useful when you have sets of hundreds of billboards as is possible with special
            	effects. You can deviate from this if you wish (example: a smoke effect would probably have smoke puffs
            	expanding as they rise, so each billboard will legitimately have it's own size) but be aware the extra
            	overhead this brings and try to avoid it if you can.
            	<p/>
            	Billboards are just the mechanism for rendering a range of effects such as particles. It is other classes
            	which use billboards to create their individual effects, so the methods here are quite generic.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Billboard.rotationInRadians">
            <summary>
            	Needed for particle systems
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor(Axiom.Math.Vector3,Axiom.Core.BillboardSet)">
             <summary>
            
             </summary>
             <param name="position"></param>
             <param name="owner"></param>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor(Axiom.Math.Vector3,Axiom.Core.BillboardSet,Axiom.Core.ColorEx)">
             <summary>
            
             </summary>
             <param name="position"></param>
             <param name="owner"></param>
             <param name="color"></param>
        </member>
        <member name="M:Axiom.Core.Billboard.ResetDimensions">
            <summary>
            	Resets this billboard to use the parent BillboardSet's dimensions instead of it's own.
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.SetDimensions(System.Single,System.Single)">
            <summary>
            	Sets the width and height for this billboard.
            </summary>
            <param name="width">Width of the billboard.</param>
            <param name="height">Height of the billboard.</param>
        </member>
        <member name="M:Axiom.Core.Billboard.NotifyOwner(Axiom.Core.BillboardSet)">
            <summary>
            	Internal method for notifying a billboard of it's owner.
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:Axiom.Core.Billboard.Width">
            <summary>
            	Width and height of this billboard, if it has it's own.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.Height">
            <summary>
            	Width and height of this billboard, if it has it's own.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.HasOwnDimensions">
            <summary>
            	Specifies whether or not this billboard has different dimensions than the rest in the set.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.Rotation">
            <summary>
            	Gets/Sets the rotation in degrees.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.IControllerValue`1">
            <summary>
            	Classes that will be controlled by any type of Controller should implement
            	this interface to define how the controller will modifiy it's local data.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Collections.ConfigOptionMap">
            <summary>
            Represents a collection of <see cref="T:Axiom.Configuration.ConfigOption">ConfigOptions</see> that are sorted by key.
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.LightList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.Light">Lights</see>.
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.EntityList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.Entity">Entities</see>
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.SubEntityList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.SubEntity"/> objects
            </summary>
            <remarks>
            The items are sorted by their implicit index, it is important that the order of  subentities in the collection maps to the order
            of submeshes in a <see cref="T:Axiom.Core.Collections.SubMeshList"/>
            </remarks>
        </member>
        <member name="T:Axiom.Core.Collections.SubMeshList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.SubMesh">SubMeshes</see>
            </summary>
            <remarks>
            The items are sorted by their implicit index, it is important that the order of  submeshes in the collection maps to the order
            of subentities in a <see cref="T:Axiom.Core.Collections.SubEntityList"/>
            </remarks>
        </member>
        <member name="T:Axiom.Core.Collections.MeshLodUsageList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.LodValueList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.IntList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Core.Collections.FloatList">
            <summary>
            </summary>
        </member>
        <member name="T:Axiom.Serialization.Endian">
            <summary>
            The endianness of files
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Endian.Auto">
            <summary>
            The endianness of files
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Endian.Big">
            <summary>
            Use big endian (0x1000 is serialised as 0x10 0x00)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Endian.Little">
            <summary>
            Use little endian (0x1000 is serialised as 0x00 0x10)
            </summary>
        </member>
        <member name="T:Axiom.Serialization.RealStorageFormat">
            <summary>
            The storage format of Real values
            </summary>
        </member>
        <member name="F:Axiom.Serialization.RealStorageFormat.Float">
            <summary>
            Real is stored as float, reducing precision if you're using OGRE_DOUBLE_PRECISION
            </summary>
        </member>
        <member name="F:Axiom.Serialization.RealStorageFormat.Double">
            <summary>
            Real as stored as double, not useful unless you're using OGRE_DOUBLE_PRECISION
            </summary>
        </member>
        <member name="T:Axiom.Serialization.Chunk">
            <summary>
            Definition of a chunk of data in a file
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Chunk.id">
            <summary>
            Identifier of the chunk (for example from makeIdentifier)  (stored)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Chunk.version">
            <summary>
            Version of the chunk (stored)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Chunk.length">
            <summary>
            Length of the chunk data in bytes, excluding the header of this chunk (stored)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Chunk.offset">
            <summary>
            Location of the chunk (header) in bytes from the start of a stream (derived)
            </summary>
        </member>
        <member name="T:Axiom.Serialization.StreamSerializer">
            <summary>
            Utility class providing helper methods for reading / writing structured data held in a Stream.
            </summary>
            <remarks>
            The structure of a file read / written by this class is a series of 
            'chunks'. A chunk-based format has the advantage of being extensible later, 
            and it's robust, in that a reader can skip chunks that they are not 
            able (or willing) to process.
            <para />
            Chunks are contained serially in the file, but they can also be 
            nested in order both to provide context, and to group chunks together for 
            potential skipping. 
            <para />
            The data format of a chunk is as follows:
            -# Chunk ID (32-bit uint). This can be any number unique in a context, except the numbers 0x0000, 0x0001 and 0x1000, which are reserved for Ogre's use
            -# Chunk version (16-bit uint). Chunks can change over time so this version number reflects that
            -# Length (32-bit uint). The length of the chunk data section, including nested chunks. Note that
               this length excludes this header, but includes the header of any nested chunks. 
            -# Checksum (32-bit uint). Checksum value generated from the above - basically lets us check this is a valid chunk.
            -# Chunk data
            The 'Chunk data' section will contain chunk-specific data, which may include
            other nested chunks.
            </remarks>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.#ctor(System.IO.Stream)">
            <summary>
            Default constructor.
            </summary>
            <param name="stream">The stream on which you will read / write data.</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.#ctor(System.IO.Stream,Axiom.Serialization.Endian)">
            <summary>
            Constructor.
            </summary>
            <param name="stream">The stream on which you will read / write data.</param>
            <param name="endianMode">If true, the first write or read to this stream will 
            automatically read / write the header too. This is required if you
            set endianMode to Endian.Auto, but if you manually set the endian mode, 
            then you can skip writing / reading the header if you wish, if for example
            this stream is midway through a file which has already included header
            information.</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.#ctor(System.IO.Stream,Axiom.Serialization.Endian,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="stream">The stream on which you will read / write data.</param>
            <param name="endianMode">If true, the first write or read to this stream will 
            automatically read / write the header too. This is required if you
            set endianMode to Endian.Auto, but if you manually set the endian mode, 
            then you can skip writing / reading the header if you wish, if for example
            this stream is midway through a file which has already included header
            information.</param>
            <param name="autoHeader">If true, the first write or read to this stream will 
            automatically read / write the header too. This is required if you
            set endianMode to Endian.Auto, but if you manually set the endian mode, 
            then you can skip writing / reading the header if you wish, if for example
            this stream is midway through a file which has already included header
            information.</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.#ctor(System.IO.Stream,Axiom.Serialization.Endian,System.Boolean,Axiom.Serialization.RealStorageFormat)">
            <summary>
            Constructor.
            </summary>
            <param name="stream">The stream on which you will read / write data.</param>
            <param name="endianMode">If true, the first write or read to this stream will 
            automatically read / write the header too. This is required if you
            set endianMode to Endian.Auto, but if you manually set the endian mode, 
            then you can skip writing / reading the header if you wish, if for example
            this stream is midway through a file which has already included header
            information.</param>
            <param name="autoHeader">If true, the first write or read to this stream will 
            automatically read / write the header too. This is required if you
            set endianMode to Endian.Auto, but if you manually set the endian mode, 
            then you can skip writing / reading the header if you wish, if for example
            this stream is midway through a file which has already included header
            information.</param>
            <param name="realFormat">Set the format you want to write reals in. Only useful for files that 
            you're writing (since when reading this is picked up from the file), 
            and can only be changed if autoHeader is true, since real format is stored in the header. 
            Defaults to float unless you're using AXIOM_DOUBLE_PRECISION.</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.MakeIdentifier(System.String)">
            <summary>
            Pack a 4-character code into a 32-bit identifier.
            </summary>
            <param name="code"> Pack a 4-character code into a 32-bit identifier.</param>
            <remarks>You can use this to generate id's for your chunks based on friendlier 
            4-character codes rather than assigning numerical IDs, if you like.</remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.GetCurrentChunkDepth">
            <summary>
            Report the current depth of the chunk nesting, whether reading or writing.
            </summary>
            <returns>Returns how many levels of nested chunks are currently being processed, 
            either writing or reading. In order to tidily finish, you must call
            read/writeChunkEnd this many times.</returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadChunkBegin">
            <summary>
            Reads the start of the next chunk in the file.
            </summary>
            <remarks>
            Files are serialised in a chunk-based manner, meaning that each section
            of data is prepended by a chunk header. After reading this chunk header, 
            the next set of data is available directly afterwards.
            <para />
            When you have finished with this chunk, you should call readChunkEnd.
            This will perform a bit of validation and clear the chunk from 
            the stack.
            </remarks>
            <returns>The Chunk that comes next</returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadChunkBegin(System.UInt32,System.UInt16)">
            <summary>
            Reads the start of the next chunk so long as it's of a given ID and version.
            </summary>
            <remarks>
            Files are serialised in a chunk-based manner, meaning that each section
            of data is prepended by a chunk header. After reading this chunk header, 
            the next set of data is available directly afterwards.
            </remarks>
            <param name="id">The ID you're expecting. If the next chunk isn't of this ID, then
            the chunk read is undone and the method returns null.</param>
            <param name="maxVersion">The maximum version you're able to process. If the ID is correct
            but the version	exceeds what is passed in here, the chunk is skipped over,
            the problem logged and null is returned.</param>
            <returns>The chunk if it passes the validation</returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadChunkBegin(System.UInt32,System.UInt16,System.String)">
            <summary>
            Reads the start of the next chunk so long as it's of a given ID and version.
            </summary>
            <remarks>
            Files are serialised in a chunk-based manner, meaning that each section
            of data is prepended by a chunk header. After reading this chunk header, 
            the next set of data is available directly afterwards.
            </remarks>
            <param name="id">The ID you're expecting. If the next chunk isn't of this ID, then
            the chunk read is undone and the method returns null.</param>
            <param name="maxVersion">The maximum version you're able to process. If the ID is correct
            but the version	exceeds what is passed in here, the chunk is skipped over,
            the problem logged and null is returned.</param>
            <param name="msg">Descriptive text added to the log if versions are not compatible</param>
            <returns>The chunk if it passes the validation</returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.UndoReadChunk(System.UInt32)">
            <summary>
            Call this to 'rewind' the stream to just before the start of the current chunk. 
            </summary>
            <remarks>The most common case of wanting to use this is if you'd called <see cref="M:Axiom.Serialization.StreamSerializer.ReadChunkBegin"/>, 
            but the chunk you read wasn't one you wanted to process, and rather than
            skipping over it (which <see cref="M:Axiom.Serialization.StreamSerializer.ReadChunkEnd(System.UInt32)"/> would do), you want to backtrack
            and give something else an opportunity to read it. </remarks>
            <param name="id">The id of the chunk that you were reading (for validation purposes)</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadChunkEnd(System.UInt32)">
            <summary>
            Finish the reading of a chunk.
            </summary>
            <remarks>You can call this method at any point after calling <see cref="M:Axiom.Serialization.StreamSerializer.ReadChunkBegin"/>, even
            if you didn't read all the rest of the data in the chunk. If you did 
            not read to the end of a chunk, this method will automatically skip 
            over the remainder of the chunk and position the stream just after it.</remarks>
            <param name="id">The id of the chunk that you were reading (for validation purposes)</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.IsEndOfChunk(System.UInt32)">
            <summary>
            Return whether the current data pointer is at the end of the current chunk.
            </summary>
            <param name="id">The id of the chunk that you were reading (for validation purposes)</param>
            <returns>Return whether the current data pointer is at the end of the current chunk.</returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.WriteChunkBegin(System.UInt32)">
            <summary>
            Begin writing a new chunk.
            </summary>
            <remarks>
            This starts the process of writing a new chunk to the stream. This will 
            write the chunk header for you, and store a pointer so that the
            class can automatically go back and fill in the size for you later
            should you need it to. If you have already begun a chunk without ending
            it, then this method will start a nested chunk within it. Once written, 
            you can then start writing chunk-specific data into your stream.</remarks>
            <param name="id">The identifier of the new chunk. Any value that's unique in the
            file context is valid, except for the numbers 0x0001 and 0x1000 which are reserved
            for internal header identification use.</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.WriteChunkBegin(System.UInt32,System.UInt16)">
            <summary>
            Begin writing a new chunk.
            </summary>
            <remarks>
            This starts the process of writing a new chunk to the stream. This will 
            write the chunk header for you, and store a pointer so that the
            class can automatically go back and fill in the size for you later
            should you need it to. If you have already begun a chunk without ending
            it, then this method will start a nested chunk within it. Once written, 
            you can then start writing chunk-specific data into your stream.</remarks>
            <param name="id">The identifier of the new chunk. Any value that's unique in the
            file context is valid, except for the numbers 0x0001 and 0x1000 which are reserved
            for internal header identification use.</param>
            <param name="version">The version of the chunk you're writing</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.WriteChunkEnd(System.UInt32)">
            <summary>
            End writing a chunk.
            </summary>
            <param name="id">The identifier of the chunk - this is really just a safety check, 
            since you can only end the chunk you most recently started.</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Read``1">
            <summary>
            Reads an item from the stream
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <returns>new instance of type T</returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Read``1(``0@)">
            <summary>
            Reads an item from the stream
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <param name="data">new instance of type T</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Read``1(``0[]@)">
            <summary>
            Reads an item from the stream
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <param name="data">new instance of type T</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Read(System.String@)">
            <summary>
            Reads a string from the stream
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Read(Axiom.Core.Node@)">
            <summary>
            Reads a node from the stream
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Write``1(``0)">
            <summary>
            Write an item to the stream
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="data">instance of T to write</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Write``1(``0[])">
            <summary>
            Write an item to the stream
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="data">instance of T to write</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Write(System.String)">
            <summary>
            Write a string to the stream
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.Write(Axiom.Core.Node)">
            <summary>
            Write a node to the stream
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadHeader">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.WriteHeader">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadChunk">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.WriteChunk(System.UInt32,System.UInt16)">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.CheckStream">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.CheckStream(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.DetermineEndianness">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.ReadData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read arbitrary data to a stream.
            </summary>
            <param name="buf">Array of bytes to read into</param>
            <param name="size">The size of each element to read; each will be endian-flipped if necessary</param>
            <param name="count">The number of elements to read</param>
        </member>
        <member name="M:Axiom.Serialization.StreamSerializer.WriteData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write arbitrary data to a stream.
            </summary>
            <param name="buf">Array of bytes to write</param>
            <param name="size">The size of each element to write; each will be endian-flipped if necessary</param>
            <param name="count">The number of elements to write</param>
        </member>
        <member name="P:Axiom.Serialization.StreamSerializer.Endian">
            <summary>
            Get the endian mode.
            </summary>
            <remarks>
            If the result is Endian.Auto, this mode will change when the first piece of data is read / written.</remarks>
        </member>
        <member name="P:Axiom.Serialization.StreamSerializer.Eof">
            <summary>
            Reports whether the stream is at the end of file
            </summary>
        </member>
        <member name="P:Axiom.Serialization.StreamSerializer.CurrentChunk">
            <summary>
            Get the definition of the current chunk being read (if any).
            </summary>
        </member>
        <member name="P:Axiom.Serialization.StreamSerializer.CurrentChunkID">
            <summary>
            Get the ID of the chunk that's currently being read/written, if any.
            </summary>
            <remarks>The id of the current chunk being read / written (at the tightest
            level of nesting), or zero if no chunk is being processed.</remarks>
        </member>
        <member name="P:Axiom.Serialization.StreamSerializer.OffsetFromChunkStart">
            <summary>
            Get the current byte position relative to the start of the data section
            of the last chunk that was read or written.
            </summary>
            <remarks>Returns the offset. Note that a return value of 0 means that either the
            position is at the start of the chunk data section (ie right after the
            header), or that no chunk is currently active. Use getCurrentChunkID
            or getCurrentChunkDepth to determine if a chunk is active.</remarks>
        </member>
        <member name="P:Axiom.Serialization.StreamSerializer.NextChunkId">
            <summary>
            Call this to 'peek' at the next chunk ID without permanently moving the stream pointer.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerListener">
            <summary>
            This is a listener for the compiler. The compiler can be customized with
            this listener. It lets you listen in on events occuring during compilation,
            hook them, and change the behavior.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerListener.ImportFile(Axiom.Scripting.Compiler.ScriptCompiler,System.String)">
            <summary>
            Returns the concrete node list from the given file
            </summary>
            <param name="compiler">A reference to the compiler</param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerListener.PreConversion(Axiom.Scripting.Compiler.ScriptCompiler,System.Collections.Generic.IList{Axiom.Scripting.Compiler.ConcreteNode})">
            <summary>
            Allows for responding to and overriding behavior before a CST is translated into an AST
            </summary>
            <param name="compiler">A reference to the compiler</param>
            <param name="nodes"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerListener.PostConversion(Axiom.Scripting.Compiler.ScriptCompiler,System.Collections.Generic.IList{Axiom.Scripting.Compiler.AST.AbstractNode})">
             <summary>
             Allows vetoing of continued compilation after the entire AST conversion process finishes
             </summary>
             <remarks>
             Once the script is turned completely into an AST, including import
             and override handling, this function allows a listener to exit
             the compilation process.
            </remarks>
             <param name="compiler">A reference to the compiler</param>
             <param name="nodes"></param>
             <returns>True continues compilation, false aborts</returns>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerListener.HandleError(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.ScriptCompiler.CompileError)">
            <summary>
            Called when an error occurred
            </summary>
            <param name="compiler">A reference to the compiler</param>
            <param name="err"></param>
        </member>
        <member name="M:Axiom.Scripting.Compiler.ScriptCompilerListener.HandleEvent(Axiom.Scripting.Compiler.ScriptCompiler,Axiom.Scripting.Compiler.ScriptCompilerEvent@,System.Object@)">
            <summary>
            Called when an event occurs during translation, return true if handled
            </summary>
            <remarks>
            This function is called from the translators when an event occurs that
            that can be responded to. Often this is overriding names, or it can be a request for
            custom resource creation.
            </remarks>
            <param name="compiler">A reference to the compiler</param>
            <param name="evt">The event object holding information about the event to be processed</param>
            <param name="retVal">A possible return value from handlers</param>
            <returns>True if the handler processed the event</returns>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleVisualData">
            <summary>
            Abstract class containing any additional data required to be associated
            with a particle to perform the required rendering. 
            </summary>
            <remarks>
            Because you can specialise the way that particles are renderered by supplying
            custom ParticleSystemRenderer classes, you might well need some additional 
            data for your custom rendering routine which is not held on the default particle
            class. If that's the case, then you should define a subclass of this class, 
            and construct it when asked in your custom ParticleSystemRenderer class.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleVisualData.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Axiom.Media.PixelUtil.GetNumElemBytes(Axiom.Media.PixelFormat)">
            <summary>
               Returns the size in bytes of an element of the given pixel format.
            </summary>
            <param name="format">Pixel format to test.</param>
            <returns>Size in bytes.</returns>
        </member>
        <member name="M:Axiom.Media.PixelUtil.GetNumElemBits(Axiom.Media.PixelFormat)">
            <summary>
               Returns the size in bits of an element of the given pixel format.
            </summary>
            <param name="format">Pixel format to test.</param>
            <returns>Size in bits.</returns>
        </member>
        <member name="M:Axiom.Media.PixelUtil.GetMemorySize(System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
                Returns the size in memory of a region with the given extents and pixel
                format with consecutive memory layout.
            </summary>
            <param name="width">Width of the area</param>
            <param name="height">Height of the area</param>
            <param name="depth">Depth of the area</param>
            <param name="format">Format of the area</param>
            <returns>The size in bytes</returns>
            <remarks>
                In case that the format is non-compressed, this simply returns
                width * height * depth * PixelConverter.GetNumElemBytes(format). In the compressed
                case, this does serious magic.
            </remarks>
        </member>
        <member name="M:Axiom.Media.PixelUtil.GetFormatFromName(System.String)">
            <see cref="M:Axiom.Media.PixelUtil.GetFormatFromName(System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Media.PixelUtil.GetFormatFromName(System.String,System.Boolean)">
            <see cref="M:Axiom.Media.PixelUtil.GetFormatFromName(System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Media.PixelUtil.GetFormatFromName(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets the format from given name.
            </summary>
            <param name="name">The string of format name</param>
            <param name="accessibleOnly">If true, non-accessible format will treat as invalid format, otherwise, all supported formats are valid.</param>
            <param name="caseSensitive">Should be set true if string match should use case sensitivity.</param>
            <returns>The format match the format name, or <see cref="F:Axiom.Media.PixelFormat.Unknown"/> if is invalid name.</returns>
        </member>
        <member name="T:Axiom.Math.Vector4">
            <summary>
            4D homogeneous vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector4.#ctor(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Creates a new 4 dimensional Vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector4.Dot(Axiom.Math.Vector4)">
            <summary>
                Calculates the dot (scalar) product of this vector with another.
            </summary>
            <param name="vec">
                Vector with which to calculate the dot product (together with this one).
            </param>
            <returns>A Real representing the dot product value.</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.Multiply(Axiom.Math.Vector4,Axiom.Math.Matrix4)">
            <summary>
            	
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Vector4)">
            <summary>
            	
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Multiply(Axiom.Math.Vector4,Axiom.Math.Real)">
            <summary>
            	Multiplies a Vector4 by a scalar value.
            </summary>
            <param name="vector"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Equality(Axiom.Math.Vector4,Axiom.Math.Vector4)">
            <summary>
            	User to compare two Vector4 instances for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Addition(Axiom.Math.Vector4,Axiom.Math.Vector4)">
            <summary>
            	Used to add a Vector4 to another Vector4.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Subtraction(Axiom.Math.Vector4,Axiom.Math.Vector4)">
            <summary>
            	Used to subtract a Vector4 from another Vector4.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_UnaryNegation(Axiom.Math.Vector4)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Inequality(Axiom.Math.Vector4,Axiom.Math.Vector4)">
            <summary>
            	User to compare two Vector4 instances for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Vector4.
            </summary>
            <returns>A string representation of a Vector4.</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.Equals(System.Object)">
            <summary>
            	Compares this Vector to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.Parse(System.String)">
            <summary>
            	Parses a string and returns Vector4.
            </summary>
            <param name="vector">
                A string representation of a Vector4. ( as its returned from Vector4.ToString() )
            </param>
            <returns>
                A new Vector4.
            </returns>
        </member>
        <member name="P:Axiom.Math.Vector4.Zero">
            <summary>
            	Gets a Vector4 with all components set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector4.Item(System.Int32)">
            <summary>
            	Used to access a Vector by index 0 = this.x, 1 = this.y, 2 = this.z, 3 = this.w.  
            </summary>
            <remarks>
            	Uses unsafe pointer arithmetic to reduce the code required.
            </remarks>
        </member>
        <member name="T:Axiom.Input.KeyEventArgs">
            <summary>
            	Events args for keyboard input events.
            </summary>
        </member>
        <member name="T:Axiom.Input.InputEventArgs">
            <summary>
            Summary description for InputEvent.
            </summary>
        </member>
        <member name="F:Axiom.Input.InputEventArgs.modifiers">
            <summary>
            	Special keys currently pressed during this event.
            </summary>
        </member>
        <member name="F:Axiom.Input.InputEventArgs.handled">
            <summary>
            	Has this event been handled?
            </summary>
        </member>
        <member name="M:Axiom.Input.InputEventArgs.#ctor(Axiom.Input.ModifierKeys)">
            <summary>
            	Constructor.
            </summary>
            <param name="modifiers">Special modifier keys down at the time of this event.</param>
        </member>
        <member name="P:Axiom.Input.InputEventArgs.Handled">
            <summary>
            	Get/Set whether or not this input event has been handled.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputEventArgs.IsAltDown">
            <summary>
            	True if the alt key was down during this event.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputEventArgs.IsShiftDown">
            <summary>
            	True if the shift key was down during this event.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputEventArgs.IsControlDown">
            <summary>
            	True if the ctrl key was down during this event.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputEventArgs.Modifiers">
            <summary>
            	Gets the modifier keys that were down during this event.
            </summary>
            <remarks>
            	This is a combination of values from the <see cref="T:Axiom.Input.ModifierKeys"/> enum.
            </remarks>
        </member>
        <member name="F:Axiom.Input.KeyEventArgs.key">
            <summary>
            	Which key was pressed.
            </summary>
        </member>
        <member name="M:Axiom.Input.KeyEventArgs.#ctor(Axiom.Input.KeyCodes,Axiom.Input.ModifierKeys)">
            <summary>
            	Constructor.
            </summary>
            <param name="key">Key that was pressed.</param>
            <param name="modifiers">Modifier keys pressed at the time of the event.</param>
        </member>
        <member name="P:Axiom.Input.KeyEventArgs.Key">
            <summary>
            	The key that was pressed.
            </summary>
        </member>
        <member name="P:Axiom.Input.KeyEventArgs.KeyChar">
            <summary>
            	Character for the key that was pressed.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SpotShadowFadePng">
            <summary>
            	This exists so we don't have to be dependent on an external .png file
            	for this core feature (PNG used to fade out the edges of spotlight shadows)
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareIndexBuffer">
            <summary>
            	Describes the graphics API independent functionality required by a hardware
            	index buffer.  
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareIndexBuffer.type">
            <summary>
            	Type of index (16 or 32 bit).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareIndexBuffer.numIndices">
            <summary>
            	Number of indices in this buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareIndexBuffer.indexSize">
            <summary>
                Size of each index.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareIndexBuffer.#ctor(Axiom.Graphics.HardwareBufferManagerBase,Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
             <summary>
            		Constructor.
             </summary>
            <param name="manager"></param>
            <param name="type">Type of index (16 or 32 bit).</param>
             <param name="numIndices">Number of indices to create in this buffer.</param>
             <param name="usage">Buffer usage.</param>
             <param name="useSystemMemory">Create in system memory?</param>
             <param name="useShadowBuffer">Use a shadow buffer for reading/writing?</param>
        </member>
        <member name="P:Axiom.Graphics.HardwareIndexBuffer.Type">
            <summary>
            	Gets an enum specifying whether this index buffer is 16 or 32 bit elements.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareIndexBuffer.IndexCount">
            <summary>
            	Gets the number of indices in this buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareIndexBuffer.IndexSize">
            <summary>
                Gets the size (in bytes) of each index element.
            </summary>
            <value></value>
        </member>
        <member name="T:Axiom.Core.SubMesh">
            <summary>
            	Defines a part of a complete 3D mesh.
            </summary>
            <remarks>
            	Models which make up the definition of a discrete 3D object
            	are made up of potentially multiple parts. This is because
            	different parts of the mesh may use different materials or
            	use different vertex formats, such that a rendering state
            	change is required between them.
            	<p/>
            	Like the Mesh class, instatiations of 3D objects in the scene
            	share the SubMesh instances, and have the option of overriding
            	their material differences on a per-object basis if required.
            	See the SubEntity class for more information.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SubMesh.parent">
            <summary>The parent mesh that this subMesh belongs to.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.materialName">
            <summary>Name of the material assigned to this subMesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.name">
            <summary>Name of this SubMesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.isMaterialInitialized">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.boneAssignmentList">
            <summary>List of bone assignment for this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.boneAssignmentsOutOfDate">
            <summary>Flag indicating that bone assignments need to be recompiled.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.operationType">
            <summary>Mode used for rendering this submesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.useSharedVertices">
            <summary>Indicates if this submesh shares vertex data with other meshes or whether it has it's own vertices.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.vertexAnimationType">
            <summary>Type of vertex animation for dedicated vertex data (populated by Mesh)</summary>
        </member>
        <member name="M:Axiom.Core.SubMesh.#ctor">
            <summary>
            	Basic contructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubMesh.AddBoneAssignment(Axiom.Animating.VertexBoneAssignment)">
            <summary>
               Assigns a vertex to a bone with a given weight, for skeletal animation.
            </summary>
            <remarks>
               This method is only valid after setting the SkeletonName property.
               You should not need to modify bone assignments during rendering (only the positions of bones)
               and the engine reserves the right to do some internal data reformatting of this information,
               depending on render system requirements.
            </remarks>
            <param name="boneAssignment"></param>
        </member>
        <member name="M:Axiom.Core.SubMesh.ClearBoneAssignments">
            <summary>
               Removes all bone assignments for this mesh.
            </summary>
            <remarks>
               This method is for modifying weights to the shared geometry of the Mesh. To assign
               weights to the per-SubMesh geometry, see the equivalent methods on SubMesh.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SubMesh.CompileBoneAssignments">
            <summary>
               Must be called once to compile bone assignments into geometry buffer.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubMesh.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SubMesh.GetRenderOperation(Axiom.Graphics.RenderOperation,System.Int32)">
            <summary>
               Fills a RenderOperation structure required to render this mesh.
            </summary>
            <param name="op">Reference to a RenderOperation structure to populate.</param>
            <param name="lodIndex">The index of the LOD to use.</param>
        </member>
        <member name="P:Axiom.Core.SubMesh.Name">
            <summary>
            	Gets/Sets the name of this SubMesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubMesh.MaterialName">
            <summary>
            	Gets/Sets the name of the material this SubMesh will be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubMesh.Parent">
            <summary>
            	Gets/Sets the parent mode of this SubMesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubMesh.IsMaterialInitialized">
            <summary>
            	Gets whether or not a material has been set for this subMesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubMesh.BoneAssignmentList">
            <summary>
            	Gets bone assigment list
            </summary>
        </member>
        <member name="T:Axiom.Core.StringConverter">
            <summary>
                Helper class for going back and forth between strings and various types.
            </summary>
        </member>
        <member name="F:Axiom.Core.StringConverter.englishCulture">
            <summary>
            	Culture info to use for parsing numeric data.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.#ctor">
            <summary>
                Private constructor so no instances can be created.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseBool(System.String)">
            <summary>
            	Parses a boolean type value
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseColor(System.String[])">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseColor(System.String)">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseVector3(System.String[])">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseVector3(System.String)">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseVector4(System.String[])">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseFloat(System.String)">
            <summary>
            	Parse a float value from a string.
            </summary>
            <remarks>
            	Since our file formats assume the 'en-US' style format for numbers, we need to
            	let the framework know that where numbers are being parsed.
            </remarks>
            <param name="val">String value holding the float.</param>
            <returns>A float representation of the string value.</returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(Axiom.Core.ColorEx)">
             <summary>
            
             </summary>
             <param name="color"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(Axiom.Math.Vector4)">
             <summary>
            
             </summary>
             <param name="vec"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(Axiom.Math.Vector3)">
             <summary>
            
             </summary>
             <param name="vec"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(System.Single)">
            <summary>
                Converts a
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.Root">
            <summary>
            	The Engine class is the main container of all the subsystems.  This includes the RenderSystem, various ResourceManagers, etc.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.instance">
            <summary>
                Singleton instance of Root.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.#ctor">
            <summary>
                Constructor.
            </summary>
            <remarks>
                This public contructor is intended for the user to decide when the Root object gets instantiated.
                This is a critical step in preparing the engine for use.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.#ctor(System.String)">
            <summary>
                Constructor.
            </summary>
            <remarks>
                This public contructor is intended for the user to decide when the Root object gets instantiated.
                This is a critical step in preparing the engine for use.
            </remarks>
            <param name="logFilename">Name of the default log file.</param>
        </member>
        <member name="F:Axiom.Core.Root.activeRenderSystem">
            <summary>
                Current active render system.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.autoWindow">
            <summary>
                Auto created window (if one was created).
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.averageFPS">
            <summary>
                Average frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.currentFPS">
            <summary>
                Current frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.currentFrameCount">
            <summary>
            	Global frame count since startup.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.firstTimePostWindowInit">
            <summary>
               In case multiple render windows are created, only once are the resources loaded.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.frameCount">
            <summary>
                Frames drawn counter for FPS calculations.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.highestFPS">
            <summary>
                Highest recorded frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastCalculationTime">
            <summary>
                The last time we calculated the framerate.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastEndTime">
            <summary>
                End time of last frame.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastQueuedTime">
            <summary>
                Start queued stage of last frame.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastStartTime">
            <summary>
                Start time of last frame.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.logMgr">
            <summary>
            Holds instance of LogManager
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lowestFPS">
            <summary>
                Lowest recorded frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.queuedEnd">
            <summary>
            	True if a request has been made to shutdown the rendering engine.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.renderSystemList">
            <summary>
                List of available render systems.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.sceneManager">
            <summary>
                Current active scene manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.sceneManagerEnumerator">
            <summary>
                List of available scene managers.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.secondsBetweenFPSAverages">
            <summary>
                How often we determine the FPS average, in seconds
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.suspendRendering">
            <summary>
            	True if a request has been made to suspend rendering, typically because the
                form has been minimized
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.timer">
            <summary>
                Current active timer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.microsecondsPerFrame">
            <summary>
               The number of microseconds per frame when we're
               limiting frame rates.  By default, we don't limit frame
               rates, and in that case, the number is 0.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.microsecondsPerTick">
            <summary>
               The number of microseconds per tick; obviously a fraction
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.AddSceneManagerFactory(Axiom.Core.SceneManagerFactory)">
            <summary>
            	Registers a new SceneManagerFactory, a factory object for creating instances
            	of specific SceneManagers.
            </summary>
            <remarks>
            	Plugins should call this to register as new SceneManager providers.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.Core.Root.RemoveSceneManagerFactory(Axiom.Core.SceneManagerFactory)">
            <summary>
            	Unregisters a SceneManagerFactory.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.Core.Root.GetSceneManagerMetaData(System.String)">
            <summary>
            	Gets more information about a given type of SceneManager.
            </summary>
            <remarks>
            	The metadata returned tells you a few things about a given type
            	of SceneManager, which can be created using a factory that has been
            	registered already.
            </remarks>
            <param name="typeName">
            	The type name of the SceneManager you want to enquire on.
            	If you don't know the typeName already, you can iterate over the
            	metadata for all types using getMetaDataIterator.
            </param>
        </member>
        <member name="M:Axiom.Core.Root.CreateSceneManager(System.String)">
            <summary>
            	Creates a <see cref="P:Axiom.Core.Root.SceneManager"/> instance of a given type.
            </summary>
            <remarks>
            	You can use this method to create a SceneManager instance of a
            	given specific type. You may know this type already, or you may
            	have discovered it by looking at the results from <see cref="M:Axiom.Core.Root.GetSceneManagerMetaData(System.String)"/>.
            </remarks>
            <param name="typeName">String identifying a unique SceneManager type.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.CreateSceneManager(System.String,System.String)">
            <summary>
            	Creates a <see cref="P:Axiom.Core.Root.SceneManager"/> instance of a given type.
            </summary>
            <remarks>
            	You can use this method to create a SceneManager instance of a
            	given specific type. You may know this type already, or you may
            	have discovered it by looking at the results from <see cref="M:Axiom.Core.Root.GetSceneManagerMetaData(System.String)"/>.
            </remarks>
            <param name="typeName">String identifying a unique SceneManager type.</param>
            <param name="instanceName">
            	Optional name to given the new instance that is created.
            	If you leave this blank, an auto name will be assigned.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.CreateSceneManager(Axiom.Core.SceneType)">
            <summary>
            	Creates a <see cref="P:Axiom.Core.Root.SceneManager"/> instance based on scene type support.
            </summary>
            <remarks>
            	Creates an instance of a <see cref="P:Axiom.Core.Root.SceneManager"/> which supports the scene types
            	identified in the parameter. If more than one type of SceneManager
            	has been registered as handling that combination of scene types,
            	in instance of the last one registered is returned.
            </remarks>
            <param name="sceneType"> A mask containing one or more <see cref="T:Axiom.Core.SceneType"/> flags.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.CreateSceneManager(Axiom.Core.SceneType,System.String)">
            <summary>
            	Creates a <see cref="P:Axiom.Core.Root.SceneManager"/> instance based on scene type support.
            </summary>
            <remarks>
            	Creates an instance of a <see cref="P:Axiom.Core.Root.SceneManager"/> which supports the scene types
            	identified in the parameter. If more than one type of SceneManager
            	has been registered as handling that combination of scene types,
            	in instance of the last one registered is returned.
            </remarks>
            <param name="sceneType"> A mask containing one or more <see cref="T:Axiom.Core.SceneType"/> flags.</param>
            <param name="instanceName">
            	Optional name to given the new instance that is
            	created. If you leave this blank, an auto name will be assigned.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.DestroySceneManager(Axiom.Core.SceneManager)">
            <summary>
            	Destroys an instance of a SceneManager.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Axiom.Core.Root.GetSceneManager(System.String)">
            <summary>
            	Gets an existing SceneManager instance that has already been created,
            	identified by the instance name.
            </summary>
            <param name="instanceName">The name of the instance to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.Initialize(System.Boolean)">
            <summary>
               Initializes the renderer.
            </summary>
            <remarks>
                This method can only be called after a renderer has been
                selected with <see cref="P:Axiom.Core.Root.RenderSystem"/>, and it will initialize
                the selected rendering system ready for use.
            </remarks>
            <param name="autoCreateWindow">
                If true, a rendering window will automatically be created. The window will be
                created based on the options currently set on the render system.
            </param>
            <returns>A reference to the automatically created window (if requested), or null otherwise.</returns>
        </member>
        <member name="M:Axiom.Core.Root.Initialize(System.Boolean,System.String)">
            <summary>
               Initializes the renderer.
            </summary>
            <remarks>
                This method can only be called after a renderer has been
                selected with <see cref="P:Axiom.Core.Root.RenderSystem"/>, and it will initialize
                the selected rendering system ready for use.
            </remarks>
            <param name="autoCreateWindow">
                If true, a rendering window will automatically be created The window will be
                created based on the options currently set on the render system.
            </param>
            <param name="windowTitle">Title to use by the window.</param>
            <returns>A reference to the automatically created window (if requested), or null otherwise.</returns>
        </member>
        <member name="M:Axiom.Core.Root.OneTimePostWindowInit">
            <summary>
               Internal method for one-time tasks after first window creation.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            	Overloaded method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)">
            <summary>
            	A collection of addition render system specific options.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.ConvertColor(Axiom.Core.ColorEx)">
            <summary>
            	Asks the current API to convert an instance of ColorEx to a 4 byte packed
            	int value the way it would expect it.
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.DetachRenderTarget(Axiom.Graphics.RenderTarget)">
             <summary>
            
             </summary>
             <param name="target"></param>
        </member>
        <member name="M:Axiom.Core.Root.RenderOneFrame">
            <summary>
            	Renders one frame.
            </summary>
            <remarks>
            	Updates all the render targets automatically and then returns, raising frame events before and after.
            </remarks>
            <returns>True if execution should continue, false if a quit was requested.</returns>
        </member>
        <member name="M:Axiom.Core.Root.StartRendering">
            <summary>
            	Starts the default rendering loop.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.Shutdown">
            <summary>
            	Shuts down the engine and unloads plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.QueueEndRendering">
            <summary>
            	Requests that the rendering engine shutdown at the beginning of the next frame.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.UpdateAllRenderTargets">
            <summary>
                Internal method used for updating all <see cref="T:Axiom.Graphics.RenderTarget"/> objects (windows,
                renderable textures etc) which are set to auto-update.
            </summary>
            <remarks>
                You don't need to use this method if you're using Axiom's own internal
                rendering loop (<see cref="M:Axiom.Core.Root.StartRendering"/>). If you're running your own loop
                you may wish to call it to update all the render targets which are
                set to auto update (<see cref="P:Axiom.Graphics.RenderTarget.IsAutoUpdated"/>). You can also update
                individual <see cref="T:Axiom.Graphics.RenderTarget"/> instances using their own Update() method.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.Dispose">
            <summary>
            	Called to shutdown the engine and dispose of all it's resources.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.CalculateEventTime(System.Int64,Axiom.Core.FrameEventType)">
            <summary>
               Internal method for calculating the average time between recently fired events.
            </summary>
            <param name="time">The current time in milliseconds.</param>
            <param name="type">The type event to calculate.</param>
            <returns>Average time since last event of the same type.</returns>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameStarted">
            <summary>
               Method for raising frame started events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on
               this.
               <p/>
               This method calculates the frame timing information for you based on the elapsed
               time. If you want to specify elapsed times yourself you should call the other
               version of this method which takes event details as a parameter.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameRenderingQueued">
            <summary>
               Method for raising frame rendering queued events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you you may want to call this method too, although nothing in Axiom relies on this
               particular event. Really if you're running your own rendering loop at
               this level of detail then you can get the same effect as doing your
               updates in a OnFrameRenderingQueued event by just calling
               <see name="RenderWindow.Update" /> with the 'swapBuffers' option set to false.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameEnded">
            <summary>
               Method for raising frame ended events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on
               this.
               <p/>
               This method calculates the frame timing information for you based on the elapsed
               time. If you want to specify elapsed times yourself you should call the other
               version of this method which takes event details as a parameter.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameStarted(Axiom.Core.FrameEventArgs)">
            <summary>
               Method for raising frame started events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on
               this.
               <p/>
               This method takes an event object as a parameter, so you can specify the times
               yourself. If you are happy for the engine to automatically calculate the frame time
               for you, then call the other version of this method with no parameters.
            </remarks>
            <param name="e">
               Event object which includes all the timing information which must already be
               calculated.  RequestShutdown should be checked after each call, because that means
               an event handler is requesting that shudown begin for one reason or another.
            </param>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameRenderingQueued(Axiom.Core.FrameEventArgs)">
            <summary>
               Method for raising frame rendering queued events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you you may want to call this method too, although nothing in Axiom relies on this
               particular event. Really if you're running your own rendering loop at
               this level of detail then you can get the same effect as doing your
               updates in a OnFrameRenderingQueued event by just calling
               <see name="RenderWindow.Update" /> with the 'swapBuffers' option set to false.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameEnded(Axiom.Core.FrameEventArgs)">
            <summary>
               Method for raising frame ended events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on
               this.
               <p/>
               This method takes an event object as a parameter, so you can specify the times
               yourself. If you are happy for the engine to automatically calculate the frame time
               for you, then call the other version of this method with no parameters.
            </remarks>
            <param name="e">
               Event object which includes all the timing information which must already be
               calculated.  RequestShutdown should be checked after each call, because that means
               an event handler is requesting that shudown begin for one reason or another.
            </param>
        </member>
        <member name="M:Axiom.Core.Root.NextMovableObjectTypeFlag">
            <summary>
                Allocate and retrieve the next MovableObject type flag.
            </summary>
            <remarks>
                This is done automatically if MovableObjectFactory.RequestTypeFlags
                returns true; don't call this manually unless you're sure you need to.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.HasMovableObjectFactory(System.String)">
            <summary>
                Checks whether a factory is registered for a given MovableObject type
            </summary>
            <param name="typeName">
                The factory type to check for.
            </param>
            <returns>True if the factory type is registered.</returns>
        </member>
        <member name="M:Axiom.Core.Root.GetMovableObjectFactory(System.String)">
            <summary>
                Get a MovableObjectFactory for the given type.
            </summary>
            <param name="typeName">
                The factory type to obtain.
            </param>
            <returns>
                A factory for the given type of MovableObject.
            </returns>
        </member>
        <member name="M:Axiom.Core.Root.RemoveMovableObjectFactory(Axiom.Core.MovableObjectFactory)">
            <summary>
                Removes a previously registered MovableObjectFactory.
            </summary>
            <remarks>
                All instances of objects created by this factory will be destroyed
                before removing the factory (by calling back the factories
                'DestroyInstance' method). The plugin writer is responsible for actually
                destroying the factory.
            </remarks>
            <param name="fact">The instance to remove.</param>
        </member>
        <member name="M:Axiom.Core.Root.AddMovableObjectFactory(Axiom.Core.MovableObjectFactory,System.Boolean)">
            <summary>
                Register a new MovableObjectFactory which will create new MovableObject
                instances of a particular type, as identified by the Type property.
            </summary>
            <remarks>
                Plugin creators can create subclasses of MovableObjectFactory which
                construct custom subclasses of MovableObject for insertion in the
                scene. This is the primary way that plugins can make custom objects
                available.
            </remarks>
            <param name="fact">
                The factory instance.
            </param>
            <param name="overrideExisting">
                Set this to true to override any existing
                factories which are registered for the same type. You should only
                change this if you are very sure you know what you're doing.
            </param>
        </member>
        <member name="P:Axiom.Core.Root.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
            <value></value>
        </member>
        <member name="P:Axiom.Core.Root.AutoWindow">
            <summary>
                Gets the Auto created window (if one was created).
            </summary>
        </member>
        <member name="E:Axiom.Core.Root.FrameStarted">
            <summary>
            Fired as a frame is about to be rendered.
            </summary>
        </member>
        <member name="E:Axiom.Core.Root.FrameEnded">
            <summary>
            Fired after a frame has completed rendering.
            </summary>
        </member>
        <member name="E:Axiom.Core.Root.FrameRenderingQueued">
            <summary>
            Fired after a frame has completed rendering.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.Copyright">
            <summary>
            Specifies the name of the engine that will be used where needed (i.e. log files, etc).
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.Version">
            <summary>
            Returns the current version of the Engine assembly.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.SceneManager">
             <summary>
            		Gets the scene manager currently being used to render a frame.
             </summary>
             <remarks>
            		This is only intended for internal use; it is only valid during the
            		rendering of a frame.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Root.SceneManagerList">
            <summary>
            	Gets a list over all the existing SceneManager instances.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.MetaDataList">
            <summary>
            	Gets a list of all types of SceneManager available for construction,
            	providing some information about each one.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.RenderSystem">
            <summary>
            Gets/Sets the current active RenderSystem that the engine is using.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.RenderSystems">
            <summary>
            The list of available render systems for the engine to use (made available via plugins).
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.Timer">
            <summary>
               Gets a reference to the timer being used for timing throughout the engine.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.MaxFramesPerSecond">
            <summary>
               Gets or sets the maximum frame rate, in frames per second
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.SecondsBetweenFPSAverages">
            <summary>
               Access to the float that determines how often we compute the FPS average
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.CurrentFrameCount">
            <summary>
            	Gets the number of frames drawn since startup.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.CurrentFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.BestFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.WorstFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.AverageFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.SuspendRendering">
            <summary>
                Exposes the mechanism to suspend rendering
            </summary>
        </member>
        <member name="T:Axiom.Core.FrameEventArgs">
            <summary>
            	Used to supply info to the FrameStarted and FrameEnded events.
            </summary>
        </member>
        <member name="F:Axiom.Core.FrameEventArgs.StopRendering">
            <summary>
            Request that the renderer stop the render loop
            </summary>
        </member>
        <member name="F:Axiom.Core.FrameEventArgs.TimeSinceLastEvent">
            <summary>
               Time elapsed (in milliseconds) since the last frame event.
            </summary>
        </member>
        <member name="F:Axiom.Core.FrameEventArgs.TimeSinceLastFrame">
            <summary>
               Time elapsed (in milliseconds) since the last frame.
            </summary>
        </member>
        <member name="T:Axiom.Core.PlatformManager">
            <summary>
            	Class which manages the platform settings required to run.
            </summary>
        </member>
        <member name="F:Axiom.Core.PlatformManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.PlatformManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="P:Axiom.Core.PlatformManager.IsWindowsOS">
            <summary>
            Gets if the operating system that this is running on is Windows (as opposed to a Unix-based one such as Linux or Mac OS X)
            </summary>
            <remarks>
            The Windows version strings start with "Microsoft Windows" followed by CE, NT, or 98 and the version number,
            however Microsoft Win32S is used with the 32-bit simulation layer on 16-bit systems so we should just check for the presence of Microsoft
            Unix-based operating systems start with Unix
            The Environment.OSVersion.Platform is 128 for Unix-based platforms (an additional enum value added that by the name Unix),
            however under .NET 2.0 Unix is supposed to be 3 but may still be 128 under Mono
            Additionally, GNU Portable .NET likely doesn't provide this same value, so just check for the presence of Windows in the string name
            </remarks>
        </member>
        <member name="P:Axiom.Core.PlatformManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshManager">
            <summary>
            	Handles the management of mesh resources.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshManager._prepAllMeshesForShadowVolumes">
            <summary>
            	Flag indicating whether newly loaded meshes should also be prepared for
            	shadow volumes.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.Initialize">
            <summary>
            	Called internally to initialize this manager.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateManual(System.String,System.String,Axiom.Core.IManualResourceLoader)">
            <summary>
            	Creates a barebones Mesh object that can be used to manually define geometry later on.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.Load(System.String,System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.Load(System.String,System.String,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreatePlane(System.String,System.String,Axiom.Math.Plane,System.Int32,System.Int32)">
             <summary>
            		Overloaded method.
             </summary>
             <param name="name">Name of the plane mesh.</param>
            <param name="group"></param>
            <param name="plane">Plane to use for distance and orientation of the mesh.</param>
             <param name="width">Width in world coordinates.</param>
             <param name="height">Height in world coordinates.</param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreatePlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="name">Name of the plane mesh.</param>
             <param name="group"></param>
             <param name="plane">Plane to use for distance and orientation of the mesh.</param>
             <param name="width">Width in world coordinates.</param>
             <param name="height">Height in world coordinates.</param>
             <param name="xSegments">Number of x segments for tesselation.</param>
             <param name="ySegments">Number of y segments for tesselation.</param>
             <param name="normals">If true, plane normals are created.</param>
             <param name="texCoordSetCount">Number of 2d texture coord sets to use.</param>
             <param name="uTile">Number of times the texture should be repeated in the u direction.</param>
             <param name="vTile">Number of times the texture should be repeated in the v direction.</param>
             <param name="upVec">The up direction of the plane.</param>
             <param name="vertexBufferUsage"></param>
             <param name="indexBufferUsage"></param>
             <param name="vertexShadowBuffer"></param>
             <param name="indexShadowBuffer"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedPlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedPlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single,Axiom.Math.Real,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedPlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single,Axiom.Math.Real,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Axiom.Math.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateBezierPatch(System.String,System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
                Creates a Bezier patch based on an array of control vertices.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager._tesselate2DMesh(Axiom.Core.SubMesh,System.Int32,System.Int32,System.Boolean,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Used to generate a face list based on vertices.
            </summary>
        </member>
        <member name="P:Axiom.Core.MeshManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="E:Axiom.Core.MeshManager.ProcessMaterialName">
            <summary>
            This event allows users to hook into the mesh loading process and
            modify references within the mesh as they are loading. Material 
            references can be processed using this event which allows
            finer control over resources.
            </summary>
        </member>
        <member name="E:Axiom.Core.MeshManager.ProcessSkeletonName">
            <summary>
            This event allows users to hook into the mesh loading process and
            modify references within the mesh as they are loading. Skeletal 
            references can be processed using this event which allows
            finer control over resources.
            </summary>
        </member>
        <member name="P:Axiom.Core.MeshManager.PrepareAllMeshesForShadowVolumes">
            <summary>
            	Tells the mesh manager that all future meshes should prepare themselves for
            	shadow volumes on loading.
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshManager.MeshBuildType">
            <summary>
            Enum identifying the types of manual mesh built by this manager
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshManager.MeshBuildParams">
            <summary>
            Saved parameters used to (re)build a manual mesh built by this class
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshSerializerArgs">
            <summary>
            Used to supply info to the ProcessMaterialName and ProcessSkeletonName events.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshSerializerArgs.Mesh">
            <summary>
            The mesh being serialized
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshSerializerArgs.Name">
            <summary>
            The name of the the Mesh/Skeleton to process
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.TexCoordModifierControllerValue">
            <summary>
            Summary description for TexCoordModifierControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Core.ObjectManager">
            <summary>
            Monitors the object lifetime of objects that are in control of unmanaged resources
            </summary>
        </member>
        <member name="M:Axiom.Core.ObjectManager.Add(Axiom.Core.DisposableObject,System.String)">
            <summary>
            Add an object to be monitored
            </summary>
            <param name="instance">
            A <see cref="T:Axiom.Core.DisposableObject"/> to monitor for proper disposal
            </param>
            <param name="stackTrace"></param>
        </member>
        <member name="T:Axiom.Serialization.MeshChunkID">
            <summary>
            	Values that mark data chunks in the .mesh file.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Header">
            <summary>
            	string vesion;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Mesh">
            <summary>
            	bool skeletallyAnimated: Important flag which affects h/w buffer policies
            	Optional Geometry chunk.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMesh">
            <summary>
            	string materialName;
            	bool useSharedVertices;
            	uint indexCount;
            	bool indexes32Bit;
            	uint[indexCount]/ushort[indexCount] faceVertexIndices;
            	M_GEOMETRY chunk (Optional: present only if useSharedVertices = false)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMeshOperation">
            <summary>
            	ushort operationType: Optional - TriangleList assumed if missing.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMeshBoneAssignment">
            <summary>
            	Optional bone weights (repeating section)
            	uint vertexIndex;
            	ushort boneIndex;
            	float weight;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Geometry">
            <summary>
            	This chunk is embedded within Mesh and SubMesh.
            	uint vertexCount;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryVertexDeclaration">
            <summary>
            	Beginning of a vertex delcaraion section.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryNormals">
            <summary>
            	Optional (pre 1.30).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryVertexElement">
            <summary>
            	Repeating section.
            	ushort source:		buffer bind source
            	ushort type:		VertexElementType
            	ushort semantic:	VertexElementSemantic
            	ushort offset:		start offset in buffer in bytes
            	ushort index:		index of the semantic (for colours and texture coords)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryVertexBuffer">
            <summary>
            	Repeating section.
            	ushort bindIndex:	Index to bind this buffer to
            	ushort vertexSize:	Per-vertex size, must agree with declaration at this index
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryColors">
            <summary>
            	Optional (pre 1.30).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryVertexBufferData">
            <summary>
            	Raw buffer data.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryTexCoords">
            <summary>
            	Optional, REPEATABLE, each one adds an extra set.  (pre 1.30).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshSkeletonLink">
            <summary>
            	Optional link to skeleton.
            	string skeletonName:	name of .skeleton to use
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshBoneAssignment">
            <summary>
            	Optional bone weights (repeating section)
            	uint vertexIndex;
            	ushort boneIndex;
            	float weight;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshLOD">
            <summary>
            	Optional LOD information
            	ushort numLevels;
            	bool manual;  (true for manual alternate meshes, false for generated)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshLODUsage">
            <summary>
            	Repeating section, ordered in increasing depth
            	LOD 0 (full detail from 0 depth) is omitted
            	float fromSquaredDepth;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshLODManual">
            <summary>
            	Required if MeshLOD section manual = true
            	string manualMeshName;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshLODGenerated">
            <summary>
            	Required if MeshLOD section manual = false
            	Repeating section (1 per submesh)
            	uint indexCount;
            	bool indexes32Bit
            	ushort[indexCount]/uint[indexCount] faceIndexes;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshBounds">
            <summary>
            	float minx, miny, minz;
            	float maxx, maxy, maxz;
            	float radius;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMeshNameTable">
            <summary>
            	Added By DrEvil
            	Optional chunk that contains a table of submesh indexes and the names of
            	the sub-meshes.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMeshNameTableElement">
            <summary>
            	short index;
            	string name;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.EdgeLists">
            <summary>
            	Optional chunk which stores precomputed edge data.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.EdgeListLOD">
            <summary>
            	Each LOD has a seperate edge list.
            	ushort		lodIndex;
            	bool		isManual:	If manual, no edge data here, loaded from manual mesh
            	ulong		numTriangles
            	ulong		numEdgeGroups
            	Triangle	triangleList[numTriangles];
            	ulong		indexSet
            	ulong		vertexSet
            	ulong		vertIndex[3]
            	ulong		sharedVertIndex[3] 
            	float		normal[4]
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.EdgeListGroup">
            <summary>
            	ulong	vertexSet;
            	ulong	numEdges;
            	Edge	edgeList[numEdges];
            	ulong	triIndex[2];
            	ulong	vertIndex[2];
            	ulong	sharedVertIndex[2];
            	bool	degenerate;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Poses">
            <summary>
            	Optional poses section, referred to by pose keyframes
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Pose">
            <summary>
            	string name;
                ushort target - 0 for shared geometry; 1+ for submesh index + 1
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.PoseVertex">
            <summary>
            	ulong vertexIndex
                float xoffset, yoffset, zoffset
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Animations">
            <summary>
            	Optional vertex animation chunk
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Animation">
            <summary>
            	string name;
                float length
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.AnimationTrack">
            <summary>
            	ushort type			// 1 == morph, 2 == posestring name;
                ushort target		// 0 for shared geometry; 1+ for submesh index + 1
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.AnimationMorphKeyframe">
            <summary>
            	float time
                float x, y, z       // repeat by number of vertices in original geometry
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.AnimationPoseKeyframe">
            <summary>
            	float time
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.AnimationPoseRef">
            <summary>
            	repeat for number of referenced poses:
            	ushort poseIndex
            	float influence
            </summary>
        </member>
        <member name="T:Axiom.Scripting.CommandAttribute">
            <summary>
            	Summary description for CommandAttribute.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.CommandAttribute.name">
            <summary>
               Name of the command the target class will be registered to handle.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.CommandAttribute.description">
            <summary>
               Description of what this command does.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.CommandAttribute.target">
            <summary>
               Target type this class is meant to handle commands for.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.CommandAttribute.#ctor(System.String,System.String,System.Type)">
            <summary>
               Constructor.
            </summary>
            <param name="name"></param>
            <param name="description"></param>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Scripting.CommandAttribute.#ctor(System.String,System.String)">
            <summary>
               Constructor.
            </summary>
            <param name="name"></param>
            <param name="description"></param>
        </member>
        <member name="M:Axiom.Scripting.CommandAttribute.#ctor(System.String)">
            <summary>
               Constructor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:Axiom.Scripting.CommandAttribute.Name">
            <summary>
               Name of this command.
            </summary>
        </member>
        <member name="P:Axiom.Scripting.CommandAttribute.Description">
            <summary>
               Optional description of what this command does.
            </summary>
        </member>
        <member name="P:Axiom.Scripting.CommandAttribute.Target">
            <summary>
               Optional target to specify what object type this command affects.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanelFactory">
            <summary>
            	Summary description for BorderPanelFactory.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.IOverlayElementFactory">
            <summary>
            	Defines the interface which all components wishing to 
            	supply OverlayElement subclasses must implement.
            </summary>
            <remarks>
            	To allow the OverlayElement types available for inclusion on 
            	overlays to be extended, the engine allows external apps or plugins
            	to register their ability to create custom OverlayElements with
            	the GuiManager, using the AddOverlayElementFactory method. Classes
            	wanting to do this must implement this interface.
            	<p/>
            	Each OverlayElementFactory creates a single type of OverlayElement, 
            	identified by a 'type name' which must be unique.
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.IOverlayElementFactory.Create(System.String)">
            <summary>
               Classes that implement this interface will return an instance of a OverlayElement of their designated
               type.
            </summary>
            <param name="name">Name of the element to create.</param>
            <returns>A new instance of a OverlayElement with the specified name.</returns>
        </member>
        <member name="P:Axiom.Overlays.IOverlayElementFactory.Type">
            <summary>
               Classes that implement this interface should return the name of the OverlayElement that it will be
               responsible for creating.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.PanelFactory">
            <summary>
            	Summary description for PanelFactory.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.TextAreaFactory">
            <summary>
            	Summary description for TextAreaFactory.
            </summary>
        </member>
        <member name="T:Axiom.Media.ImageCodec">
            <summary>
            Summary description for ImageCodec.
            </summary>
        </member>
        <member name="T:Axiom.Math.Vector3">
            <summary>
               Standard 3-dimensional vector.
            </summary>
            <remarks>
                A direction in 3D space represented as distances along the 3
                orthoganal axes (x, y, z). Note that positions, directions and
                scaling factors can be represented by a vector, depending on how
                you interpret the values.
            </remarks>
        </member>
        <member name="F:Axiom.Math.Vector3.x">
            <summary>X component.</summary>
        </member>
        <member name="F:Axiom.Math.Vector3.y">
            <summary>Y component.</summary>
        </member>
        <member name="F:Axiom.Math.Vector3.z">
            <summary>Z component.</summary>
        </member>
        <member name="M:Axiom.Math.Vector3.#ctor(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            	Creates a new 3 dimensional Vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector3.#ctor(Axiom.Math.Real)">
            <summary>
            	Creates a new 3 dimensional Vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector3.#ctor(Axiom.Math.Real[])">
            <summary>
            	Creates a new 3 dimensional Vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Equality(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	User to compare two Vector3 instances for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Inequality(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	User to compare two Vector3 instances for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Multiply(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is multiplied by another vector.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Multiply(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is multiplied by another vector.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Divide(Axiom.Math.Vector3,Axiom.Math.Real)">
            <summary>
            Used to divide a vector by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Division(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is divided by another vector.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Divide(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is divided by another vector.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Division(Axiom.Math.Vector3,Axiom.Math.Real)">
            <summary>
            Used to divide a vector by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Add(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is added to another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Addition(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is added to another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Multiply(Axiom.Math.Vector3,Axiom.Math.Real)">
            <summary>
            	Used when a Vector3 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Multiply(Axiom.Math.Vector3,Axiom.Math.Real)">
            <summary>
            	Used when a Vector3 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Multiply(Axiom.Math.Real,Axiom.Math.Vector3)">
            <summary>
            	Used when a scalar value is multiplied by a Vector3.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Multiply(Axiom.Math.Real,Axiom.Math.Vector3)">
            <summary>
            	Used when a scalar value is multiplied by a Vector3.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Subtract(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used to subtract a Vector3 from another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Subtraction(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used to subtract a Vector3 from another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Negate(Axiom.Math.Vector3)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_UnaryNegation(Axiom.Math.Vector3)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_GreaterThan(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
               Returns true if the vector's scalar components are all smaller
               that the ones of the vector it is compared against.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_LessThan(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
               Returns true if the vector's scalar components are all greater
               that the ones of the vector it is compared against.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Explicit(Axiom.Math.Vector3)~Axiom.Math.Vector4">
            <summary>
               
            </summary>
            <param name="vec3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Distance(Axiom.Math.Vector3)">
            <summary>
            Returns the distance to another vector.
            </summary>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.DistanceSquared(Axiom.Math.Vector3)">
            <summary>
                Returns the square of the distance to another vector.
            <remarks>
                This method is for efficiency - calculating the actual
                distance to another vector requires a square root, which is
                expensive in terms of the operations required. This method
                returns the square of the distance to another vector, i.e.
                the same as the distance but before the square root is taken.
                Use this if you want to find the longest / shortest distance
                without incurring the square root.
            </remarks>
            </summary>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Dot(Axiom.Math.Vector3)">
            <summary>
            Performs a Dot Product operation on 2 vectors.
            </summary>
            <remarks>
            A dot product of two vectors v1 and v2 equals to |v1|*|v2|*cos(fi)
            where fi is the angle between the vectors and |v1| and |v2| are the vector lengths.
            For unit vectors (whose length is one) the dot product will obviously be just cos(fi).
            For example, if the unit vectors are parallel the result is cos(0) = 1.0f,
            if they are perpendicular the result is cos(PI/2) = 0.0f.
            The dot product may be calculated on vectors with any length however.
            A zero vector is treated as perpendicular to any vector (result is 0.0f).
            </remarks>
            <param name="vector">The vector to perform the Dot Product against.</param>
            <returns>Products of vector lengths and cosine of the angle between them. </returns>
        </member>
        <member name="M:Axiom.Math.Vector3.AbsDot(Axiom.Math.Vector3)">
            <summary>
                Calculates the absolute dot (scalar) product of this vector with another.
            </summary>
            <remarks>
                This function work similar dotProduct, except it use absolute value
                of each component of the vector to computing.
            </remarks>
            <param name="vec">
                vec Vector with which to calculate the absolute dot product (together
                with this one).
            </param>
            <returns>A float representing the absolute dot product value.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Cross(Axiom.Math.Vector3)">
            <summary>
            	Performs a Cross Product operation on 2 vectors, which returns a vector that is perpendicular
            	to the intersection of the 2 vectors.  Useful for finding face normals.
            </summary>
            <param name="vector">A vector to perform the Cross Product against.</param>
            <returns>A new Vector3 perpedicular to the 2 original vectors.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Perpendicular">
            <summary>
            	Finds a vector perpendicular to this one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.RandomDeviant(Axiom.Math.Real,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="angle"></param>
            <param name="up"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.PositionEquals(Axiom.Math.Vector3)">
            <overloads>
            <summary>Returns wether this vector is within a positional tolerance of another vector</summary>
            <param name="right">The vector to compare with</param>
            </overloads>
            <remarks>Uses a defalut tolerance of 1E-03</remarks>
        </member>
        <member name="M:Axiom.Math.Vector3.PositionEquals(Axiom.Math.Vector3,Axiom.Math.Real)">
            <param name="right">The vector to compare with</param>
             <param name="tolerance">The amount that each element of the vector may vary by and still be considered equal.</param>
        </member>
        <member name="M:Axiom.Math.Vector3.MidPoint(Axiom.Math.Vector3)">
            <summary>
            	Finds the midpoint between the supplied Vector and this vector.
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Ceil(Axiom.Math.Vector3)">
            <summary>
            	Compares the supplied vector and updates it's x/y/z components of they are higher in value.
            </summary>
            <param name="compare"></param>
        </member>
        <member name="M:Axiom.Math.Vector3.Floor(Axiom.Math.Vector3)">
            <summary>
            	Compares the supplied vector and updates it's x/y/z components of they are lower in value.
            </summary>
            <param name="compare"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.GetRotationTo(Axiom.Math.Vector3)">
            <summary>
            	Gets the shortest arc quaternion to rotate this vector to the destination vector. 
            </summary>
            <remarks>
            	Don't call this if you think the dest vector can be close to the inverse
            	of this vector, since then ANY axis of rotation is ok.
            </remarks>
        </member>
        <member name="M:Axiom.Math.Vector3.GetRotationTo(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            Gets the shortest arc quaternion to rotate this vector to the destination vector. 
            </summary>
            <param name="destination"></param>
            <param name="fallbackAxis"></param>
            <returns></returns>
            <remarks>
            	Don't call this if you think the dest vector can be close to the inverse
            	of this vector, since then ANY axis of rotation is ok.
            </remarks>
        </member>
        <member name="M:Axiom.Math.Vector3.Normalize">
            <summary>
            	Normalizes the vector.
            </summary>
            <remarks>
            	This method normalises the vector such that it's
            	length / magnitude is 1. The result is called a unit vector.
            	<p/>
            	This function will not crash for zero-sized vectors, but there
            	will be no changes made to their components.
            </remarks>
            <returns>The previous length of the vector.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Reflect(Axiom.Math.Vector3)">
            <summary>
               Calculates a reflection vector to the plane with the given normal.
            </summary>
            <remarks>
               Assumes this vector is pointing AWAY from the plane, invert if not.
            </remarks>
            <param name="normal">Normal vector on which this vector will be reflected.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Vector3.
            </summary>
            <returns>A string representation of a vector3.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Equals(System.Object)">
            <summary>
            	Compares this Vector to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Parse(System.String)">
            <summary>
            	Parses a string and returns Vector3.
            </summary>
            <param name="vector">
                A string representation of a Vector3 as it's returned from Vector3.ToString()
            </param>
            <returns>
                A new Vector3.
            </returns>
        </member>
        <member name="P:Axiom.Math.Vector3.Item(System.Int32)">
            <summary>
            	Used to access a Vector by index 0 = x, 1 = y, 2 = z.  
            </summary>
            <remarks>
            	Uses unsafe pointer arithmetic to reduce the code required.
            </remarks>
        </member>
        <member name="P:Axiom.Math.Vector3.IsZeroLength">
            <summary>
            Returns true if this vector is zero length.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.Length">
            <summary>
               Gets the length (magnitude) of this Vector3.  The Sqrt operation is expensive, so 
               only use this if you need the exact length of the Vector.  If vector lengths are only going
               to be compared, use LengthSquared instead.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.LengthSquared">
            <summary>
               Returns the length (magnitude) of the vector squared.
            </summary>
            <remarks>
                This  property is for efficiency - calculating the actual
                length of a vector requires a square root, which is expensive
                in terms of the operations required. This method returns the
                square of the length of the vector, i.e. the same as the
                length but before the square root is taken. Use this if you
                want to find the longest / shortest vector without incurring
                the square root.
            </remarks>
        </member>
        <member name="P:Axiom.Math.Vector3.Zero">
            <summary>
            	Gets a Vector3 with all components set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitScale">
            <summary>
            	Gets a Vector3 with all components set to 1.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitX">
            <summary>
            	Gets a Vector3 with the X set to 1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitY">
            <summary>
            	Gets a Vector3 with the Y set to 1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitZ">
            <summary>
            	Gets a Vector3 with the Z set to 1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.NegativeUnitX">
            <summary>
            	Gets a Vector3 with the X set to -1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.NegativeUnitY">
            <summary>
            	Gets a Vector3 with the Y set to -1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.NegativeUnitZ">
            <summary>
            	Gets a Vector3 with the Z set to -1, and the others set to 0.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IHardwareBufferLicensee">
            <summary>
                Interface representing a 'licensee' of a hardware buffer copy.
            </summary>
            <remarks>
                Often it's useful to have temporary buffers which are used for working
                but are not necessarily needed permanently. However, creating and 
                destroying buffers is expensive, so we need a way to share these 
                working areas, especially those based on existing fixed buffers. 
                Classes implementing this interface represent a licensee of one of those 
                temporary buffers, and must be implemented by any user of a temporary buffer 
                if they wish to be notified when the license is expired. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IHardwareBufferLicensee.LicenseExpired(Axiom.Graphics.HardwareBuffer)">
            <summary>
                This method is called when the buffer license is expired and is about
                to be returned to the shared pool.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="T:Axiom.Graphics.HighLevelGpuProgramManager">
            <summary>
            	This ResourceManager manages high-level vertex and fragment programs.
            </summary>
            <remarks>
               High-level vertex and fragment programs can be used instead of assembler programs
               as managed by <see cref="T:Axiom.Graphics.GpuProgramManager"/>; however they typically result in a
               <see cref="T:Axiom.Graphics.GpuProgram"/> being created as a derivative of the high-level program.
               High-level programs are easier to write, and can often be API-independent,
               unlike assembler programs.
               <p/>
               This class not only manages the programs themselves, it also manages the factory
               classes which allow the creation of high-level programs using a variety of high-level
               syntaxes. Plugins can be created which register themselves as high-level program
               factories and as such the engine can be extended to accept virtually any kind of
               program provided a plugin is written.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgramManager._instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgramManager.factories">
            <summary>
               Lookup table for list of registered factories.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.AddFactory(Axiom.Graphics.HighLevelGpuProgramFactory)">
            <summary>
               Add a new factory object for high-level programs of a given language.
            </summary>
            <param name="factory">
               The factory instance to register.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.RemoveFactory(Axiom.Graphics.HighLevelGpuProgramFactory)">
            <summary>
                Unregisters a factory
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.CreateProgram(System.String,System.String,System.String,Axiom.Graphics.GpuProgramType)">
            <summary>
               Creates a new, unloaded HighLevelGpuProgram instance.
            </summary>
            <remarks>
               This method creates a new program of the type specified as the second and third parameters.
               You will have to call further methods on the returned program in order to
               define the program fully before you can load it.
            </remarks>
            <param name="name">Name of the program to create.</param>
            <param name="group"></param>
            <param name="language">HLSL language to use.</param>
            <param name="type">Type of program, i.e. vertex or fragment.</param>
            <returns>An unloaded instance of HighLevelGpuProgram.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.GetFactory(System.String)">
            <summary>
               Retreives a factory instance capable of producing HighLevelGpuPrograms of the
               specified language.
            </summary>
            <param name="language">HLSL language.</param>
            <returns>A factory capable of creating a HighLevelGpuProgram of the specified language.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.dispose(System.Boolean)">
            <summary>
                Called when the engine is shutting down.
            </summary>
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgramManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgramManager.Item(System.String)">
            <summary>
                Gets a HighLevelGpuProgram with the specified name.
            </summary>
            <param name="name">Name of the program to retrieve.</param>
            <returns>The high level gpu program with the specified name.</returns>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgramManager.Item(System.UInt64)">
            <summary>
                Gets a HighLevelGpuProgram with the specified handle.
            </summary>
            <param name="handle">Handle of the program to retrieve.</param>
            <returns>The high level gpu program with the specified handle.</returns>
        </member>
        <member name="T:Axiom.Core.LoadingState">
            <summary>
            Enum identifying the loading state of the resource
            </summary>
        </member>
        <member name="F:Axiom.Core.LoadingState.Unloaded">
            Not loaded
        </member>
        <member name="F:Axiom.Core.LoadingState.Loading">
            Loading is in progress
        </member>
        <member name="F:Axiom.Core.LoadingState.Loaded">
            Fully loaded
        </member>
        <member name="F:Axiom.Core.LoadingState.Unloading">
            Currently unloading
        </member>
        <member name="T:Axiom.Core.Memory">
            <summary>
            	Utility class for dealing with memory.
            </summary>
        </member>
        <member name="M:Axiom.Core.Memory.#ctor">
            <summary>
                Don't want instances of this created.
            </summary>
        </member>
        <member name="M:Axiom.Core.Memory.Copy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            	Method for copying data from one IntPtr to another.
            </summary>
            <param name="src">Source pointer.</param>
            <param name="dest">Destination pointer.</param>
            <param name="length">Length of data (in bytes) to copy.</param>
        </member>
        <member name="M:Axiom.Core.Memory.Copy(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            	Method for copying data from one IntPtr to another.
            </summary>
            <param name="src">Source pointer.</param>
            <param name="dest">Destination pointer.</param>
            <param name="srcOffset">Offset at which to copy from the source pointer.</param>
            <param name="destOffset">Offset at which to begin copying to the destination pointer.</param>
            <param name="length">Length of data (in bytes) to copy.</param>
        </member>
        <member name="M:Axiom.Core.Memory.Set(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Sets the memory to 0 starting at the specified offset for the specified byte length.
            </summary>
            <param name="dest">Destination pointer.</param>
            <param name="offset">Byte offset to start.</param>
            <param name="length">Number of bytes to set.</param>
        </member>
        <member name="T:Axiom.Controllers.Canned.WaveformControllerFunction">
            <summary>
            A Controller representing a periodic waveform function ranging from Sine to InverseSawtooth
            </summary>
            <remarks>Function take to form of BaseValue + Amplitude * ( F(time * freq) / 2 + .5 )
            such as Base + A * ( Sin(t freq 2 pi) + .5) </remarks>
        </member>
        <member name="T:Axiom.Controllers.BaseControllerFunction">
            <summary>
            	Subclasses of this class are responsible for performing a function on an input value for a Controller.
             </summary>
             <remarks>
            	This abstract class provides the interface that needs to be supported for a custom function which
            	can be 'plugged in' to a Controller instance, which controls some object value based on an input value.
            	For example, the WaveControllerFunction class provided by Ogre allows you to use various waveforms to
            	translate an input value to an output value.
            	<p/>
            	This base class implements IControllerFunction, but leaves the implementation up to the subclasses.
            </remarks>
        </member>
        <member name="T:Axiom.Controllers.IControllerFunction`1">
            <summary>
            	Interface describing the required methods of a Controller Function.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.IControllerFunction`1.Execute(`0)">
            <summary>
            	Called by a controller every frame to have this function run and return on the supplied
            	source value and return the result.
            </summary>
            <param name="sourceValue"></param>
        </member>
        <member name="F:Axiom.Controllers.BaseControllerFunction.useDeltaInput">
            <summary>
            	If true, function will add input values together and wrap at 1.0 before evaluating.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.BaseControllerFunction.deltaCount">
            <summary>
            	Value to be added during evaluation.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.BaseControllerFunction.AdjustInput(System.Single)">
            <summary>
            	Adjusts the input value by a delta.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Configuration.Config">
            <summary>
            Summary description for Config.
            </summary>
        </member>
        <member name="T:Axiom.Collections.HashList`2">
            <summary>
            Represents a collection of key/value pairs that are sorted by the keys and are accessible by key and by index.
            </summary>
        </member>
        <member name="M:Axiom.Collections.HashList`2.GetByKey(`0)">
            <summary>
            Gets a <see name="TValue"/> by key.
            </summary>
            <param name="key">The key.</param>
            <returns>The <see name="TValue"/> that corresponds to the specified key.</returns>
        </member>
        <member name="M:Axiom.Collections.HashList`2.GetKeyAt(System.Int32)">
            <summary>
            Gets the key at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>The key at the specified index.</returns>
        </member>
        <member name="P:Axiom.Collections.HashList`2.Item(System.Int32)">
            <summary>
            Gets the <see name="TValue"/> at the specified index.
            </summary>
            <value>A <see name="TValue"/>.</value>
        </member>
        <member name="T:Axiom.Animating.Skeleton">
            <summary>
            	A collection of Bone objects used to animate a skinned mesh.
             </summary>
             <remarks>
            	Skeletal animation works by having a collection of 'bones' which are
            	actually just joints with a position and orientation, arranged in a tree structure.
            	For example, the wrist joint is a child of the elbow joint, which in turn is a
            	child of the shoulder joint. Rotating the shoulder automatically moves the elbow
            	and wrist as well due to this hierarchy.
            	<p/>
            	So how does this animate a mesh? Well every vertex in a mesh is assigned to one or more
            	bones which affects it's position when the bone is moved. If a vertex is assigned to
            	more than one bone, then weights must be assigned to determine how much each bone affects
            	the vertex (actually a weight of 1.0 is used for single bone assignments).
            	Weighted vertex assignments are especially useful around the joints themselves
            	to avoid 'pinching' of the mesh in this region.
            	<p/>
            	Therefore by moving the skeleton using preset animations, we can animate the mesh. The
            	advantage of using skeletal animation is that you store less animation data, especially
            	as vertex counts increase. In addition, you are able to blend multiple animations together
            	(e.g. walking and looking around, running and shooting) and provide smooth transitions
            	between animations without incurring as much of an overhead as would be involved if you
            	did this on the core vertex data.
            	<p/>
            	Skeleton definitions are loaded from datafiles, namely the .xsf file format. They
            	are loaded on demand, especially when referenced by a Mesh.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Skeleton.MAX_BONE_COUNT">
            <summary>Maximum total available bone matrices that are available during blending.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton._blendMode">
            <summary>Mode of animation blending to use.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.namedBoneList">
            <summary>Internal list of bones attached to this skeleton, indexed by name.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.boneList">
            <summary>Internal list of bones attached to this skeleton, indexed by handle.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.rootBones">
            <summary>Reference to the root bone of this skeleton.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton._currentEntity">
            <summary>The entity that is currently updating this skeleton.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton._nextAutoHandle">
            <summary>Used for auto generated handles to ensure they are unique.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.animationList">
            <summary>Lookup table for animations related to this skeleton.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.attachmentPoints">
            <summary>Internal list of bones attached to this skeleton, indexed by handle.</summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String)">
            <summary>
            Constructor, don't call directly, use SkeletonManager.
            </summary>
            <remarks>
            On creation, a Skeleton has a no bones, you should create them and link
            them together appropriately.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Axiom.Core.IManualResourceLoader)">
            <summary>
            Constructor, don't call directly, use SkeletonManager.
            </summary>
            <remarks>
            On creation, a Skeleton has a no bones, you should create them and link
            them together appropriately.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateAnimation(System.String,System.Single)">
            <summary>
               Creates a new Animation object for animating this skeleton.
            </summary>
            <param name="name">The name of this animation</param>
            <param name="length">The length of the animation in seconds</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone">
            <summary>
               Creates a brand new Bone owned by this Skeleton.
            </summary>
            <remarks>
               This method creates an unattached new Bone for this skeleton. Unless this is to
               be the root bone (there must only be one of these), you must
               attach it to another Bone in the skeleton using addChild for it to be any use.
               For this reason you will likely be better off creating child bones using the
               Bone.CreateChild method instead, once you have created the root bone.
               <p/>
               Note that this method automatically generates a handle for the bone, which you
               can retrieve using Bone.Handle. If you wish the new Bone to have a specific
               handle, use the alternate form of this method which takes a handle as a parameter,
               although you should note the restrictions.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.String)">
            <summary>
               Creates a brand new Bone owned by this Skeleton.
            </summary>
            <remarks>
               This method creates an unattached new Bone for this skeleton. Unless this is to
               be the root bone (there must only be one of these), you must
               attach it to another Bone in the skeleton using addChild for it to be any use.
               For this reason you will likely be better off creating child bones using the
               Bone.CreateChild method instead, once you have created the root bone.
            </remarks>
            <param name="name">
               The name to give to this new bone - must be unique within this skeleton.
               Note that the way the engine looks up bones is via a numeric handle, so if you name a
               Bone this way it will be given an automatic sequential handle. The name is just
               for your convenience, although it is recommended that you only use the handle to
               retrieve the bone in performance-critical code.
            </param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.UInt16)">
            <summary>
               Creates a brand new Bone owned by this Skeleton.
            </summary>
            <param name="handle">
               The handle to give to this new bone - must be unique within this skeleton.
               You should also ensure that all bone handles are eventually contiguous (this is to simplify
               their compilation into an indexed array of transformation matrices). For this reason
               it is advised that you use the simpler createBone method which automatically assigns a
               sequential handle starting from 0.
            </param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.String,System.UInt16)">
            <summary>
               Creates a brand new Bone owned by this Skeleton.
            </summary>
            <param name="name">
               The name to give to this new bone - must be unique within this skeleton.
               Note that the way the engine looks up bones is via a numeric handle, so if you name a
               Bone this way it will be given an automatic sequential handle. The name is just
               for your convenience, although it is recommended that you only use the handle to
               retrieve the bone in performance-critical code.
            </param>
            <param name="handle">
               The handle to give to this new bone - must be unique within this skeleton.
               You should also ensure that all bone handles are eventually contiguous (this is to simplify
               their compilation into an indexed array of transformation matrices). For this reason
               it is advised that you use the simpler createBone method which automatically assigns a
               sequential handle starting from 0.
            </param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.DeriveRootBone">
            <summary>
               Internal method which parses the bones to derive the root bone.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetAnimation(System.String)">
            <summary>
               Returns the animation with the specified name.
            </summary>
            <param name="name">Name of the animation to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetBone(System.UInt16)">
            <summary>
               Gets a bone by its handle.
            </summary>
            <param name="handle">Handle of the bone to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetBone(System.String)">
            <summary>
               Gets a bone by its name.
            </summary>
            <param name="name">Name of the bone to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.ContainsBone(System.String)">
            <summary>
               Checks to see if a bone exists
            </summary>
            <param name="name">Name of the bone to check.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetRootBone(System.Int32)">
            <summary>
            	Gets the root bone at the specified index.
            </summary>
            <param name="index">Index of the root bone to return.</param>
            <returns>Root bone at the specified index, or null if the index is out of bounds.</returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetBoneMatrices(Axiom.Math.Matrix4[])">
            <summary>
               Populates the passed in array with the bone matrices based on the current position.
            </summary>
            <remarks>
               Internal use only. The array passed in must
               be at least as large as the number of bones.
               Assumes animation has already been updated.
            </remarks>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.InitAnimationState(Axiom.Animating.AnimationStateSet)">
            <summary>
               Initialize an animation set suitable for use with this mesh.
            </summary>
            <remarks>
               Only recommended for use inside the engine, not by applications.
            </remarks>
            <param name="animSet"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.RemoveAnimation(System.String)">
            <summary>
               Removes the animation with the specified name from this skeleton.
            </summary>
            <param name="name">Name of the animation to remove.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.Reset">
            <summary>
               Resets the position and orientation of all bones in this skeleton to their original binding position.
            </summary>
            <remarks>
               A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this
               position during animation. This method returns all the bones to their original position and
               orientation.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.Reset(System.Boolean)">
            <summary>
               Resets the position and orientation of all bones in this skeleton to their original binding position.
            </summary>
            <remarks>
               A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this
               position during animation. This method returns all the bones to their original position and
               orientation.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.SetAnimationState(Axiom.Animating.AnimationStateSet)">
             <summary>
            
             </summary>
             <param name="animSet"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.SetBindingPose">
            <summary>
               Sets the current position / orientation to be the 'binding pose' ie the layout in which
               bones were originally bound to a mesh.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.UpdateTransforms">
            <summary>
            	Updates all the derived transforms in the skeleton.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateAttachmentPoint(System.String,System.UInt16,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
              TODO: should this replace an existing attachment point with the same name?
            </summary>
            <param name="name"></param>
            <param name="parentHandle"></param>
            <param name="rotation"></param>
            <param name="translation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.DumpContents(System.String)">
             <summary>
            
             </summary>
             <param name="fileName"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.load">
            <summary>
               Generic load, called by SkeletonManager.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.unload">
            <summary>
               Generic unload, called by SkeletonManager.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.BlendMode">
            <summary>
               Gets/Sets the animation blending mode which this skeleton will use.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.Bones">
            <summary>
            Gets the bones.
            </summary>
            <value>The bones.</value>
        </member>
        <member name="P:Axiom.Animating.Skeleton.BoneCount">
            <summary>
               Gets the number of bones in this skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.RootBone">
            <summary>
               Gets the root bone of the skeleton.
            </summary>
            <remarks>
               The system derives the root bone the first time you ask for it. The root bone is the
               only bone in the skeleton which has no parent. The system locates it by taking the
               first bone in the list and going up the bone tree until there are no more parents,
               and saves this top bone as the root. If you are building the skeleton manually using
               CreateBone then you must ensure there is only one bone which is not a child of
               another bone, otherwise your skeleton will not work properly. If you use CreateBone
               only once, and then use Bone.CreateChild from then on, then inherently the first
               bone you create will by default be the root.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.Skeleton.RootBoneCount">
            <summary>
            	Gets the number of root bones in this skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.CurrentEntity">
            <summary>
               Get/Set the entity that is currently updating this skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.Animations">
            <summary>
                Gets the animations associated with this skeleton
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.Collections.EmitterList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.Collections.AffectorList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.Collections.ParticleList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorManager">
            <summary>
                Class for managing Compositor settings for Ogre. Compositors provide the means
                to flexibly "composite" the final rendering result from multiple scene renders
                and intermediate operations like rendering fullscreen quads. This makes
                it possible to apply postfilter effects, HDRI postprocessing, and shadow
                effects to a Viewport.
            
                When loaded from a script, a Compositor is in an 'unloaded' state and only stores the settings
                required. It does not at that stage load any textures. This is because the material settings may be
                loaded 'en masse' from bulk material script files, but only a subset will actually be required.
            
                Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or
                archive added to the resource paths/archives. See ResourceManager for details.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.Initialize(System.Object[])">
            <summary>
            Initializes the Compositor Manager
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.chains">
            <summary>
                Mapping from viewport to compositor chain
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.texturesByDef">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.chainTexturesByRef">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.rectangle">
            <summary>
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.compositorLogics">
            <summary>
            List of registered compositor logics
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.customCompositionPasses">
            <summary>
            List of registered custom composition passes
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.GetCompositorChain(Axiom.Core.Viewport)">
            <summary>
                Get the compositor chain for a Viewport. If there is none yet, a new
                compositor chain is registered.
                XXX We need a _notifyViewportRemoved to find out when this viewport disappears,
                so we can destroy its chain as well.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.HasCompositorChain(Axiom.Core.Viewport)">
            <summary>
                Returns whether exists compositor chain for a viewport.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.RemoveCompositorChain(Axiom.Core.Viewport)">
            <summary>
                Remove the compositor chain from a viewport if exists.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.RemoveAll">
            <summary>
                Overridden from ResourceManager since we have to clean up chains too.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.FreeChains">
            <summary>
                Clear composition chains for all viewports
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.AddCompositor(Axiom.Core.Viewport,System.String,System.Int32)">
            <summary>
                Add a compositor to a viewport. By default, it is added to end of the chain,
                after the other compositors.
            </summary>
            <param name="vp">Viewport to modify</param>
            <param name="compositor">The name of the compositor to apply</param>
            <param name="addPosition">At which position to add, defaults to the end (-1).</param>
            <returns>pointer to instance, or null if it failed.</returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.RemoveCompositor(Axiom.Core.Viewport,System.String)">
            <summary>
                Remove a compositor from a viewport
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.RemoveCompositor(Axiom.Graphics.CompositorInstance)">
            <summary>
            another overload to remove a compositor instance from its chain
            </summary>
            <param name="remInstance"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.SetCompositorEnabled(Axiom.Core.Viewport,System.String,System.Boolean)">
            <summary>
                Set the state of a compositor on a viewport to enabled or disabled.
                Disabling a compositor stops it from rendering but does not free any resources.
                This can be more efficient than using removeCompositor and addCompositor in cases
                the filter is switched on and off a lot.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.GetPooledTexture(System.String,System.String,System.Int32,System.Int32,Axiom.Media.PixelFormat,System.Int32,System.String,System.Boolean,System.Collections.Generic.List{Axiom.Core.Texture},Axiom.Graphics.CompositorInstance,Axiom.Graphics.CompositionTechnique.TextureScope)">
             <summary>
            
             </summary>
             <param name="name"></param>
             <param name="localName"></param>
             <param name="width"></param>
             <param name="height"></param>
             <param name="format"></param>
             <param name="aa"></param>
             <param name="aaHint"></param>
             <param name="srgb"></param>
             <param name="textureAllreadyAssigned"></param>
             <param name="instance"></param>
             <param name="scope"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.FreePooledTextures">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.FreePooledTextures(System.Boolean)">
             <summary>
            
             </summary>
             <param name="onlyIfUnreferenced"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.IsInputPreviousTarget(Axiom.Graphics.CompositorInstance,System.String)">
             <summary>
            
             </summary>
             <param name="instance"></param>
             <param name="localName"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.IsInputPreviousTarget(Axiom.Graphics.CompositorInstance,Axiom.Core.Texture)">
             <summary>
            
             </summary>
             <param name="instance"></param>
             <param name="texture"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.IsInputToOutputTarget(Axiom.Graphics.CompositorInstance,System.String)">
             <summary>
            
             </summary>
             <param name="instance"></param>
             <param name="localName"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.IsInputToOutputTarget(Axiom.Graphics.CompositorInstance,Axiom.Core.Texture)">
             <summary>
            
             </summary>
             <param name="instance"></param>
             <param name="texture"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.ParseScript(System.IO.Stream,System.String,System.String)">
            <summary>
            	Starts parsing an individual script file.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositorManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositorManager.CompositorLogics">
            <summary>
            List of registered compositor logics
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositorManager.CustomCompositionPasses">
            <summary>
            List of registered custom composition passes
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositorManager.TexturedRectangle2D">
            <summary>
                Get a textured fullscreen 2D rectangle, for internal use.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorManager.TextureDefinition">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.TextureDefinition.Width">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.TextureDefinition.Height">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.TextureDefinition.Format">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.TextureDefinition.FSAA">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.TextureDefinition.FSAAHint">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorManager.TextureDefinition.SRGBWrite">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorManager.TextureDefinition.#ctor(System.Int32,System.Int32,Axiom.Media.PixelFormat,System.Int32,System.String,System.Boolean)">
             <summary>
            
             </summary>
             <param name="width"></param>
             <param name="height"></param>
             <param name="format"></param>
             <param name="aa"></param>
             <param name="aaHint"></param>
             <param name="srgb"></param>
        </member>
        <member name="T:Axiom.Graphics.CompositorManager.TextureDefLess">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorChain">
            <summary>
                Chain of compositor effects applying to one viewport.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.viewport">
            <summary>
                Viewport affected by this CompositorChain
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.originalScene">
            <summary>
                Plainly renders the scene; implicit first compositor in the chain.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.instances">
            <summary>
                Postfilter instances in this chain
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.dirty">
            <summary>
                State needs recompile
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.anyCompositorsEnabled">
            <summary>
                Any compositors enabled?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.compiledState">
            <summary>
                Compiled state (updated with _compile)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.renderSystemOperations">
            <summary>
               Render System operations queued by last compile, these are created by this
               instance thus managed and deleted by it. The list is cleared with
               ClearCompilationState()
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.oldClearEveryFrameBuffers">
            <summary>
                Old viewport settings
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.oldVisibilityMask">
            <summary>
                Store old scene visibility mask
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.oldFindVisibleObjects">
            <summary>
                Store old find visible objects
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.oldLodBias">
            <summary>
                Store old camera LOD bias
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.oldMaterialScheme">
            <summary>
                Store old viewport material scheme
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.listener">
            <summary>
              The class that will handle the callbacks from the RenderQueue
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.lastCompositor">
            <summary>
                Identifier for "last" compositor in chain
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.bestCompositor">
            <summary>
                Identifier for best technique
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.DestroyResources">
            <summary>
                destroy internal resources
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.AddCompositor(Axiom.Graphics.Compositor)">
            <summary>
                Apply a compositor. Initially, the filter is enabled.
            </summary>
            <param name="filter">Filter to apply</param>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.AddCompositor(Axiom.Graphics.Compositor,System.Int32)">
            <summary>
                Apply a compositor. Initially, the filter is enabled.
            </summary>
            <param name="filter">Filter to apply</param>
            <param name="addPosition">Position in filter chain to insert this filter at; defaults to the end (last applied filter)</param>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.AddCompositor(Axiom.Graphics.Compositor,System.Int32,System.Int32)">
            <summary>
                Apply a compositor. Initially, the filter is enabled.
            </summary>
            <param name="filter">Filter to apply</param>
            <param name="addPosition">Position in filter chain to insert this filter at; defaults to the end (last applied filter)</param>
            <param name="technique">Technique to use; CompositorChain::BEST (default) chooses to the best one
                                    available (first technique supported)
            </param>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.AddCompositor(Axiom.Graphics.Compositor,System.Int32,System.Int32,System.String)">
            <summary>
                Apply a compositor. Initially, the filter is enabled.
            </summary>
            <param name="filter">Filter to apply</param>
            <param name="addPosition">Position in filter chain to insert this filter at; defaults to the end (last applied filter)</param>
            <param name="technique">Technique to use; CompositorChain::BEST (default) chooses to the best one
                                    available (first technique supported)
            </param>
            <param name="scheme"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RemoveCompositor">
            <summary>
             Removes the last compositor in the chain.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RemoveCompositor(System.Int32)">
            <summary>
             Remove a compositor.
            </summary>
            <param name="position">Position in filter chain of filter to remove</param>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RemoveAllCompositors">
            <summary>
                Remove all compositors.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RemoveInstance(Axiom.Graphics.CompositorInstance)">
            <summary>
                Remove a compositor by pointer. This is internally used by CompositionTechnique to
                "weak" remove any instanced of a deleted technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.GetCompositor(System.Int32)">
            <summary>
                Get compositor instance by position.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.GetPreviousInstance(Axiom.Graphics.CompositorInstance)">
            <summary>
            Get the previous instance in this chain to the one specified.
            </summary>
            <param name="curr"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.GetPreviousInstance(Axiom.Graphics.CompositorInstance,System.Boolean)">
            <summary>
            Get the previous instance in this chain to the one specified.
            </summary>
            <param name="curr"></param>
            <param name="activeOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.GetNextInstance(Axiom.Graphics.CompositorInstance)">
            <summary>
            Get the next instance in this chain to the one specified.
            </summary>
            <param name="curr"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.GetNextInstance(Axiom.Graphics.CompositorInstance,System.Boolean)">
            <summary>
            Get the next instance in this chain to the one specified.
            </summary>
            <param name="curr"></param>
            <param name="activeOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.SetCompositorEnabled(System.Int32,System.Boolean)">
            <summary>
               Enable or disable a compositor, by position. Disabling a compositor stops it from rendering
               but does not free any resources. This can be more efficient than using removeCompositor and
               addCompositor in cases the filter is switched on and off a lot.
            </summary>
            <param name="position">Position in filter chain of filter</param>
            <param name="state"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.BeforeRenderTargetUpdate(Axiom.Graphics.RenderTargetEventArgs)">
            <summary>
                @see RenderTargetListener.PreRenderTargetUpdate
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.AfterRenderTargetUpdate(Axiom.Graphics.RenderTargetEventArgs)">
            <summary>
                @see RenderTargetListener.PreRenderTargetUpdate
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.BeforeViewportUpdate(Axiom.Graphics.RenderTargetViewportEventArgs)">
            <summary>
                @see RenderTargetListener.PreViewportUpdate
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.PreTargetOperation(Axiom.Graphics.CompositeTargetOperation,Axiom.Core.Viewport,Axiom.Core.Camera)">
            <summary>
                Prepare a viewport, the camera and the scene for a rendering operation
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.PostTargetOperation(Axiom.Graphics.CompositeTargetOperation,Axiom.Core.Viewport,Axiom.Core.Camera)">
            <summary>
                Restore a viewport, the camera and the scene after a rendering operation
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.AfterViewportUpdate(Axiom.Graphics.RenderTargetViewportEventArgs)">
            <summary>
                @see RenderTargetListener.PostViewportUpdate
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.OnViewportRemoved(Axiom.Graphics.RenderTargetViewportEventArgs)">
            <summary>
                @see RenderTargetListener.ViewportRemoved
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.Compile">
            <summary>
                Compile this Composition chain into a series of RenderTarget operations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.RQListener.operation">
            <summary>
             Fields that are treated as temps by queue started/ended events
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.RQListener.sceneManager">
            <summary>
                The scene manager instance
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.RQListener.renderSystem">
            <summary>
                The render system
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.RQListener.viewport">
            <summary>
                The view port
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.RQListener.currentOp">
            <summary>
                The number of the first render system op to be processed by the event
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorChain.RQListener.lastOp">
            <summary>
                The number of the last render system op to be processed by the event
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RQListener.SetOperation(Axiom.Graphics.CompositeTargetOperation,Axiom.Core.SceneManager,Axiom.Graphics.RenderSystem)">
            <summary>
                Set current operation and target */
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RQListener.OnRenderQueueStarted(System.Object,Axiom.Core.SceneManager.BeginRenderQueueEventArgs)">
            <summary>
             <see>RenderQueueListener.RenderQueueStarted</see>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RQListener.OnRenderQueueEnded(System.Object,Axiom.Core.SceneManager.EndRenderQueueEventArgs)">
            <summary>
             <see>RenderQueueListener.RenderQueueEnded</see>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositorChain.RQListener.FlushUpTo(Axiom.Core.RenderQueueGroupID)">
            <summary>
                Flush remaining render system operations
            </summary>
        </member>
        <member name="T:Axiom.Core.LodStrategy">
            <summary>
            Strategy for determining level of detail.
            </summary>
            <remarks>
            Generally, to create a new lod strategy, all of the following will
            need to be implemented: Value, BaseValue, TransformBias,
            Index, Sort, and IsSorted.
            In addition, TransformUserValue may be overridden.</remarks>
        </member>
        <member name="F:Axiom.Core.LodStrategy._name">
            <summary>
            Name of this strategy.
            </summary>
        </member>
        <member name="M:Axiom.Core.LodStrategy.#ctor(System.String)">
            <summary>
            Constructor accepting name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.LodStrategy.TransformUserValue(Axiom.Math.Real)">
            <summary>
            Transform user supplied value to internal value.
            </summary>
            By default, performs no transformation.
            Do not throw exceptions for invalid values here, as the lod strategy
            may be changed such that the values become valid.
            <param name="userValue"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.GetValue(Axiom.Core.MovableObject,Axiom.Core.Camera)">
            <summary>
            Compute the lod value for a given movable object relative to a given camera.
            </summary>
            <param name="movableObject"></param>
            <param name="cam"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.IsSortedAscending(Axiom.Core.Collections.LodValueList)">
            <summary>
            Implementation of isSorted suitable for ascending values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.IsSortedDescending(Axiom.Core.Collections.LodValueList)">
            <summary>
            Implementation of isSorted suitable for descending values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.SortAscending(Axiom.Core.Collections.MeshLodUsageList)">
             <summary>
            
             </summary>
             <param name="meshLodUsageList"></param>
        </member>
        <member name="M:Axiom.Core.LodStrategy.SortDescending(Axiom.Core.Collections.MeshLodUsageList)">
             <summary>
            
             </summary>
             <param name="meshLodUsageList"></param>
        </member>
        <member name="M:Axiom.Core.LodStrategy.GetIndexAscending(System.Single,Axiom.Core.Collections.MeshLodUsageList)">
             <summary>
            
             </summary>
             <param name="value"></param>
             <param name="meshLodUsageList"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.GetIndexDescending(System.Single,Axiom.Core.Collections.MeshLodUsageList)">
             <summary>
            
             </summary>
             <param name="value"></param>
             <param name="meshLodUsageList"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.GetIndexAscending(System.Single,Axiom.Core.Collections.LodValueList)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.LodStrategy.GetIndexDescending(System.Single,Axiom.Core.Collections.LodValueList)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.LodStrategy.TransformBias(Axiom.Math.Real)">
            <summary>
            Transform lod bias so it only needs to be multiplied by the lod value.
            </summary>
            <param name="factor"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategy.getValue(Axiom.Core.MovableObject,Axiom.Core.Camera)">
            <summary>
            Compute the lod value for a given movable object relative to a given camera.
            </summary>
            <param name="movableObject"></param>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.LodStrategy.BaseValue">
            <summary>
            Get the value of the first (highest) level of detail.
            </summary>
        </member>
        <member name="T:Axiom.Core.LodUsageSortGreater">
            <summary>
            Small helper class to sort a MeshLodUsageList
            </summary>
        </member>
        <member name="T:Axiom.Core.LodUsageSortLess">
            <summary>
            Small helper class to sort a MeshLodUsageList
            </summary>
        </member>
        <member name="T:Axiom.Collections.UnsortedCollection`1">
            <summary>
            Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists.
            </summary>
        </member>
        <member name="M:Axiom.Collections.UnsortedCollection`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.List`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Axiom.Collections.UnsortedCollection`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.List`1"/> class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than 0. 
            </exception>
        </member>
        <member name="M:Axiom.Collections.UnsortedCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.List`1"/> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.
            </exception>
        </member>
        <member name="F:Axiom.Scripting.Compiler.Parser.ScriptToken.lexeme">
            This is the lexeme for this token
        </member>
        <member name="F:Axiom.Scripting.Compiler.Parser.ScriptToken.file">
            This is the lexeme for this token
        </member>
        <member name="F:Axiom.Scripting.Compiler.Parser.ScriptToken.type">
            This is the id associated with the lexeme, which comes from a lexeme-token id mapping
        </member>
        <member name="F:Axiom.Scripting.Compiler.Parser.ScriptToken.line">
            This holds the line number of the input stream where the token was found.
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleSystemRendererAttributeParser">
            <summary>
                Particle system renderer attribute method definition.
            </summary>
            <param name="values">Attribute values.</param>
            <param name="renderer">Target particle system renderer.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.#ctor">
            Constructor
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.UpdateRenderQueue(Axiom.Graphics.RenderQueue,System.Collections.Generic.List{Axiom.ParticleSystems.Particle},System.Boolean)">
            <summary>
             Delegated to by ParticleSystem::UpdateRenderQueue
            </summary>
            <remarks>
            The subclass must update the render queue using whichever Renderable instance(s) it wishes.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            Delegated to by ParticleSystem.NotifyCurrentCamera
            </summary>
            <param name="cam"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyAttached(Axiom.Core.Node)">
            <summary>
            Delegated to by ParticleSystem.NotifyAttached
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleRotated">
            <summary>
            Optional callback notified when particles are rotated
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleEmitted(Axiom.ParticleSystems.Particle)">
            <summary>
            Optional callback notified when particles are emitted
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleResized">
            <summary>
            Optional callback notified when particles are resized individually
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleQuota(System.Int32)">
            <summary>
            Tells the renderer that the particle quota has changed 
            </summary>
            <param name="quota"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleMoved(System.Collections.Generic.List{Axiom.ParticleSystems.Particle})">
            <summary>
            Optional callback notified when particles are moved
            </summary>
            <param name="activeParticles"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleExpired(Axiom.ParticleSystems.Particle)">
            <summary>
            Optional callback notified when particles are moved
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyDefaultDimensions(System.Single,System.Single)">
            <summary>
            Tells the renderer that the particle default size has changed
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.CreateVisualData">
            <summary>
            Create a new ParticleVisualData instance for attachment to a particle.
            </summary>
            <remarks>
            If this renderer needs additional data in each particle, then this should
            be held in an instance of a subclass of ParticleVisualData, and this method
            should be overridden to return a new instance of it. The default
            behaviour is to return null.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.DestroyVisualData(Axiom.ParticleSystems.ParticleVisualData)">
            <summary>
             Destroy a ParticleVisualData instance.
            </summary>
            <remarks>
            If this renderer needs additional data in each particle, then this should
            be held in an instance of a subclass of ParticleVisualData, and this method
            should be overridden to destroy an instance of it. The default
            behaviour is to do nothing.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.SetKeepParticlesInLocalSpace(System.Boolean)">
            Setting carried over from ParticleSystem.
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemRenderer.Type">
            <summary>
            Gets the type of this renderer - must be implemented by subclasses
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemRenderer.Material">
            <summary>
            Sets the material this renderer must use; called by ParticleSystem.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemRenderer.RenderQueueGroup">
            <summary>
            Sets which render queue group this renderer should target with it's output.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Pair">
            <summary>
            	A simple container class for returning a pair of objects from a method call 
            	(similar to std::pair, minus the templates).
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:Axiom.Math.Vector2">
            <summary>
                2 dimensional vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector2.#ctor(Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
                Constructor.
            </summary>
            <param name="x">X position.</param>
            <param name="y">Y position</param>
        </member>
        <member name="M:Axiom.Math.Vector2.Normalize">
            <summary>
            	Normalizes the vector.
            </summary>
            <remarks>
            	This method normalises the vector such that it's
            	length / magnitude is 1. The result is called a unit vector.
            	<p/>
            	This function will not crash for zero-sized vectors, but there
            	will be no changes made to their components.
            </remarks>
            <returns>The previous length of the vector.</returns>
        </member>
        <member name="M:Axiom.Math.Vector2.ToNormalized">
            <summary>
            Gets a normalized (unit length) vector of this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Cross(Axiom.Math.Vector2)">
            <summary>
            Calculates the 2 dimensional cross-product of 2 vectors, which results
            in a Real value which is 2 times the area of the triangle
            defined by the two vectors. It also is the magnitude of the 3D vector that is perpendicular
            to the 2D vectors if the 2D vectors are projected to 3D space.
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Dot(Axiom.Math.Vector2)">
            <summary>
            Calculates the 2 dimensional dot-product of 2 vectors, 
            which is equal to the cosine of the angle between the vectors, times the lengths of each of the vectors.
            A.Dot(B) == |A| * |B| * cos(fi)
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Add(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used when a Vector2 is added to another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Addition(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used when a Vector2 is added to another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Subtract(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used to subtract a Vector2 from another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Subtraction(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used to subtract a Vector2 from another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Multiply(Axiom.Math.Vector2,Axiom.Math.Real)">
            <summary>
            	Used when a Vector2 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Multiply(Axiom.Math.Vector2,Axiom.Math.Real)">
            <summary>
            	Used when a Vector2 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Multiply(Axiom.Math.Real,Axiom.Math.Vector2)">
            <summary>
            	Used when a scalar value is multiplied by a Vector2.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Multiply(Axiom.Math.Real,Axiom.Math.Vector2)">
            <summary>
            	Used when a scalar value is multiplied by a Vector2.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Negate(Axiom.Math.Vector2)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_UnaryNegation(Axiom.Math.Vector2)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Vector2.Length">
            <summary>
            Gets length of this vector
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector2.LengthSquared">
            <summary>
            Gets the squared length of this vector
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector2.Perpendicular">
            <summary>
            Gets a vector perpendicular to this, which has the same magnitude.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector2.Zero">
            <summary>
            	Gets a Vector2 with all components set to 0.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Technique">
            <summary>
            	Class representing an approach to rendering a particular Material. 
            </summary>
            <remarks>
               The engine will attempt to use the best technique supported by the active hardware, 
               unless you specifically request a lower detail technique (say for distant rendering)
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.Technique._passes">
            <summary>
               The list of passes (fixed function or programmable) contained in this technique.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique._illuminationPasses">
            <summary>
            	List of derived passes, categorized (and ordered) into illumination stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique._parent">
            <summary>
               The material that owns this technique.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique._isSupported">
            <summary>
               Flag that states whether or not this technique is supported on the current hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique._name">
            <summary>
               Name of this technique.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique._lodIndex">
            <summary>
            	Level of detail index for this technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Sets the fogging mode applied to each pass.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.SetFog"></see>
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Technique.ClearIlluminationPasses">
            <summary>
            	Internal method for clearing the illumination pass list.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.Clone(Axiom.Graphics.Material)">
            <summary>
               Clones this Technique.
            </summary>
            <param name="parent">Material that will own this technique.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Technique.CopyTo(Axiom.Graphics.Technique)">
            <summary>
            	Copy the details of this Technique to another.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Graphics.Technique.Compile(System.Boolean)">
            <summary>
               Compilation method for Techniques.  See <see cref="T:Axiom.Graphics.Material"/>
            </summary>
            <param name="autoManageTextureUnits">
               Determines whether or not the engine should split up extra texture unit requests
               into extra passes if the hardware does not have enough available units.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Technique.CompileIlluminationPasses">
            <summary>
            	Internal method for splitting the passes into illumination passes.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.CreatePass">
            <summary>
               Creates a new Pass for this technique.
            </summary>
            <remarks>
               A Pass is a single rendering pass, ie a single draw of the given material.
               Note that if you create a non-programmable pass, during compilation of the
               material the pass may be split into multiple passes if the graphics card cannot
               handle the number of texture units requested. For programmable passes, however, 
               the number of passes you create will never be altered, so you have to make sure 
               that you create an alternative fallback Technique for if a card does not have 
               enough facilities for what you're asking for.
            </remarks>
            <returns>A new Pass object reference.</returns>
        </member>
        <member name="M:Axiom.Graphics.Technique.GetPass(System.String)">
            <summary>
               Retreives the Pass by name.
            </summary>
            <param name="passName">Name of the Pass to retreive.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.GetPass(System.Int32)">
            <summary>
               Retreives the Pass at the specified index.
            </summary>
            <param name="index">Index of the Pass to retreive.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.GetIlluminationPass(System.Int32)">
            <summary>
               Retreives the IlluminationPass at the specified index.
            </summary>
            <param name="index">Index of the IlluminationPass to retreive.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.Preload">
            <summary>
               Preloads resources required by this Technique.  This is the 
               portion that is safe to do from a thread other than the 
               main render thread.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.Load">
            <summary>
               Loads resources required by this Technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.NotifyNeedsRecompile">
            <summary>
               Forces this Technique to recompile.
            </summary>
            <remarks>
               The parent Material is asked to recompile to accomplish this.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Technique.RemovePass(Axiom.Graphics.Pass)">
            <summary>
               Removes the specified Pass from this Technique.
            </summary>
            <param name="pass">A reference to the Pass to be removed.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.RemoveAllPasses">
            <summary>
            	Removes all passes from this technique and queues them for deletion.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.Unload">
            <summary>
               Unloads resources used by this Technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.AddGPUVenderRule(Axiom.Graphics.Technique.GPUVendorRule)">
            <summary>
            Add a rule which manually influences the support for this technique based
            on a GPU vendor.
            </summary>
            <remarks>
            You can use this facility to manually control whether a technique is
            considered supported, based on a GPU vendor. You can add inclusive
            or exclusive rules, and you can add as many of each as you like. If
            at least one inclusive rule is added, a	technique is considered 
            unsupported if it does not match any of those inclusive rules. If exclusive rules are
            added, the technique is considered unsupported if it matches any of
            those inclusive rules.
            Note that any rule for the same vendor will be removed before adding this one.
            /// </remarks>
            <param name="rule"></param>
        </member>
        <member name="M:Axiom.Graphics.Technique.RemoveGPUVendorRule(Axiom.Graphics.Technique.GPUVendorRule)">
            <summary>
            Removes a matching vendor rule.
            </summary>
            <see cref="M:Axiom.Graphics.Technique.AddGPUVenderRule(Axiom.Graphics.Technique.GPUVendorRule)"/>
            <param name="rule"></param>
        </member>
        <member name="M:Axiom.Graphics.Technique.AddGPUDeviceNameRule(Axiom.Graphics.Technique.GPUDeviceNameRule)">
            <summary>
            Add a rule which manually influences the support for this technique based
            on a pattern that matches a GPU device name (e.g. '*8800*').
            </summary>
            <remarks>
            You can use this facility to manually control whether a technique is
            considered supported, based on a GPU device name pattern. You can add inclusive
            or exclusive rules, and you can add as many of each as you like. If
            at least one inclusive rule is added, a	technique is considered 
            unsupported if it does not match any of those inclusive rules. If exclusive rules are
            added, the technique is considered unsupported if it matches any of
            those inclusive rules. The pattern you supply can include wildcard
            characters ('*') if you only want to match part of the device name.
            Note that any rule for the same device pattern will be removed before adding this one.
            </remarks>
            <param name="rule"></param>
        </member>
        <member name="M:Axiom.Graphics.Technique.RemoveGPUDeviceNameRule(Axiom.Graphics.Technique.GPUDeviceNameRule)">
            <summary>
            Removes a matching device name rule.
            </summary>
            <see cref="M:Axiom.Graphics.Technique.AddGPUDeviceNameRule(Axiom.Graphics.Technique.GPUDeviceNameRule)"/>
            <param name="rule"></param>
        </member>
        <member name="P:Axiom.Graphics.Technique.Parent">
            <summary>
               Gets a reference to the Material that owns this Technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.IsSupported">
            <summary>
               Flag that states whether or not this technique is supported on the current hardware.
            </summary>
            <remarks>
               This will only be correct after the Technique has been compiled, which is
               usually triggered in Material.Compile.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Name">
            <summary>
               Gets/Sets the name of this technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.LodIndex">
            <summary>
            	Assigns a level-of-detail (LOD) index to this Technique.
            </summary>
            <remarks>
            	As noted previously, as well as providing fallback support for various
            	graphics cards, multiple Technique objects can also be used to implement
            	material LOD, where the detail of the material diminishes with distance to 
            	save rendering power.
            	<p/>
            	By default, all Techniques have a LOD index of 0, which means they are the highest
            	level of detail. Increasing LOD indexes are lower levels of detail. You can 
            	assign more than one Technique to the same LOD index, meaning that the best 
            	Technique that is supported at that LOD index is used. 
            	<p/>
            	You should not leave gaps in the LOD sequence; the engine will allow you to do this
            	and will continue to function as if the LODs were sequential, but it will 
            	confuse matters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.IlluminationPassCount">
            <summary>
            	Gets the number of illumination passes compiled from this technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.PointSize">
            <summary>
            Sets the point size properties for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.PointSize"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Ambient">
            <summary>
            Sets the ambient size properties for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.Ambient"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Diffuse">
            <summary>
            Sets the Diffuse property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.Diffuse"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Specular">
            <summary>
            Sets the Specular property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.Specular"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Shininess">
            <summary>
            Sets the Shininess property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.Shininess"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.SelfIllumination">
            <summary>
            Sets the SelfIllumination property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.SelfIllumination"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Emissive">
            <summary>
            Sets the Emissive property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.Emissive"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.CullingMode">
            <summary>
            Sets the CullingMode property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.CullingMode"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.ManualCullingMode">
            <summary>
            Sets the ManualCullingMode property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.ManualCullingMode"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.LightingEnabled">
            <summary>
            Sets whether or not dynamic lighting is enabled for every Pass.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.LightingEnabled"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.DepthBias">
            <summary>
            Sets the depth bias to be used for each Pass.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.DepthBias"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.ShadingMode">
            <summary>
            Sets the type of light shading required
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.ShadingMode"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.DepthCheck">
            <summary>
            Sets the DepthCheck property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.DepthCheck"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.DepthFunction">
            <summary>
            Sets the function used to compare depth values when depth checking is on.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.DepthFunction"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.DepthWrite">
            <summary>
            Sets the DepthWrite property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.DepthWrite"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.ColorWriteEnabled">
            <summary>
            Sets whether or not colour buffer writing is enabled for each Pass.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.ColorWriteEnabled"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.TextureAnisotropy">
            <summary>
            Sets the anisotropy level to be used for all textures.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see ref="Pass.TextureAnisotropy"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.TextureFiltering">
            <summary>
            Sets the TextureFiltering property for every Pass in this Technique.
            </summary>
            <remarks>
            This property actually exists on the Pass class. For simplicity, this method allows 
            you to set these properties for every current Pass within this Technique. If 
            you need more precision, retrieve the Pass instance and set the
            property there.
            <see cref="P:Axiom.Graphics.Pass.TextureFiltering"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.IsLoaded">
            <summary>
               Returns true if this Technique has already been loaded.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.IsTransparent">
            <summary>
               Returns true if this Technique involves transparency.
            </summary>
            <remarks>
               This basically boils down to whether the first pass
               has a scene blending factor. Even if the other passes 
               do not, the base color, including parts of the original 
               scene, may be used for blending, therefore we have to treat
               the whole Technique as transparent.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.PassCount">
            <summary>
               Gets the number of passes within this Technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.SchemeName">
            <summary>
            Get/Set the 'scheme name' for this technique. 
            </summary>
            <remarks>
            Material schemes are used to control top-level switching from one
            set of techniques to another. For example, you might use this to 
            define 'high', 'medium' and 'low' complexity levels on materials
            to allow a user to pick a performance / quality ratio. Another
            possibility is that you have a fully HDR-enabled pipeline for top
            machines, rendering all objects using unclamped shaders, and a 
            simpler pipeline for others; this can be implemented using 
            schemes.
            <para>
            Every technique belongs to a scheme - if you don't specify one, the
            Technique belongs to the scheme called 'Default', which is also the
            scheme used to render by default. The active scheme is set one of
            two ways - either by calling <see ref="Viewport.MaterialScheme" />, or
            by manually calling <see ref="MaterialManager.ActiveScheme" />.
            </para>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.SchemeIndex">
            <summary>
            The material scheme index
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Technique.IlluminationPassesCompilationPhase">
            <summary>
            illumination pass state type
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Technique.GPUVendorRule">
            <summary>
            Rule controlling whether technique is deemed supported based on GPU vendor
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Technique.GPUDeviceNameRule">
            <summary>
            Rule controlling whether technique is deemed supported based on GPU device name
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowVolumeExtrudeProgram">
             <summary>
            		Static class containing source for vertex programs for extruding shadow volumes.
             </summary>
             <remarks>
            		This exists so we don't have to be dependent on an external media files.
            		 is used so we don't have to rely on particular plugins.
            		 assembler contents of this file were generated from the following Cg:
            		 
            		 <code>
            		 // Point light shadow volume extrude
                    void shadowVolumeExtrudePointLight_vp (
                        float4 position			: POSITION,
                        float  wcoord			: TEXCOORD0,
            
                        out float4 oPosition	: POSITION,
            
                        uniform float4x4 worldViewProjMatrix,
                        uniform float4   lightPos // homogenous, object space
                        )
                    {
                        // extrusion in object space
                        // vertex unmodified if w==1, extruded if w==0
                        float4 newpos = 
                            (wcoord.xxxx * lightPos) + 
                            float4(position.xyz - lightPos.xyz, 0);
            
                        oPosition = mul(worldViewProjMatrix, newpos);
            
                    }
            
                   // Directional light extrude
                    void shadowVolumeExtrudeDirLight_vp (
                       float4 position			: POSITION,
                       float  wcoord			: TEXCOORD0,
            
                      out float4 oPosition	: POSITION,
            
                       uniform float4x4 worldViewProjMatrix,
                     uniform float4   lightPos // homogenous, object space
                       )
                   {
                       // extrusion in object space
                       // vertex unmodified if w==1, extruded if w==0
                        float4 newpos = 
                           (wcoord.xxxx * (position + lightPos)) - lightPos;
            
                      oPosition = mul(worldViewProjMatrix, newpos);
            
                   }
                    // Point light shadow volume extrude - FINITE
                    void shadowVolumeExtrudePointLightFinite_vp (
                        float4 position			: POSITION,
                       float  wcoord			: TEXCOORD0,
            
                      out float4 oPosition	: POSITION,
            
                       uniform float4x4 worldViewProjMatrix,
                      uniform float4   lightPos, // homogenous, object space
            			uniform float    extrusionDistance // how far to extrude
                      )
                   {
                        // extrusion in object space
                       // vertex unmodified if w==1, extruded if w==0
            			float3 extrusionDir = position.xyz - lightPos.xyz;
            			extrusionDir = normalize(extrusionDir);
            			
                       float4 newpos = float4(position.xyz +  
                            ((1 - wcoord.x) * extrusionDistance * extrusionDir), 1);
            
                       oPosition = mul(worldViewProjMatrix, newpos);
            
                    }
            
                  // Directional light extrude - FINITE
                   void shadowVolumeExtrudeDirLightFinite_vp (
                        float4 position			: POSITION,
                        float  wcoord			: TEXCOORD0,
            
                        out float4 oPosition	: POSITION,
            
                        uniform float4x4 worldViewProjMatrix,
                        uniform float4   lightPos, // homogenous, object space
            			uniform float    extrusionDistance // how far to extrude
                        )
                   {
                        // extrusion in object space
                        // vertex unmodified if w==1, extruded if w==0
            			// -ve lightPos is direction
                        float4 newpos = float4(position.xyz - 
                            (wcoord.x * extrusionDistance * lightPos.xyz), 1);
            
                        oPosition = mul(worldViewProjMatrix, newpos);
            
                    }		
            		 </code>
             </remarks>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.#ctor">
            <summary>
            	This is a static class; don't allow instantiation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.isInitialized">
            <summary>
            	Have the hardware extrusion programs been initialized yet?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.GetProgramSource(Axiom.Graphics.LightType,System.String,System.Boolean,System.Boolean)">
            <summary>
            	General purpose method to get any of the program sources.
            </summary>
            <param name="lightType">Type of light to get the source for.</param>
            <param name="syntax">Syntax code of interest.</param>
            <param name="finite">Is this for finite volume extrusion?</param>
            <param name="debug">Should the shadow volumes be visible?</param>
            <returns>Source of the specified program.</returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.GetProgramName(Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs)">
            <summary>
            	Gets the name of the program for the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.GetProgramName(Axiom.Graphics.LightType,System.Boolean,System.Boolean)">
            <summary>
            	General purpose method to get any of the program names based on the specified parameters.
            </summary>
            <param name="lightType">Type of light to get the source for.</param>
            <param name="finite">Is this for finite volume extrusion?</param>
            <param name="debug">Should the shadow volumes be visible?</param>
            <returns>Name of the program matching the specified parameters.</returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.Initialize">
            <summary>
            	Initialize the creation of these core vertex programs.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.Shutdown">
            <summary>
                Called on engine shutdown; destroys all auto created gpu programs.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs">
            <summary>
            	Contains the possible hardware extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLight">
            <summary>
            	Point light extruder, infinite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLightDebug">
            <summary>
            	Point light extruder, infinite distance, debug mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLight">
            <summary>
            	Directional light extruder, infinite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLightDebug">
            <summary>
            	Directional light extruder, infinite distance, debug mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLightFinite">
            <summary>
            	Point light extruder, finite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLightFiniteDebug">
            <summary>
            	Point light extruder, finite distance, debug mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLightFinite">
            <summary>
            	Directional light extruder, finite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLightFiniteDebug">
            <summary>
            	Directional light extruder, finite distance, debug mode.
            </summary>
        </member>
        <member name="T:Axiom.Core.Timer">
            <summary>
            	Encapsulates the functionality of the platform's highest resolution timer available.
            </summary>
            <remarks>
            based on an vb.net implementation by createdbyx as posted in SourceForge Tracker #: [1612705]
            </remarks>
        </member>
        <member name="M:Axiom.Core.Timer.Start">
            <summary>
            Start this instance's timer.
            </summary>
        </member>
        <member name="M:Axiom.Core.Timer.Reset">
            <summary>
            	Reset this instance's timer.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.Count">
            <summary>
            Gets a <see cref="T:System.Int64"/> representing the 
            current tick count of the timer.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.Frequency">
            <summary>
            Gets a <see cref="T:System.Int64"/> representing the 
            frequency of the counter in ticks-per-second.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.IsRunning">
            <summary>
            Gets a <see cref="T:System.Boolean"/> representing whether the 
            timer has been started and is currently running.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.Resolution">
            <summary>
            Gets a <see cref="T:System.Double"/> representing the 
            resolution of the timer in seconds.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.StartCount">
            <summary>
            Gets a <see cref="T:System.Int64"/> representing the 
            tick count at the start of the timer's run.
            </summary>
        </member>
        <member name="T:Axiom.Core.TextureManager">
            <summary>
               Class for loading &amp; managing textures.
            </summary>
            <remarks>
               Texture manager serves as an abstract singleton for all API specific texture managers.
            	When a class inherits from this and is created, a instance of that class (i.e. GLTextureManager)
            	is stored in the global singleton instance of the TextureManager.
            	Note: This will not take place until the RenderSystem is initialized and at least one RenderWindow
            	has been created.
            </remarks>
        </member>
        <member name="F:Axiom.Core.TextureManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
            <remarks>
                Protected internal because this singleton will actually hold the instance of a subclass
                created by a render system plugin.
            </remarks>
        </member>
        <member name="F:Axiom.Core.TextureManager._is32Bit">
            <summary>
               Flag that indicates whether 32-bit texture are being used.
            </summary>
        </member>
        <member name="F:Axiom.Core.TextureManager._defaultMipmapCount">
            <summary>
               Default number of mipmaps to be used for loaded textures.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.CreateManual(System.String,System.String,Axiom.Graphics.TextureType,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat,Axiom.Graphics.TextureUsage,Axiom.Core.IManualResourceLoader,System.Boolean,System.Int32,System.String)">
            <summary>
            Create a manual texture with specified width, height and depth (not loaded from a file).
            </summary>
            <param name="name">The name to give the resulting texture</param>
            <param name="group">The name of the resource group to assign the texture to</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures</param>
            <param name="width">The dimensions of the texture</param>
            <param name="height">The dimensions of the texture</param>
            <param name="depth">The dimensions of the texture</param>
            <param name="numMipMaps">
            The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
            the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()).
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
            level, 1x1x1.
            </param>
            <param name="format">
            The internal format you wish to request; the manager reserves
            the right to create a different format if the one you select is
            not available in this context.
            </param>
            <param name="usage">
            The kind of usage this texture is intended for. It
            is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY,
            TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are
            strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to
            update regularly, consider HBU_DYNAMIC_WRITE_ONLY.
            </param>
            <param name="loader">
            If you intend the contents of the manual texture to be
            regularly updated, to the extent that you don't need to recover
            the contents if the texture content is lost somehow, you can leave
            this parameter as null. However, if you intend to populate the
            texture only once, then you should implement ManualResourceLoader
            and pass a pointer to it in this parameter; this means that if the
            manual texture ever needs to be reloaded, the ManualResourceLoader
            will be called to do it.
            </param>
            <param name="hwGammaCorrection"></param>
            <param name="fsaa"></param>
            <param name="fsaaHint"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.CreateManual(System.String,System.String,Axiom.Graphics.TextureType,System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat,Axiom.Graphics.TextureUsage,Axiom.Core.IManualResourceLoader)">
            <summary>
            Create a manual texture with a depth of 1 (not loaded from a file).
            </summary>
            <param name="name">The name to give the resulting texture</param>
            <param name="group">The name of the resource group to assign the texture to</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures</param>
            <param name="width">The dimensions of the texture</param>
            <param name="height">The dimensions of the texture</param>
            <param name="numMipmaps">
            The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
            the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()).
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
            level, 1x1x1.
            </param>
            <param name="format">
            The internal format you wish to request; the manager reserves
            the right to create a different format if the one you select is
            not available in this context.
            </param>
            <param name="usage">
            The kind of usage this texture is intended for. It
            is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY,
            TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are
            strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to
            update regularly, consider HBU_DYNAMIC_WRITE_ONLY.
            </param>
            <param name="loader">
            If you intend the contents of the manual texture to be
            regularly updated, to the extent that you don't need to recover
            the contents if the texture content is lost somehow, you can leave
            this parameter as null. However, if you intend to populate the
            texture only once, then you should implement ManualResourceLoader
            and pass a pointer to it in this parameter; this means that if the
            manual texture ever needs to be reloaded, the ManualResourceLoader
            will be called to do it.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.CreateManual(System.String,System.String,Axiom.Graphics.TextureType,System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat,Axiom.Graphics.TextureUsage)">
            <summary>
            Create a manual texture with a depth of 1 (not loaded from a file).
            </summary>
            <param name="name">The name to give the resulting texture</param>
            <param name="group">The name of the resource group to assign the texture to</param>
            <param name="type">The type of texture to load/create, defaults to normal 2D textures</param>
            <param name="width">The dimensions of the texture</param>
            <param name="height">The dimensions of the texture</param>
            <param name="numMipmaps">
            The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then
            the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()).
            If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible
            level, 1x1x1.
            </param>
            <param name="format">
            The internal format you wish to request; the manager reserves
            the right to create a different format if the one you select is
            not available in this context.
            </param>
            <param name="usage">
            The kind of usage this texture is intended for. It
            is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY,
            TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are
            strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to
            update regularly, consider HBU_DYNAMIC_WRITE_ONLY.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,System.String)">
            <summary>
               Loads a texture with the specified name.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,System.String,Axiom.Graphics.TextureType)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,System.String,Axiom.Graphics.TextureType,System.Int32,System.Single,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,System.String,Axiom.Graphics.TextureType,System.Int32,System.Single,System.Boolean,Axiom.Media.PixelFormat)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,System.String,Axiom.Media.Image)">
            <summary>
            Loads a pre-existing image into the texture.
            </summary>
            <param name="name"></param>
            <param name="group"></param>
            <param name="image"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,System.String,Axiom.Media.Image,Axiom.Graphics.TextureType)">
            <summary>
            Loads a pre-existing image into the texture.
            </summary>
            <param name="name"></param>
            <param name="group"></param>
            <param name="image"></param>
            <param name="texType"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,System.String,Axiom.Media.Image,Axiom.Graphics.TextureType,System.Int32,System.Single,System.Boolean,Axiom.Media.PixelFormat)">
            <summary>
            	Loads a pre-existing image into the texture.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.dispose(System.Boolean)">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.IsHardwareFilteringSupported(Axiom.Graphics.TextureType,Axiom.Media.PixelFormat,System.Int32)">
            <summary>
            Returns whether this render system has hardware filtering supported for the
            texture format requested with the given usage options.
            </summary>
            <param name="ttype">The texture type requested</param>
            <param name="format">The pixel format requested</param>
            <param name="usage">the kind of usage this texture is intended for, a combination of the TextureUsage flags.</param>
            <returns>true if the texture filtering is supported.</returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.IsHardwareFilteringSupported(Axiom.Graphics.TextureType,Axiom.Media.PixelFormat,System.Int32,System.Boolean)">
            <summary>
            Returns whether this render system has hardware filtering supported for the
            texture format requested with the given usage options.
            </summary>
            <param name="ttype">The texture type requested</param>
            <param name="format">The pixel format requested</param>
            <param name="usage">the kind of usage this texture is intended for, a combination of the TextureUsage flags.</param>
            <param name="preciseFormatOnly">
            Whether precise or fallback format mode is used to detecting.
            In case the pixel format doesn't supported by device, false will be returned
            if in precise mode, and natively used pixel format will be actually use to
            check if in fallback mode.
            </param>
            <returns>true if the texture filtering is supported.</returns>
        </member>
        <member name="P:Axiom.Core.TextureManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureManager.Is32Bit">
            <summary>
               Flag that indicates whether 32-bit texture are being used.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureManager.DefaultMipmapCount">
            <summary>
               Gets/Sets the default number of mipmaps to be used for loaded textures.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureManager.Item(System.String)">
            <summary>
               Returns an instance of Texture that has the supplied name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.PluginManager">
            <summary>
            Summary description for PluginManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.PluginManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Core.PluginManager._plugins">
            <summary>
            	List of loaded plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.LoadAll">
            <summary>
            	Loads all plugins specified in the plugins section of the app.config file.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.ScanForPlugins">
            <summary>
            	Scans for plugin files in the current directory.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.IsValidModule(System.String)">
            <summary>
            Checks if the given Module contains managed code
            </summary>
            <param name="file">The file to check</param>
            <returns>True if the module contains CLR data</returns>
        </member>
        <member name="M:Axiom.Core.PluginManager.ScanForPlugins(System.String)">
             <summary>
            		Scans for plugin files in the current directory.
             </summary>
            <param name="folder"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PluginManager.UnloadAll">
            <summary>
            	Unloads all currently loaded plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.LoadPlugin(Axiom.Core.ObjectCreator)">
            <summary>
            	Loads a plugin of the given class name from the given assembly, and calls Initialize() on it.
            	This function does NOT add the plugin to the PluginManager's
            	list of plugins.
            </summary>
            <returns>The loaded plugin.</returns>
        </member>
        <member name="P:Axiom.Core.PluginManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Core.PluginManager.InstalledPlugins">
            <summary>
            Gets a read only collection with all known plugins.
            </summary>
        </member>
        <member name="T:Axiom.Core.NodeUpdateHandler">
            <summary>
            Signature for the Node.UpdatedFromParent event which provides the newly-updated derived properties for syncronization in a physics engine for instance
            </summary>
        </member>
        <member name="T:Axiom.Core.LoggingLevel">
            <summary>
                The level of detail in which the log will go into.
            </summary>
        </member>
        <member name="T:Axiom.Core.LogMessageLevel">
            <summary>
                The importance of a logged message.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneType">
            <summary>
               The different types of scenes types that can be handled by the engine.  The various types can
               be altered by plugin functionality (i.e. BSP for interior, Octree for Exterior, etc).
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneQueryTypeMask">
            <summary>
            Scene Query Type Mask values
            </summary>
            <seealso cref="T:Axiom.Core.SceneQuery"/>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.WorldGeometry">
            <summary>Query type mask which will be used for world geometry <see cref="T:Axiom.Core.SceneQuery"/></summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.Entity">
            <summary>Query type mask which will be used for entities <see cref="T:Axiom.Core.SceneQuery"/></summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.Fx">
            <summary>Query type mask which will be used for effects like billboardsets / particle systems <see cref="T:Axiom.Core.SceneQuery"/></summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.StaticGeometry">
            <summary>Query type mask which will be used for StaticGeometry <see cref="T:Axiom.Core.SceneQuery"/></summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.Light">
            <summary>Query type mask which will be used for lights <see cref="T:Axiom.Core.SceneQuery"/></summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.Frustum">
            <summary>Query type mask which will be used for frusta and cameras <see cref="T:Axiom.Core.SceneQuery"/></summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryTypeMask.UserLimit">
            <summary>User type mask limit</summary>
        </member>
        <member name="T:Axiom.Core.BillboardOrigin">
            <summary>
            	Covers what a billboards position means.
            </summary>
        </member>
        <member name="F:Axiom.Core.BillboardRotationType.Vertex">
            <summary>Rotate the billboard's vertices around their facing direction</summary>
        </member>
        <member name="F:Axiom.Core.BillboardRotationType.Texcoord">
            <summary>Rotate the billboard's texture coordinates</summary>
        </member>
        <member name="T:Axiom.Core.BillboardType">
            <summary>
            	Type of billboard to use for a BillboardSet.
            </summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.Point">
            <summary>Standard point billboard (default), always faces the camera completely and is always upright</summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.OrientedCommon">
            <summary>Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera</summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.OrientedSelf">
            <summary>Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera</summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.PerpendicularCommon">
            <summary>Billboards are oriented perpendicular to a shared direction vector</summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.PerpendicularSelf">
            <summary>Billboards are oriented perpendicular to their own direction vector</summary>
        </member>
        <member name="T:Axiom.Core.BoxPlane">
            <summary>
            	Specifying the side of a box, used for things like skyboxes, etc.
            </summary>
        </member>
        <member name="T:Axiom.Core.FrustumPlane">
            <summary>
            Defines the 6 planes the make up a frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.FrustumPlane.None">
            <summary>Used for methods that require returning a value of this type but cannot return null.</summary>
        </member>
        <member name="T:Axiom.Core.PrefabEntity">
            <summary>
            	Canned entities that can be created on demand.
            </summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Plane">
            <summary>A flat plane.</summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Cube">
            <summary>Typical box.</summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Sphere">
            <summary>That round shape.</summary>
        </member>
        <member name="T:Axiom.Core.RenderQueueGroupID">
            <summary>
            	Priorities that can be assigned to renderable objects for sorting.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Background">
            <summary>
            	Objects that must be rendered first (like backgrounds).
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.SkiesEarly">
            <summary>
            	First queue (after backgrounds), used for skyboxes if rendered first.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.One">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Two">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Three">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Four">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Main">
            <summary>Default queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Six">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Seven">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Eight">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Nine">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.SkiesLate">
            <summary>
            	Last queue before overlays, used for skyboxes if rendered last.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Overlay">
            <summary>
            	Use this queue for objects which must be rendered last e.g. overlays.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Count">
            <summary>
            	A count of the set of all render queues
            </summary>
        </member>
        <member name="T:Axiom.Core.TransformSpace">
            <summary>
                Denotes the spaces which a transform can be relative to.
            </summary>
        </member>
        <member name="F:Axiom.Core.TransformSpace.Local">
            <summary>
                Transform is relative to the local space.
            </summary>
        </member>
        <member name="F:Axiom.Core.TransformSpace.Parent">
            <summary>
                Transform is relative to the space of the parent node.
            </summary>
        </member>
        <member name="F:Axiom.Core.TransformSpace.World">
            <summary>
                Transform is relative to world space.
            </summary>
        </member>
        <member name="T:Axiom.Core.WorldFragmentType">
            <summary>
               This type can be used by collaborating applications &amp; SceneManagers to
               agree on the type of world geometry to be returned from queries. Not all
               these types will be supported by all SceneManagers; once the application
               has decided which SceneManager specialization to use, it is expected that
               it will know which type of world geometry abstraction is available to it.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.None">
            <summary>
               Return no world geometry hits at all.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.PlaneBoundedRegion">
            <summary>
               Return references to convex plane-bounded regions.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.SingleIntersection">
            <summary>
               Return a single intersection point (typically RaySceneQuery only)
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.CustomGeometry">
            <summary>
               Custom geometry as defined by the SceneManger.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.RenderOperation">
            <summary>
               General RenderOperation structure.
            </summary>
        </member>
        <member name="T:Axiom.Core.AxiomException">
            <summary>
            Summary description for AxiomException.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.FloatGpuParamControllerValue">
            <summary>
                Predefined controller value for setting a single floating-
                point value in a constant paramter of a vertex or fragment program.
            </summary>
            <remarks>
                Any value is accepted, it is propagated into the 'x'
                component of the constant register identified by the index. If you
                need to use named parameters, retrieve the index from the param
                object before setting this controller up.
                <p/>
                Note: Retrieving a value from the program parameters is not currently 
                supported, therefore do not use this controller value as a source,
                only as a target.
            </remarks>
        </member>
        <member name="F:Axiom.Controllers.Canned.FloatGpuParamControllerValue.parms">
            <summary>
                Gpu parameters to access.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.FloatGpuParamControllerValue.index">
            <summary>
                The constant register index of the parameter to set.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.FloatGpuParamControllerValue.vec4">
            <summary>
                Member level Vector to use for returning.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Canned.FloatGpuParamControllerValue.#ctor(Axiom.Graphics.GpuProgramParameters,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="parms">Params to set.</param>
            <param name="index">Index of the parameter to set.</param>
        </member>
        <member name="P:Axiom.Controllers.Canned.FloatGpuParamControllerValue.Value">
            <summary>
            Gets or Sets the value of the GPU parameter
            </summary>
        </member>
        <member name="T:Axiom.Controllers.ControllerManager">
            <summary>
            Summary description for ControllerManager.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.controllers">
            <summary>
            	List of references to controllers in a scene.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.frameTimeController">
            <summary>
            	Local instance of a FrameTimeControllerValue to be used for time based controllers.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateController(Axiom.Controllers.IControllerValue{System.Single},Axiom.Controllers.IControllerFunction{System.Single})">
            <summary>
            	Overloaded method.  Creates a new controller, using a reference to a FrameTimeControllerValue as
            	the source.
            </summary>
            <param name="destination">Controller value to use as the destination.</param>
            <param name="function">Controller funcion that will use the source value to set the destination.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateController(Axiom.Controllers.IControllerValue{System.Single},Axiom.Controllers.IControllerValue{System.Single},Axiom.Controllers.IControllerFunction{System.Single})">
            <summary>
            	Factory method for creating an instance of a controller based on the input provided.
            </summary>
            <param name="source">Controller value to use as the source.</param>
            <param name="destination">Controller value to use as the destination.</param>
            <param name="function">Controller funcion that will use the source value to set the destination.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureAnimator(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a texture layer animator controller.
            </summary>
            <remarks>
                This helper method creates the Controller, IControllerValue and IControllerFunction classes required
                to animate a texture.
            </remarks>
            <param name="texUnit">The texture unit to animate.</param>
            <param name="sequenceTime">Length of the animation (in seconds).</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureRotator(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a basic time-based texture coordinate modifier designed for creating rotating textures.
            </summary>
            <remarks>
                This simple method allows you to easily create constant-speed rotating textures. If you want more
                control, look up the ControllerManager.CreateTextureWaveTransformer for more complex wave-based
                scrollers / stretchers / rotaters.
            </remarks>
            <param name="layer">The texture unit to animate.</param>
            <param name="speed">Speed of the rotation, in counter-clockwise revolutions per second.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateGpuProgramTimerParam(Axiom.Graphics.GpuProgramParameters,System.Int32,System.Single)">
            <summary>
                Predefined controller value for setting a single floating-
                point value in a constant paramter of a vertex or fragment program.
            </summary>
            <remarks>
                Any value is accepted, it is propagated into the 'x'
                component of the constant register identified by the index. If you
                need to use named parameters, retrieve the index from the param
                object before setting this controller up.
            </remarks>
            <param name="parms"></param>
            <param name="index"></param>
            <param name="timeFactor"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureUVScroller(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a basic time-based texture uv coordinate modifier designed for creating scrolling textures.
            </summary>
            <remarks>
                This simple method allows you to easily create constant-speed scrolling textures. If you want to
                specify differnt speed values for horizontil and vertical scroll, use the specific methods
                <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureUScroller(Axiom.Graphics.TextureUnitState,System.Single)"/> and <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureVScroller(Axiom.Graphics.TextureUnitState,System.Single)"/>. If you want more
                control, look up the <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureWaveTransformer(Axiom.Graphics.TextureUnitState,Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)"/> for more complex wave-based
                scrollers / stretchers / rotaters.
            </remarks>
            <param name="layer">The texture unit to animate.</param>
            <param name="speed">speed, in wraps per second.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureUScroller(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a basic time-based texture u coordinate modifier designed for creating scrolling textures.
            </summary>
            <remarks>
                This simple method allows you to easily create constant-speed scrolling textures. If you want more
                control, look up the <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureWaveTransformer(Axiom.Graphics.TextureUnitState,Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)"/> for more complex wave-based
                scrollers / stretchers / rotaters.
            </remarks>
            <param name="layer">The texture unit to animate.</param>
            <param name="speed">speed, in wraps per second.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureVScroller(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a basic time-based texture v coordinate modifier designed for creating scrolling textures.
            </summary>
            <remarks>
                This simple method allows you to easily create constant-speed scrolling textures. If you want more
                control, look up the <see cref="M:Axiom.Controllers.ControllerManager.CreateTextureWaveTransformer(Axiom.Graphics.TextureUnitState,Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)"/> for more complex wave-based
                scrollers / stretchers / rotaters.
            </remarks>
            <param name="layer">The texture unit to animate.</param>
            <param name="speed">speed, in wraps per second.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureWaveTransformer(Axiom.Graphics.TextureUnitState,Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Creates a very flexible time-based texture transformation which can alter the scale, position or
                rotation of a texture based on a wave function.	
            </summary>
            <param name="layer">The texture unit to effect.</param>
            <param name="type">The type of transform, either translate (scroll), scale (stretch) or rotate (spin).</param>
            <param name="waveType">The shape of the wave, see WaveformType enum for details.</param>
            <param name="baseVal">The base value of the output.</param>
            <param name="frequency">The speed of the wave in cycles per second.</param>
            <param name="phase">The offset of the start of the wave, e.g. 0.5 to start half-way through the wave.</param>
            <param name="amplitude">Scales the output so that instead of lying within 0..1 it lies within 0..(1 * amplitude) for exaggerated effects</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.UpdateAll">
            <summary>
            	Causes all registered controllers to execute.  This will depend on RenderSystem.BeginScene already
            	being called so that the time since last frame can be obtained for calculations.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.dispose(System.Boolean)">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.ControllerManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.DriverVersion">
            <summary>
            DriverVersion is used by RenderSystemCapabilities and both GL and D3D9
            to store the version of the current GPU driver
            </summary>
        </member>
        <member name="M:Axiom.Graphics.DriverVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Graphics.DriverVersion.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.DriverVersion.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.DriverVersion.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.DriverVersion.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="versionString"></param>
        </member>
        <member name="T:Axiom.Core.DistanceLodStrategy">
            <summary>
            Level of detail strategy based on distance from camera.
            </summary>
        </member>
        <member name="F:Axiom.Core.DistanceLodStrategy.ReferenceViewValue">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.DistanceLodStrategy._referenceViewEnabled">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Core.DistanceLodStrategy.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.DistanceLodStrategy.SetReferenceView(System.Single,System.Single,Axiom.Math.Radian)">
            <summary>
            Sets the reference view upon which the distances were based.
            </summary>
            <note>
            This automatically enables use of the reference view.
             There is no corresponding get method for these values as
               they are not saved, but used to compute a reference value.
            </note>
            <param name="viewportWidth"></param>
            <param name="viewportHeight"></param>
            <param name="fovY"></param>
        </member>
        <member name="P:Axiom.Core.DistanceLodStrategy.ReferenceViewEnabled">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Collections.MovableObjectCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.MovableObject">MovableObjects</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Collections.MovableObjectFactoryMap">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.MovableObjectFactory">MovableObjectFactorys</see> accessable by name.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.ImportAbstractNode">
            <summary>
            This abstract node represents an import statement
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.ImportAbstractNode.Clone">
            <see cref="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone"/>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.ImportAbstractNode.Value">
            <see cref="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value"/>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleSystemManager">
            <summary>
            	Manages particle systems, particle system scripts (templates) and the available emitter &amp; affector factories.
             </summary>
             <remarks>
            	This singleton class is responsible for creating and managing particle systems. All particle
            	systems must be created and destroyed using this object. Remember that like all other SceneObject
            	subclasses, ParticleSystems do not get rendered until they are attached to a SceneNode object.
            	<p/>
            	This class also manages factories for ParticleEmitter and ParticleAffector classes. To enable easy
            	extensions to the types of emitters (particle sources) and affectors (particle modifiers), the
            	ParticleSystemManager lets plugins or applications register factory classes which submit new
            	subclasses to ParticleEmitter and ParticleAffector. The engine comes with a number of them already provided,
            	such as cone, sphere and box-shaped emitters, and simple affectors such as constant directional force
            	and color faders. However using this registration process, a plugin can create any behavior
            	required.
            	<p/>
            	This class also manages the loading and parsing of particle system scripts, which are XML files
            	describing named particle system templates. Instances of particle systems using these templates can
            	then be created easily through the CreateParticleSystem method.
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.DefaultQuota">
            <summary>
                Default param constants.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.PARTICLE">
            <summary>
                Script parsing constants.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.systemTemplateList">
            <summary>
                List of template particle systems.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.systemList">
            <summary>
                Actual instantiated particle systems (may be based on template, may be manual).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.emitterFactoryList">
            <summary>
                Factories for named emitter type (can be extended using plugins).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.affectorFactoryList">
            <summary>
                Factories for named affector types (can be extended using plugins).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.rendererFactoryList">
            <summary>
                Factories for named renderer types (can be extended using plugins).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.timeFactor">
            <summary>
                Controls time. (1.0 is real time)
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddEmitterFactory(Axiom.ParticleSystems.ParticleEmitterFactory)">
            <summary>
            	Adds a new 'factory' object for emitters to the list of available emitter types.
             </summary>
             <remarks>
            	This method allows plugins etc to add new particle emitter types. Particle emitters
            	are sources of particles, and generate new particles with their start positions, colors and
            	momentums appropriately. Plugins would create new subclasses of ParticleEmitter which
            	emit particles a certain way, and register a subclass of ParticleEmitterFactory to create them (since multiple
            	emitters can be created for different particle systems).
            	<p/>
            	All particle emitter factories have an assigned name which is used to identify the emitter
            	type. This must be unique.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddAffectorFactory(Axiom.ParticleSystems.ParticleAffectorFactory)">
            <summary>
            	Adds a new 'factory' object for affectors to the list of available affector types.
             </summary>
              <remarks>
            	This method allows plugins etc to add new particle affector types. Particle
            	affectors modify the particles in a system a certain way such as affecting their direction
            	or changing their color, lifespan etc. Plugins would
            	create new subclasses of ParticleAffector which affect particles a certain way, and register
            	a subclass of ParticleAffectorFactory to create them.
            	<p/>
            	All particle affector factories have an assigned name which is used to identify the affector
            	type. This must be unique.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddRendererFactory(Axiom.ParticleSystems.ParticleSystemRendererFactory)">
            <summary>
            Registers a factory class for creating ParticleSystemRenderer instances.
            </summary>
            <param name="factory">
            factory Pointer to a ParticleSystemRendererFactory subclass created by the plugin or application code.
            </param>
            <remarks>
            Note that the object passed to this function will not be destroyed by the ParticleSystemManager,
            since it may have been allocted on a different heap in the case of plugins. The caller must
            destroy the object later on, probably on plugin shutdown.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddTemplate(System.String,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Adds a new particle system template to the list of available templates.
             </summary>
             <remarks>
            	Instances of particle systems in a scene are not normally unique - often you want to place the
            	same effect in many places. This method allows you to register a ParticleSystem as a named template,
            	which can subsequently be used to create instances using the CreateSystem method.
            	<p/>
            	Note that particle system templates can either be created programmatically by an application
            	and registered using this method, or they can be defined in a XML script file which is
            	loaded by the engine at startup, very much like Material scripts.
            </remarks>
            <param name="name">The name of the template. Must be unique across all templates.</param>
            <param name="system">A reference to a particle system to be used as a template.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateTemplate(System.String,System.String)">
            <summary>
            	Create a new particle system template.
            </summary>
            <remarks>
            	This method is similar to the AddTemplate method, except this just creates a new template
            	and returns a reference to it to be populated. Use this when you don't already have a system
            	to add as a template and just want to create a new template which you will build up at runtime.
            </remarks>
            <param name="name"></param>
            <param name="resourceGroup">The name of the resource group which will be used to load any dependent resources.</param>
            <returns>returns a reference to a ParticleSystem template to be populated</returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.Int32)">
            <summary>
            	Basic method for creating a blank particle system.
             </summary>
             <remarks>
            	This method creates a new, blank ParticleSystem instance and returns a reference to it.
            	<p/>
            	The instance returned from this method won't actually do anything because on creation a
            	particle system has no emitters. The caller should manipulate the instance through it's
            	ParticleSystem methods to actually create a real particle effect.
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode.
            </remarks>
            <param name="name">The name to give the ParticleSystem.</param>
            <param name="quota">The maximum number of particles to allow in this system.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.String,System.Int32)">
            <summary>
            	Creates a particle system based on a template.
             </summary>
             <remarks>
            	This method creates a new ParticleSystem instance based on the named template and returns a
            	reference to the caller.
            	<p/>
            	Each system created from a template takes the template's settings at the time of creation,
            	but is completely separate from the template from there on.
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode.
            	<p/>
            	This is probably the more useful particle system creation method since it does not require manual
            	setup of the system.
            </remarks>
            <param name="name">The name to give the new particle system instance.</param>
            <param name="templateName">The name of the template to base the new instance on.</param>
            <param name="quota">The maximum number of particles to allow in this system (can be changed later).</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateEmitter(System.String,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Internal method for creating a new emitter from a factory.
            </summary>
            <remarks>
            	Used internally by the engine to create new ParticleEmitter instances from named
            	factories. Applications should use the ParticleSystem.AddEmitter method instead,
            	which calls this method to create an instance.
            </remarks>
            <param name="emitterType">string name of the emitter type to be created. A factory of this type must have been registered.</param>
            <param name="ps"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateAffector(System.String)">
            <summary>
            	Internal method for creating a new affector from a factory.
            </summary>
            <remarks>
            	Used internally by the engine to create new ParticleAffector instances from named
            	factories. Applications should use the ParticleSystem.AddAffector method instead,
            	which calls this method to create an instance.
            </remarks>
            <param name="affectorType">string name of the affector type to be created. A factory of this type must have been registered.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.Initialize">
            <summary>
            	Internal method to init the particle systems.
            </summary>
            <remarks>
            	Since this method is dependent on other engine systems being started, this method will be called by the
            	engine when the render system is initialized.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAttrib(System.String,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Parses an attribute intended for the particle system itself.
            </summary>
            <param name="line"></param>
            <param name="system"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseEmitter(System.String,System.IO.TextReader,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAffector(System.String,System.IO.TextReader,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseEmitterAttrib(System.String,Axiom.ParticleSystems.ParticleEmitter)">
             <summary>
            
             </summary>
             <param name="line"></param>
             <param name="emitter"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAffectorAttrib(System.String,Axiom.ParticleSystems.ParticleAffector)">
             <summary>
            
             </summary>
             <param name="line"></param>
             <param name="affector"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RenderSystem_FrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	A listener that is added to the engine's render loop.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.dispose(System.Boolean)">
            <summary>
            Called when the engine is shutting down.
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.TimeFactor">
            <summary>
            	Get/Set the relative speed of time as perceived by particle systems.
             </summary>
             <remarks>
            	Normally particle systems are updated automatically in line with the real
            	passage of time. This method allows you to change that, so that
            	particle systems are told that the time is passing slower or faster than it
            	actually is. Use this to globally speed up / slow down particle systems.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.ParticleSystems">
            <summary>
            	List of available particle systems.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Affectors">
            <summary>
                List of available affector factories.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Emitters">
            <summary>
                List of available emitter factories.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexBufferBinding">
            <summary>
            	Records the state of all the vertex buffer bindings required to provide a vertex declaration
            	with the input data it needs for the vertex elements.
             </summary>
             <remarks>
            	Why do we have this binding list rather than just have VertexElement referring to the
            	vertex buffers direct? Well, in the underlying APIs, binding the vertex buffers to an
            	index (or 'stream') is the way that vertex data is linked, so this structure better
            	reflects the realities of that. In addition, by separating the vertex declaration from
            	the list of vertex buffer bindings, it becomes possible to reuse bindings between declarations
            	and vice versa, giving opportunities to reduce the state changes required to perform rendering.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.VertexBufferBinding.bindingMap">
            <summary>
            	Defines the vertex buffer bindings used as source for vertex declarations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexBufferBinding.highIndex">
            <summary>
            	The highest index in use for this binding.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.SetBinding(System.Int16,Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
            	Set a binding, associating a vertex buffer with a given index.
            </summary>
            <remarks>
            	If the index is already associated with a vertex buffer,
            	the association will be replaced. This may cause the old buffer
            	to be destroyed if nothing else is referring to it.
            	You should assign bindings from 0 and not leave gaps, although you can
            	bind them in any order.
            </remarks>
            <param name="index">Index at which to bind the buffer.</param>
            <param name="buffer">Vertex buffer to bind.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.UnsetBinding(System.Int16)">
            <summary>
            	Removes an existing binding.
            </summary>
            <param name="index">Index of the buffer binding to remove.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.UnsetAllBindings">
            <summary>
            	Removes all current buffer bindings.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.GetBuffer(System.Int16)">
            <summary>
            	Gets the buffer bound to the given source index.
            </summary>
            <param name="index">Index of the binding to retreive the buffer for.</param>
            <returns>Buffer at the specified index.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="P:Axiom.Graphics.VertexBufferBinding.Bindings">
            <summary>
            	Gets an enumerator to iterate through the buffer bindings.
            </summary>
            TODO: Change this to strongly typed later on
        </member>
        <member name="P:Axiom.Graphics.VertexBufferBinding.BindingCount">
            <summary>
            	Gets the number of bindings.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexBufferBinding.NextIndex">
            <summary>
            	Gets the highest index which has already been set, plus 1.
            </summary>
            <remarks>
            	This is to assist in binding the vertex buffers such that there are
            	not gaps in the list.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.RenderSystem">
            <summary>
            Defines the functionality of a 3D API
            </summary>
            <remarks>
            The RenderSystem class provides a base class
            which abstracts the general functionality of the 3D API
            e.g. Direct3D or OpenGL. Whilst a few of the general
            methods have implementations, most of this class is
            abstract, requiring a subclass based on a specific API
            to be constructed to provide the full functionality.
            <p/>
            Note there are 2 levels to the interface - one which
            will be used often by the caller of the engine library,
            and one which is at a lower level and will be used by the
            other classes provided by the engine. These lower level
            methods are marked as internal, and are not accessible outside
            of the Core library.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.DefaultWindowTitle">
            <summary>
            Default window title if one is not specified upon a call to <see cref="M:Axiom.Graphics.RenderSystem.Initialize(System.Boolean,System.String)"/>.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.prioritizedRenderTargets">
            <summary>
            List of current render targets (i.e. a <see cref="T:Axiom.Graphics.RenderWindow"/>, or a<see cref="T:Axiom.Graphics.RenderTexture"/>) by priority
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.renderTargets">
            <summary>
            List of current render targets (i.e. a <see cref="T:Axiom.Graphics.RenderWindow"/>, or a<see cref="T:Axiom.Graphics.RenderTexture"/>)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.textureManager">
            <summary>
            A reference to the texture management class specific to this implementation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.activeRenderTarget">
            <summary>
            Active render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.realCapabilities">
            <summary>
            Capabilites of the current hardware (populated at startup).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.manualBlendColors">
            <summary>
            Saved manual color blends
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.#ctor">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.FireEvent(System.String,Axiom.Collections.NameValuePairList)">
            <summary>
            Internal method for firing a rendersystem event
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.PreExtraThreadsStarted">
            <summary>
            Tell the rendersystem to perform any prep tasks it needs to directly
            before other threads which might access the rendering API are registered.
            </summary>
            <remarks>
            Call this from your main thread before starting your other threads
            (which themselves should call registerThread()). Note that if you
            start your own threads, there is a specific startup sequence which 
            must be respected and requires synchronisation between the threads:
            <ol>
            <li>[Main thread]Call <see cref="M:Axiom.Graphics.RenderSystem.PreExtraThreadsStarted"/></li>
            <li>[Main thread]Start other thread, wait</li>
            <li>[Other thread]Call <see cref="M:Axiom.Graphics.RenderSystem.RegisterThread"/>, notify main thread &amp; continue</li>
            <li>[Main thread]Wake up &amp; call <see cref="M:Axiom.Graphics.RenderSystem.PostExtraThreadsStarted"/></li>
            </ol>
            Once this init sequence is completed the threads are independent but
            this startup sequence must be respected.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.PostExtraThreadsStarted">
            <summary>
            Tell the rendersystem to perform any tasks it needs to directly
            after other threads which might access the rendering API are registered.
            <see cref="M:Axiom.Graphics.RenderSystem.PreExtraThreadsStarted"/>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.RegisterThread">
            <summary>
            Register the an additional thread which may make calls to rendersystem-related objects.
            </summary>
            <remarks>
            This method should only be called by additional threads during their
            initialisation. If they intend to use hardware rendering system resources 
            they should call this method before doing anything related to the render system.
            Some rendering APIs require a per-thread setup and this method will sort that
            out. It is also necessary to call unregisterThread before the thread shuts down.
            </remarks>
            <note>
            This method takes no parameters - it must be called from the thread being
            registered and that context is enough.
            </note>        
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UnregisterThread">
            <summary>
            Unregister an additional thread which may make calls to rendersystem-related objects.
            <see cref="M:Axiom.Graphics.RenderSystem.RegisterThread"/>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UseCustomRenderSystemCapabilities(Axiom.Graphics.RenderSystemCapabilities)">
            <summary>
            Force the render system to use the special capabilities. Can only be called
            before the render system has been fully initializer (before createWindow is called) 
            </summary>
            <param name="capabilities">
            capabilities has to be a subset of the real capabilities and the caller is 
            responsible for deallocating capabilities.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetDepthBufferFor(Axiom.Graphics.RenderTarget)">
            <summary>
            Retrieves an existing DepthBuffer or creates a new one suited for the given RenderTarget and sets it.
            </summary>
            <remarks>
            RenderTarget's pool ID is respected. <see name="RenderTarget.DepthBufferPool"/>
            </remarks>
            <param name="renderTarget"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetDepthBias(System.Single,System.Single)">
            <summary>
            Sets the depth bias, NB you should use the Material version of this.
            </summary>
            <param name="constantBias"></param>
            <param name="slopeScaleBias"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetDerivedDepthBias(System.Boolean,System.Single,System.Single,System.Single)">
            <summary>
            Tell the render system whether to derive a depth bias on its own based on 
            the values passed to it in setCurrentPassIterationCount.
            The depth bias set will be baseValue + iteration * multiplier
            </summary>
            <param name="derive">true to tell the RS to derive this automatically</param>
            <param name="baseValue">The base value to which the multiplier should be added</param>
            <param name="multiplier">The amount of depth bias to apply per iteration</param>
            <param name="slopeScale">The constant slope scale bias for completeness</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ValidateConfigOptions">
            <summary>
            Validates the configuration of the rendering system
            </summary>
            <remarks>Calling this method can cause the rendering system to modify the ConfigOptions collection.</remarks>
            <returns>Error message is configuration is invalid <see cref="F:System.String.Empty"/> if valid.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.AttachRenderTarget(Axiom.Graphics.RenderTarget)">
            <summary>
            Attaches a render target to this render system.
            </summary>
            <param name="target">Reference to the render target to attach to this render system.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BeginGeometryCount">
            <summary>
            The RenderSystem will keep a count of tris rendered, this resets the count.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DetachRenderTarget(System.String)">
            <summary>
            Detaches the render target from this render system.
            </summary>
            <param name="name">Name of the render target to detach.</param>
            <returns>the render target that was detached</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.GetErrorDescription(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DisableTextureUnit(System.Int32)">
            <summary>
            Turns off a texture unit if not needed.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DisableTextureUnitsFrom(System.Int32)">
            <summary>
            Disables all texture units from the given unit upwards
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.InitRenderTargets">
            <summary>
            Utility method for initializing all render targets attached to this rendering system.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.AddClipPlane(Axiom.Math.Plane)">
            <summary>
            Add a user clipping plane.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.AddClipPlane(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Add a user clipping plane.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ResetClipPlanes">
            <summary>
            Clears the user clipping region.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.NotifyCameraRemoved(Axiom.Core.Camera)">
            <summary>
            Utility method to notify all render targets that a camera has been removed, 
            incase they were referring to it as their viewer. 
            </summary>
            <param name="camera">Camera being removed.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetClipPlanesImpl(Axiom.Math.Collections.PlaneList)">
            <summary>
            Internal method used to set the underlying clip planes when needed
            </summary>
            <param name="clipPlanes"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Render(Axiom.Graphics.RenderOperation)">
            <summary>
            Render something to the active viewport.
            </summary>
            <remarks>
            Low-level rendering interface to perform rendering
            operations. Unlikely to be used directly by client
            applications, since the <see cref="T:Axiom.Core.SceneManager"/> and various support
            classes will be responsible for calling this method.
            Can only be called between BeginScene and EndScene
            </remarks>
            <param name="op">
            A rendering operation instance, which contains details of the operation to be performed.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UpdatePassIterationRenderState">
            <summary>
            updates pass iteration rendering state including bound gpu program parameter pass iteration auto constant entry
            </summary>
            <returns>True if more iterations are required</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureUnitSettings(System.Int32,Axiom.Graphics.TextureUnitState)">
            <summary>
            Utility function for setting all the properties of a texture unit at once.
            This method is also worth using over the individual texture unit settings because it
            only sets those settings which are different from the current settings for this
            unit, thus minimising render state changes.
            </summary>
            <param name="texUnit"></param>
            <param name="tl"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetWorldMatrices(Axiom.Math.Matrix4[],System.UInt16)">
            <summary>
            Sets multiple world matrices (vertex blending).
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Shutdown">
            <summary>
            Shuts down the RenderSystem.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UpdateAllRenderTargets(System.Boolean)">
            <summary>
            Internal method for updating all render targets attached to this rendering system.
            </summary>
            <param name="swapBuffers"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SwapAllRenderTargetBuffers(System.Boolean)">
            <summary>
            Internal method for swapping all the buffers on all render targets,
            if <see cref="M:Axiom.Graphics.RenderSystem.UpdateAllRenderTargets(System.Boolean)"/> was called with a 'false' parameter.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.GetRenderTarget(System.String)">
            <summary>
            Returns a pointer to the render target with the passed name, or null if that
            render target cannot be found.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ApplyObliqueDepthProjection(Axiom.Math.Matrix4@,Axiom.Math.Plane,System.Boolean)">
            <summary>
            Update a perspective projection matrix to use 'oblique depth projection'.
            </summary>
            <remarks>
            This method can be used to change the nature of a perspective 
            transform in order to make the near plane not perpendicular to the 
            camera view direction, but to be at some different orientation. 
            This can be useful for performing arbitrary clipping (e.g. to a 
            reflection plane) which could otherwise only be done using user
            clip planes, which are more expensive, and not necessarily supported
            on all cards.
            </remarks>
            <param name="projMatrix">
            The existing projection matrix. Note that this must be a
            perspective transform (not orthographic), and must not have already
            been altered by this method. The matrix will be altered in-place.
            </param>
            <param name="plane">
            The plane which is to be used as the clipping plane. This
            plane must be in CAMERA (view) space.
            </param>
            <param name="forGpuProgram">Is this for use with a Gpu program or fixed-function transforms?</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BeginFrame">
            <summary>
            Signifies the beginning of a frame, ie the start of rendering on a single viewport. Will occur
            several times per complete frame if multiple viewports exist.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.PauseFrame">
            <summary>
            Pause rendering for a frame. This has to be called after 
            <see cref="M:Axiom.Graphics.RenderSystem.BeginFrame"/> and before <see cref="M:Axiom.Graphics.RenderSystem.EndFrame"/>.
            will usually be called by the SceneManager, don't use this manually unless you know what
            you are doing.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ResumeFrame(Axiom.Graphics.RenderSystem.RenderSystemContext)">
            <summary>
            Resume rendering for a frame. This has to be called after a <see cref="M:Axiom.Graphics.RenderSystem.PauseFrame"/> call
            Will usually be called by the SceneManager, don't use this manually unless you know what
            you are doing.
            </summary>
            <param name="context">the render system context, as returned by <see cref="M:Axiom.Graphics.RenderSystem.PauseFrame"/></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BindGpuProgram(Axiom.Graphics.GpuProgram)">
            <summary>
            Binds a given GpuProgram (but not the parameters). 
            </summary>
            <remarks>
            Only one GpuProgram of each type can be bound at once, binding another
            one will simply replace the existing one.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BindGpuProgramParameters(Axiom.Graphics.GpuProgramType,Axiom.Graphics.GpuProgramParameters,Axiom.Graphics.GpuProgramParameters.GpuParamVariability)">
            <summary>
            Bind Gpu program parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BindGpuProgramPassIterationParameters(Axiom.Graphics.GpuProgramType)">
            <summary>
            Only binds Gpu program parameters used for passes that have more than one iteration rendering
            </summary>
            <param name="gptype"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ClearFrameBuffer(Axiom.Graphics.FrameBufferType,Axiom.Core.ColorEx,Axiom.Math.Real,System.UInt16)">
            <summary>
            Clears one or more frame buffers on the active render target.
            </summary>
            <param name="buffers">
             Combination of one or more elements of <see cref="T:Axiom.Graphics.RenderTarget.FrameBuffer"/>
             denoting which buffers are to be cleared.
            </param>
            <param name="color">The color to clear the color buffer with, if enabled.</param>
            <param name="depth">The value to initialize the depth buffer with, if enabled.</param>
            <param name="stencil">The value to initialize the stencil buffer with, if enabled.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ConvertColor(Axiom.Core.ColorEx)">
            <summary>
            Converts the Axiom.Core.ColorEx value to a int.  Each API may need the 
            bytes of the packed color data in different orders. i.e. OpenGL - ABGR, D3D - ARGB
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)">
            <summary>
            Creates a new render window.
            </summary>
            <remarks>
            This method creates a new rendering window as specified
            by the paramteters. The rendering system could be
            responible for only a single window (e.g. in the case
            of a game), or could be in charge of multiple ones (in the
            case of a level editor). The option to create the window
            as a child of another is therefore given.
            This method will create an appropriate subclass of
            RenderWindow depending on the API and platform implementation.
            </remarks>
            <param name="name"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="isFullScreen"></param>
            <param name="miscParams">
            A collection of addition rendersystem specific options.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateRenderWindows(Axiom.Graphics.RenderWindowDescriptionList,Axiom.Graphics.RenderWindowList)">
            <summary>
            Creates multiple rendering windows.
            </summary>
            <param name="renderWindowDescriptions">
            Array of structures containing the descriptions of each render window.
            The structure's members are the same as the parameters of CreateRenderWindow:
            <see cref="M:Axiom.Graphics.RenderSystem.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)"/>
            </param>
            <param name="createdWindows">This array will hold the created render windows.</param>
            <returns>true on success.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateMultiRenderTarget(System.String)">
            <summary>
            Create a MultiRenderTarget, which is a render target that renders to multiple RenderTextures at once.
            </summary>
            <Remarks>
            Surfaces can be bound and unbound at will. This fails if Capabilities.MultiRenderTargetsCount is smaller than 2.
            </Remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateHardwareOcclusionQuery">
            <summary>
            Requests an API implementation of a hardware occlusion query used to test for the number
            of fragments rendered between calls to <see cref="M:Axiom.Graphics.HardwareOcclusionQuery.Begin"/> and 
            <see cref="M:Axiom.Graphics.HardwareOcclusionQuery.End"/> that pass the depth buffer test.
            </summary>
            <returns>An API specific implementation of an occlusion query.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DestroyHardwareOcclusionQuery(Axiom.Graphics.HardwareOcclusionQuery)">
            <summary>
            Destroy a hardware occlusion query object. 
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.EndFrame">
            <summary>
            Ends rendering of a frame to the current viewport.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Initialize(System.Boolean,System.String)">
            <summary>
            Initialize the rendering engine.
            </summary>
            <param name="autoCreateWindow">If true, a default window is created to serve as a rendering target.</param>
            <param name="windowTitle">Text to display on the window caption if not fullscreen.</param>
            <returns>A RenderWindow implementation specific to this RenderSystem.</returns>
            <remarks>All subclasses should call this method from within thier own intialize methods.</remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Reinitialize">
            <summary>
            Reinitializes the Render System
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateRenderSystemCapabilities">
            <summary>
            Query the real capabilities of the GPU and driver in the RenderSystem
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeOrthoMatrix(Axiom.Math.Radian,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Matrix4@,System.Boolean)">
            <summary>
            Builds an orthographic projection matrix suitable for this render system.
            </summary>
            <remarks>
            Because different APIs have different requirements (some incompatible) for the
            projection matrix, this method allows each to implement their own correctly and pass
            back a generic Matrix4 for storage in the engine.
            </remarks>
            <param name="fov">Field of view angle.</param>
            <param name="aspectRatio">Aspect ratio.</param>
            <param name="near">Near clipping plane distance.</param>
            <param name="far">Far clipping plane distance.</param>
            <param name="dest"></param>
            <param name="forGpuPrograms"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ConvertProjectionMatrix(Axiom.Math.Matrix4,Axiom.Math.Matrix4@,System.Boolean)">
            <summary>
            Converts a uniform projection matrix to one suitable for this render system.
            </summary>
            <remarks>
            Because different APIs have different requirements (some incompatible) for the
            projection matrix, this method allows each to implement their own correctly and pass
            back a generic Matrix4 for storage in the engine.
            </remarks>
            <param name="matrix"></param>
            <param name="dest"></param>
            <param name="forGpuProgram"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeProjectionMatrix(Axiom.Math.Radian,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Matrix4@,System.Boolean)">
            <summary>
            Builds a perspective projection matrix suitable for this render system.
            </summary>
            <remarks>
            Because different APIs have different requirements (some incompatible) for the
            projection matrix, this method allows each to implement their own correctly and pass
            back a generic Matrix4 for storage in the engine.
            </remarks>
            <param name="fov">Field of view angle.</param>
            <param name="aspectRatio">Aspect ratio.</param>
            <param name="near">Near clipping plane distance.</param>
            <param name="far">Far clipping plane distance.</param>
            <param name="dest"></param>
            <param name="forGpuProgram"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeProjectionMatrix(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Matrix4@,System.Boolean)">
            <summary>
            Builds a perspective projection matrix for the case when frustum is
            not centered around camera.
            </summary>
            <remarks>
            Viewport coordinates are in camera coordinate frame, i.e. camera is 
            at the origin.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetAlphaRejectSettings(Axiom.Graphics.CompareFunction,System.Byte,System.Boolean)">
            <summary>
             Sets the global alpha rejection approach for future renders.
            </summary>
            <param name="func">The comparison function which must pass for a pixel to be written.</param>
            <param name="value">The value to compare each pixels alpha value to (0-255)</param>
            <param name="alphaToCoverage">Whether to enable alpha to coverage, if supported</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateDepthBufferFor(Axiom.Graphics.RenderTarget)">
            <summary>
            Creates a DepthBuffer that can be attached to the specified RenderTarget
            </summary>
            <remarks>
            It doesn't attach anything, it just returns a pointer to a new DepthBuffer
            Caller is responsible for putting this buffer into the right pool, for
            attaching, and deleting it. Here's where API-specific magic happens.
            Don't call this directly unless you know what you're doing.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CleanupDepthBuffers(System.Boolean)">
            <summary>
            Removes all depth buffers. Should be called on device lost and shutdown
            </summary>
            <remarks>
            Advanced users can call this directly with bCleanManualBuffers=false to
            remove all depth buffers created for RTTs; when they think the pool has
            grown too big or they've used lots of depth buffers they don't need anymore,
            freeing GPU RAM.
            </remarks>
            <param name="bCleanManualBuffers"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetConfigOption(System.String,System.String)">
            <summary>
            Used to confirm the settings (normally chosen by the user) in
            order to make the renderer able to inialize with the settings as required.
            This make be video mode, D3D driver, full screen / windowed etc.
            Called automatically by the default configuration
            dialog, and by the restoration of saved settings.
            These settings are stored and only activeated when 
            RenderSystem::Initalize or RenderSystem::Reinitialize are called
            </summary>
            <param name="name">the name of the option to alter</param>
            <param name="value">the value to set the option to</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetColorBufferWriteEnabled(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets whether or not color buffer writing is enabled, and for which channels. 
            </summary>
            <remarks>
            For some advanced effects, you may wish to turn off the writing of certain color
            channels, or even all of the color channels so that only the depth buffer is updated
            in a rendering pass. However, the chances are that you really want to use this option
            through the Material class.
            </remarks>
            <param name="red">Writing enabled for red channel.</param>
            <param name="green">Writing enabled for green channel.</param>
            <param name="blue">Writing enabled for blue channel.</param>
            <param name="alpha">Writing enabled for alpha channel.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetDepthBufferParams(System.Boolean,System.Boolean,Axiom.Graphics.CompareFunction)">
            <summary>
            Sets the mode of operation for depth buffer tests from this point onwards.
            </summary>
            <remarks>
            Sometimes you may wish to alter the behavior of the depth buffer to achieve
            special effects. Because it's unlikely that you'll set these options for an entire frame,
            but rather use them to tweak settings between rendering objects, this is intended for internal
            uses, which will be used by a <see cref="T:Axiom.Core.SceneManager"/> implementation rather than directly from 
            the client application.
            </remarks>
            <param name="depthTest">
            If true, the depth buffer is tested for each pixel and the frame buffer is only updated
            if the depth function test succeeds. If false, no test is performed and pixels are always written.
            </param>
            <param name="depthWrite">
            If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds.
            If false, the depth buffer is left unchanged even if a new pixel is written.
            </param>
            <param name="depthFunction">Sets the function required for the depth test.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetFog(Axiom.Graphics.FogMode,Axiom.Core.ColorEx,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Sets the fog with the given params.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetSceneBlending(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendOperation)">
            <summary>
            Sets the global blending factors for combining subsequent renders with the existing frame contents.
            The result of the blending operation is:
            <p align="center">final = (texture * src) + (pixel * dest)</p>
            Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor
            enumerated type.
            </summary>
            <param name="src">The source factor in the above calculation, i.e. multiplied by the texture color components.</param>
            <param name="dest">The destination factor in the above calculation, i.e. multiplied by the pixel color components.</param>
            <param name="op">The blend operation mode for combining pixels</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetSeparateSceneBlending(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendOperation,Axiom.Graphics.SceneBlendOperation)">
            <summary>
            Sets the global blending factors for combining subsequent renders with the existing frame contents.
            The result of the blending operation is:
            final = (texture * sourceFactor) + (pixel * destFactor).
            Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor
            enumerated type.
            </summary>
            <param name="sourceFactor">The source factor in the above calculation, i.e. multiplied by the texture color components.</param>
            <param name="destFactor">The destination factor in the above calculation, i.e. multiplied by the pixel color components.</param>
            <param name="sourceFactorAlpha">The source factor in the above calculation for the alpha channel, i.e. multiplied by the texture alpha components.</param>
            <param name="destFactorAlpha">The destination factor in the above calculation for the alpha channel, i.e. multiplied by the pixel alpha components.</param>
            <param name="op">The blend operation mode for combining pixels</param>
            <param name="alphaOp">The blend operation mode for combining pixel alpha values</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetScissorTest(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the 'scissor region' ie the region of the target in which rendering can take place.
            </summary>
            <remarks>
            This method allows you to 'mask off' rendering in all but a given rectangular area
            as identified by the parameters to this method.
            <p/>
            Not all systems support this method. Check the <see cref="P:Axiom.Graphics.RenderSystem.Capabilities"/> enum for the
            ScissorTest capability to see if it is supported.
            </remarks>
            <param name="enable">True to enable the scissor test, false to disable it.</param>
            <param name="left">Left corner (in pixels).</param>
            <param name="top">Top corner (in pixels).</param>
            <param name="right">Right corner (in pixels).</param>
            <param name="bottom">Bottom corner (in pixels).</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetStencilBufferParams(Axiom.Graphics.CompareFunction,System.Int32,System.Int32,Axiom.Graphics.StencilOperation,Axiom.Graphics.StencilOperation,Axiom.Graphics.StencilOperation,System.Boolean)">
            <summary>
            This method allows you to set all the stencil buffer parameters in one call.
            </summary>
            <remarks>
            <para>
            The stencil buffer is used to mask out pixels in the render target, allowing
            you to do effects like mirrors, cut-outs, stencil shadows and more. Each of
            your batches of rendering is likely to ignore the stencil buffer, 
            update it with new values, or apply it to mask the output of the render.
            The stencil test is:<PRE>
            (Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask)</PRE>
            The result of this will cause one of 3 actions depending on whether the test fails,
            succeeds but with the depth buffer check still failing, or succeeds with the
            depth buffer check passing too.</para>
            <para>
            Unlike other render states, stencilling is left for the application to turn
            on and off when it requires. This is because you are likely to want to change
            parameters between batches of arbitrary objects and control the ordering yourself.
            In order to batch things this way, you'll want to use OGRE's separate render queue
            groups (see RenderQueue) and register a RenderQueueListener to get notifications
            between batches.</para>
            <para>
            There are individual state change methods for each of the parameters set using 
            this method. 
            Note that the default values in this method represent the defaults at system 
            start up too.</para>
            </remarks>
            <param name="function">The comparison function applied.</param>
            <param name="refValue">The reference value used in the comparison.</param>
            <param name="mask">
            The bitmask applied to both the stencil value and the reference value 
            before comparison.
            </param>
            <param name="stencilFailOp">The action to perform when the stencil check fails.</param>
            <param name="depthFailOp">
            The action to perform when the stencil check passes, but the depth buffer check still fails.
            </param>
            <param name="passOp">The action to take when both the stencil and depth check pass.</param>
            <param name="twoSidedOperation">
            If set to true, then if you render both back and front faces 
            (you'll have to turn off culling) then these parameters will apply for front faces, 
            and the inverse of them will happen for back faces (keep remains the same).
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetSurfaceParams(Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Math.Real,Axiom.Core.TrackVertexColor)">
            <summary>
            Sets the surface properties to be used for future rendering.
            
            This method sets the the properties of the surfaces of objects
            to be rendered after it. In this context these surface properties
            are the amount of each type of light the object reflects (determining
            it's color under different types of light), whether it emits light
            itself, and how shiny it is. Textures are not dealt with here,
            <see cref="M:Axiom.Graphics.RenderSystem.SetTexture(System.Int32,System.Boolean,Axiom.Core.Texture)"/> method for details.
            This method is used by SetMaterial so does not need to be called
            direct if that method is being used.
            </summary>
            <param name="ambient">
            The amount of ambient (sourceless and directionless)
            light an object reflects. Affected by the color/amount of ambient light in the scene.
            </param>
            <param name="diffuse">
            The amount of light from directed sources that is
            reflected (affected by color/amount of point, directed and spot light sources)
            </param>
            <param name="specular">
            The amount of specular light reflected. This is also
            affected by directed light sources but represents the color at the
            highlights of the object.
            </param>
            <param name="emissive">
            The color of light emitted from the object. Note that
            this will make an object seem brighter and not dependent on lights in
            the scene, but it will not act as a light, so will not illuminate other
            objects. Use a light attached to the same SceneNode as the object for this purpose.
            </param>
            <param name="shininess">
            A value which only has an effect on specular highlights (so
            specular must be non-black). The higher this value, the smaller and crisper the
            specular highlights will be, imitating a more highly polished surface.
            This value is not constrained to 0.0-1.0, in fact it is likely to
            be more (10.0 gives a modest sheen to an object).
            </param>
            <param name="tracking">
            A bit field that describes which of the ambient, diffuse, specular
            and emissive colors follow the vertex color of the primitive. When a bit in this field is set
            its colorValue is ignored. This is a combination of TVC_AMBIENT, TVC_DIFFUSE, TVC_SPECULAR(note that the shininess value is still
            taken from shininess) and TVC_EMISSIVE. TVC_NONE means that there will be no material property
            tracking the vertex colors.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetPointParameters(Axiom.Math.Real,System.Boolean,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real)">
            <summary>
            Sets the size of points and how they are attenuated with distance.
            <remarks>
            When performing point rendering or point sprite rendering,
            point size can be attenuated with distance. The equation for
            doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2) .
            </remarks>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTexture(System.Int32,System.Boolean,System.String)">
            <summary>
            Sets the details of a texture stage, to be used for all primitives
            rendered afterwards. User processes would
            not normally call this direct unless rendering
            primitives themselves - the SubEntity class
            is designed to manage materials for objects.
            Note that this method is called by SetMaterial.
            </summary>
            <param name="unit">The index of the texture unit to modify. Multitexturing hardware 
            can support multiple units (see TextureUnitCount)</param>
            <param name="enabled">Boolean to turn the unit on/off</param>
            <param name="textureName">
            The name of the texture to use - this should have
            already been loaded with TextureManager.Load.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTexture(System.Int32,System.Boolean,Axiom.Core.Texture)">
            <summary>
            Sets the texture to bind to a given texture unit.
            
            User processes would not normally call this direct unless rendering
            primitives themselves.
            </summary>
            <param name="unit">
            The index of the texture unit to modify. Multitexturing
            hardware can support multiple units <see cref="P:Axiom.Graphics.RenderSystemCapabilities.TextureUnitCount"/> 
            </param>
            <param name="enabled"></param>
            <param name="texture"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetVertexTexture(System.Int32,Axiom.Core.Texture)">
            <summary>
            Binds a texture to a vertex sampler.
            </summary>
            <remarks>
            Not all rendersystems support separate vertex samplers. For those that
            do, you can set a texture for them, separate to the regular texture
            samplers, using this method. For those that don't, you should use the
            regular texture samplers which are shared between the vertex and
            fragment units; calling this method will throw an exception.
            <see cref="P:Axiom.Graphics.RenderSystemCapabilities.VertexTextureUnitsShared"/>
            </remarks>
            <param name="unit"></param>
            <param name="texture"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureAddressingMode(System.Int32,Axiom.Graphics.UVWAddressing)">
            <summary>
            Tells the hardware how to treat texture coordinates.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureMipmapBias(System.Int32,System.Single)">
            <summary>
            Sets the mipmap bias value for a given texture unit.
            </summary>
            <remarks>
            This allows you to adjust the mipmap calculation up or down for a
            given texture unit. Negative values force a larger mipmap to be used, 
            positive values force a smaller mipmap to be used. Units are in numbers
            of levels, so +1 forces the mipmaps to one smaller level.
            </remarks>
            <note>Only does something if render system has capability RSC_MIPMAP_LOD_BIAS.</note>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureBorderColor(System.Int32,Axiom.Core.ColorEx)">
            <summary>
            Tells the hardware what border color to use when texture addressing mode is set to Border
            </summary>
            <param name="unit"></param>
            <param name="borderColor"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureBlendMode(System.Int32,Axiom.Graphics.LayerBlendModeEx)">
            <summary>
            Sets the texture blend modes from a TextureLayer record.
            Meant for use internally only - apps should use the Material
            and TextureLayer classes.
            </summary>
            <param name="unit">Texture unit.</param>
            <param name="bm">Details of the blending modes.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureCoordCalculation(System.Int32,Axiom.Graphics.TexCoordCalcMethod,Axiom.Core.Frustum)">
            <summary>
            Sets a method for automatically calculating texture coordinates for a stage.
            </summary>
            <param name="unit">Texture stage to modify.</param>
            <param name="method">Calculation method to use</param>
            <param name="frustum">Frustum, only used for projective effects</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureCoordSet(System.Int32,System.Int32)">
            <summary>
            Sets the index into the set of tex coords that will be currently used by the render system.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureLayerAnisotropy(System.Int32,System.Int32)">
            <summary>
            Sets the maximal anisotropy for the specified texture unit.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureMatrix(System.Int32,Axiom.Math.Matrix4)">
            <summary>
            Sets the texture matrix for the specified stage.  Used to apply rotations, translations,
            and scaling to textures.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureUnitFiltering(System.Int32,Axiom.Graphics.FilterType,Axiom.Graphics.FilterOptions)">
            <summary>
            Sets a single filter for a given texture unit.
            </summary>
            <param name="unit">The texture unit to set the filtering options for.</param>
            <param name="type">The filter type.</param>
            <param name="filter">The filter to be used.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureUnitFiltering(System.Int32,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions)">
            <summary>
            Sets the filtering options for a given texture unit.
            </summary>
            <param name="unit">The texture unit to set the filtering options for.</param>
            <param name="minFilter">The filter used when a texture is reduced in size.</param>
            <param name="magFilter">The filter used when a texture is magnified.</param>
            <param name="mipFilter">
            The filter used between mipmap levels, <see cref="F:Axiom.Graphics.FilterOptions.None"/> disables mipmapping.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UnbindGpuProgram(Axiom.Graphics.GpuProgramType)">
            <summary>
            Unbinds the current GpuProgram of a given GpuProgramType.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.IsGpuProgramBound(Axiom.Graphics.GpuProgramType)">
            <summary>
            Gets the bound status of a given GpuProgramType.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UseLights(Axiom.Core.Collections.LightList,System.Int32)">
            <summary>
            Tells the rendersystem to use the attached set of lights (and no others) 
            up to the number specified (this allows the same list to be used with different
            count limits).
            </summary>
            <param name="lightList">List of lights.</param>
            <param name="limit">Max number of lights that can be used from the list currently.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DestroyRenderTarget(System.String)">
            <summary>
            Destroys a render target of any sort
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DestroyRenderWindow(System.String)">
            <summary>
            Destroys a render window
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DestroyRenderTexture(System.String)">
            <summary>
            Destroys a render texture
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.InitializeFromRenderSystemCapabilities(Axiom.Graphics.RenderSystemCapabilities,Axiom.Graphics.RenderTarget)">
            <summary>
            Initialize the render system from the capabilities
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ToString">
            <summary>
            Returns the name of this RenderSystem.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.dispose(System.Boolean)">
            <summary>
            Class level dispose method
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.RenderTarget">
            <summary>
            Set current render target to target, enabling its device context if needed
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.WaitForVerticalBlank">
            <summary>
            Defines whether or now fullscreen render windows wait for the vertical blank before flipping buffers.
            </summary>
            <remarks>
            By default, all rendering windows wait for a vertical blank (when the CRT beam turns off briefly to move
            from the bottom right of the screen back to the top left) before flipping the screen buffers. This ensures
            that the image you see on the screen is steady. However it restricts the frame rate to the refresh rate of
            the monitor, and can slow the frame rate down. You can speed this up by not waiting for the blank, but
            this has the downside of introducing 'tearing' artefacts where part of the previous frame is still displayed
            as the buffers are switched. Speed vs quality, you choose.
            </remarks>
            <note>
            Has NO effect on windowed mode render targets. Only affects fullscreen mode.
            </note>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.GlobalInstanceVertexBuffer">
            <summary>
            a global vertex buffer for global instancing
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.GlobalInstanceVertexBufferVertexDeclaration">
            <summary>
            a vertex declaration for the global vertex buffer for the global instancing
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.GlobalNumberOfInstances">
            <summary>
            the number of global instances (this number will be multiply by the render op instance number) 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.AreFixedFunctionLightsInViewSpace">
            <summary>
            Are fixed-function lights provided in view space? Affects optimisation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.PointSpritesEnabled">
            <summary>
            Sets whether or not rendering points using OT_POINT_LIST will 
            render point sprites (textured quads) or plain points.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.MutableCapabilities">
            <summary>
            Gets a set of hardware capabilities queryed by the current render system.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.Capabilities">
            <summary>
             Gets the capabilities of the render system
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.Viewport">
            <summary>
            Get or set the current active viewport for rendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.CullingMode">
            <summary>
            Gets/Sets the culling mode for the render system based on the 'vertex winding'.
            </summary>
            <remarks>
            A typical way for the rendering engine to cull triangles is based on the
            'vertex winding' of triangles. Vertex winding refers to the direction in
            which the vertices are passed or indexed to in the rendering operation as viewed
            from the camera, and will wither be clockwise or counterclockwise.  The default is <see name="CullingMode.Clockwise"/>  
            i.e. that only triangles whose vertices are passed/indexed in counterclockwise order are rendered - this 
            is a common approach and is used in 3D studio models for example. You can alter this culling mode 
            if you wish but it is not advised unless you know what you are doing. You may wish to use the 
            <see cref="F:Axiom.Graphics.CullingMode.None"/> option for mesh data that you cull yourself where the vertex winding is uncertain.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthBufferCheckEnabled">
            <summary>
            Sets whether or not the depth buffer check is performed before a pixel write
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthBufferWriteEnabled">
            <summary>
            Sets whether or not the depth buffer is updated after a pixel write.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthBufferFunction">
            <summary>
            Sets the comparison function for the depth buffer check.
            Advanced use only - allows you to choose the function applied to compare the depth values of
            new and existing pixels in the depth buffer. Only an issue if the depth buffer check is enabled
            <see cref="P:Axiom.Graphics.RenderSystem.DepthBufferCheckEnabled"/>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DriverVersion">
            <summary>
             Returns the driver version.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DefaultViewportMaterialScheme">
            <summary>
             Returns the driver version.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ClipPlanes">
            <summary>
             Returns the driver version.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ConfigOptions">
            <summary>
            Gets a dataset with the options set for the rendering system.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.FaceCount">
            <summary>
            Number of faces rendered during the current frame so far.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.BatchCount">
            <summary>
            Number of batches rendered during the current frame so far.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.VertexCount">
            <summary>
            Number of vertices processed during the current frame so far.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ColorVertexElementType">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.VertexDeclaration">
            <summary>
            Sets the current vertex declaration, ie the source of vertex data.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.VertexBufferBinding">
            <summary>
            Sets the current vertex buffer binding state.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.CurrentPassIterationCount">
            <summary>
            Number of times to render the current state.
            </summary>
            <remarks>Set the current multi pass count value.  This must be set prior to 
            calling render() if multiple renderings of the same pass state are 
            required.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.InvertVertexWinding">
            <summary>
            Sets whether or not vertex windings set should be inverted; this can be important
            for rendering reflections.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.Name">
            <summary>
            Gets the name of this RenderSystem based on it's assembly attribute Title.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DisplayMonitorCount">
            <summary>
            Gets the number of display monitors. <see name="Root.DisplayMonitorCount"/>
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.AmbientLight">
            <summary>
            Sets the color &amp; strength of the ambient (global directionless) light in the world.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.HorizontalTexelOffset">
            <summary>
            Returns the horizontal texel offset value required for mapping 
            texel origins to pixel origins in this rendersystem.
            </summary>
            <remarks>
            Since rendersystems sometimes disagree on the origin of a texel, 
            mapping from texels to pixels can sometimes be problematic to 
            implement generically. This method allows you to retrieve the offset
            required to map the origin of a texel to the origin of a pixel in
            the horizontal direction.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.LightingEnabled">
            <summary>
            Gets/Sets whether or not dynamic lighting is enabled.
            <p/>
            If true, dynamic lighting is performed on geometry with normals supplied, geometry without
            normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.NormalizeNormals">
            <summary>
            Get/Sets whether or not normals are to be automatically normalized.
            </summary>
            <remarks>
            This is useful when, for example, you are scaling SceneNodes such that
            normals may not be unit-length anymore. Note though that this has an
            overhead so should not be turn on unless you really need it.
            <p/>
            You should not normally call this direct unless you are rendering
            world geometry; set it on the Renderable because otherwise it will be
            overridden by material settings. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ProjectionMatrix">
            <summary>
            Gets/Sets the current projection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.PolygonMode">
            <summary>
            Gets/Sets how to rasterise triangles, as points, wireframe or solid polys.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.StencilCheckEnabled">
            <summary>
            Turns stencil buffer checking on or off. 
            </summary>
            <remarks>
            Stencilling (masking off areas of the rendering target based on the stencil 
            buffer) can be turned on or off using this method. By default, stencilling is
            disabled.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.VerticalTexelOffset">
            <summary>
            Returns the vertical texel offset value required for mapping 
            texel origins to pixel origins in this rendersystem.
            </summary>
            <remarks>
            Since rendersystems sometimes disagree on the origin of a texel, 
            mapping from texels to pixels can sometimes be problematic to 
            implement generically. This method allows you to retrieve the offset
            required to map the origin of a texel to the origin of a pixel in
            the vertical direction.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ViewMatrix">
            <summary>
            Gets/Sets the current view matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.WorldMatrix">
            <summary>
            Sets the current world matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.MinimumDepthInputValue">
            <summary>
            Gets the maximum (closest) depth value to be used when rendering using identity transforms.
            </summary>
            <remarks>
            When using identity transforms you can manually set the depth
            of a vertex; however the input values required differ per
            rendersystem. This method lets you retrieve the correct value.
            <see cref="P:Axiom.Graphics.SimpleRenderable.UseIdentityView"/>
            <see cref="P:Axiom.Graphics.SimpleRenderable.UseIdentityProjection"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.MaximumDepthInputValue">
            <summary>
            Gets the maximum (farthest) depth value to be used when rendering using identity transforms.
            </summary>
            <remarks>
            When using identity transforms you can manually set the depth
            of a vertex; however the input values required differ per
            rendersystem. This method lets you retrieve the correct value.
            <see cref="P:Axiom.Graphics.SimpleRenderable.UseIdentityView"/>
            <see cref="P:Axiom.Graphics.SimpleRenderable.UseIdentityProjection"/>
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.RenderSystem.RenderSystemContext">
            <summary>
            Dummy structure for render system contexts - implementing RenderSystems can extend
            as needed
            </summary>
        </member>
        <member name="T:Axiom.Core.ObjectTextDisplay">
            <summary>
            Attaches a label to a <see cref="T:Axiom.Core.MovableObject"/>
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.NodeRotationControllerValue">
            <summary>
            Summary description for NodeRotationControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.UnifiedHighLevelGpuProgram">
            <summary>
            Specialization of HighLevelGpuProgram which just delegates its implementation
            to one other high level program, allowing a single program definition
            to represent one supported program from a number of options
            </summary>
            <remarks>
            Whilst you can use Technique to implement several ways to render an object
            depending on hardware support, if the only reason to need multiple paths is
            because of the high-level shader language supported, this can be 
            cumbersome. For example you might want to implement the same shader 
            in HLSL and	GLSL for portability but apart from the implementation detail,
            the shaders do the same thing and take the same parameters. If the materials
            in question are complex, duplicating the techniques just to switch language
            is not optimal, so instead you can define high-level programs with a 
            syntax of 'unified', and list the actual implementations in order of
            preference via repeated use of the 'delegate' parameter, which just points
            at another program name. The first one which has a supported syntax
            will be used.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.UnifiedHighLevelGpuProgram.chooseDelegate">
            Choose the delegate to use
        </member>
        <member name="M:Axiom.Graphics.UnifiedHighLevelGpuProgram.AddDelegateProgram(System.String)">
            <summary>
            Adds a new delegate program to the list.
            </summary>
            <remarks>
            Delegates are tested in order so earlier ones are preferred.
            </remarks>
            <param name="delegateName"></param>
        </member>
        <member name="M:Axiom.Graphics.UnifiedHighLevelGpuProgram.ClearDelegatePrograms">
            <summary>
            Remove all delegate programs
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IQueuedRenderableVisitor">
            <summary>
            Visitor interface for items in a QueuedRenderableCollection.
            </summary>
            <remarks>
            Those wishing to iterate over the items in a 
            QueuedRenderableCollection should implement this visitor pattern,
            since internal organization of the collection depends on the 
            sorting method in use.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IQueuedRenderableVisitor.Visit(Axiom.Graphics.RenderablePass)">
            <summary>
            Called when visiting a RenderablePass, ie items in a
            sorted collection where items are not grouped by pass.
            </summary>
            <remarks>
            If this is called, neither of the other 2 visit methods	will be called.
            </remarks>
            <param name="renderablePass"></param>
        </member>
        <member name="M:Axiom.Graphics.IQueuedRenderableVisitor.Visit(Axiom.Graphics.Pass)">
            <summary>
            When visiting a collection grouped by pass, this is	called when the grouping pass changes.
            </summary>
            <remarks>
            If this method is called, the RenderablePass visit 
            method will not be called for this collection. The 
            Renderable visit method will be called for each item
            underneath the pass grouping level.
            </remarks>
            <param name="pass"></param>
            <returns>True to continue, false to skip the Renderables underneath</returns>
        </member>
        <member name="M:Axiom.Graphics.IQueuedRenderableVisitor.Visit(Axiom.Graphics.IRenderable)">
            <summary>
            Visit method called once per Renderable on a grouped collection.
            </summary>
            <remarks>
            If this method is called, the RenderablePass visit 
            method will not be called for this collection.
            </remarks>
            <param name="renderable"></param>
        </member>
        <member name="T:Axiom.Graphics.QueuedRenderableCollection">
            <summary>Lowest level collection of renderables.</summary>
            <remarks>
            To iterate over items in this collection, you must call
            the accept method and supply a <see cref="T:Axiom.Graphics.IQueuedRenderableVisitor"/>,
            the order of the iteration, and whether that iteration is
            over a <see cref="T:Axiom.Graphics.RenderablePass"/> list or a 2-level grouped list which 
            causes a visit call at the <see cref="T:Axiom.Graphics.Pass"/> level, and a call for each
            <see cref="T:Axiom.Graphics.IRenderable"/> underneath.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection._radixSorter1">
            Radix sorter for accessing sort value 1 (Pass)
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection._radixSorter2">
            Radix sorter for sort value 2 (distance)
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection._organizationMode">
            Bitmask of the organization modes requested
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection._grouped">
            Grouped 
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection._sortedDescending">
            Sorted descending (can iterate backwards to get ascending)
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.Clear">
            <summary>
            Empty the collection
            </summary>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.RemovePassGroup(Axiom.Graphics.Pass)">
            <summary>
            Remove the group entry (if any) for a given Pass.
            </summary>
            <remarks>
            To be used when a pass is destroyed, such that any
            grouping level for it becomes useless.
            </remarks>
            <param name="pass"></param>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.ResetOrganizationModes">
            <summary>
            Reset the organisation modes required for this collection.
            </summary>
            <remarks>
            You can only do this when the collection is empty.
            </remarks>
            <see cref="T:Axiom.Graphics.QueuedRenderableCollection.OrganizationMode"/>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.AddOrganizationMode(Axiom.Graphics.QueuedRenderableCollection.OrganizationMode)">
            <summary>
            Add a required sorting / grouping mode to this collection when next used.
            </summary>
            <remarks>
            You can only do this when the collection is empty.
            </remarks>
            <see cref="T:Axiom.Graphics.QueuedRenderableCollection.OrganizationMode"/>
            <param name="om"></param>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.AddRenderable(Axiom.Graphics.Pass,Axiom.Graphics.IRenderable)">
            <summary>
            Add a renderable to the collection using a given pass
            </summary>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.Sort(Axiom.Core.Camera)">
            <summary>
            Perform any sorting that is required on this collection.
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.AcceptVisitor(Axiom.Graphics.IQueuedRenderableVisitor,Axiom.Graphics.QueuedRenderableCollection.OrganizationMode)">
            <summary>
            Accept a visitor over the collection contents.
            </summary>
            <param name="visitor">Visitor class which should be called back</param>
            <param name="organizationMode">
            The organization mode which you want to iterate over.
            Note that this must have been included in an AddOrganizationMode
            call before any renderables were added.
            </param>
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.acceptVisitorGrouped(Axiom.Graphics.IQueuedRenderableVisitor)">
            Internal visitor implementation
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.acceptVisitorDescending(Axiom.Graphics.IQueuedRenderableVisitor)">
            Internal visitor implementation
        </member>
        <member name="M:Axiom.Graphics.QueuedRenderableCollection.acceptVisitorAscending(Axiom.Graphics.IQueuedRenderableVisitor)">
            Internal visitor implementation
        </member>
        <member name="T:Axiom.Graphics.QueuedRenderableCollection.OrganizationMode">
            <summary>
            Organization modes required for this collection.
            </summary>
            <remarks>
            This affects the internal placement of the items added to this collection;
            if only one type of sorting / grouping is to be required, then renderables
            can be stored only once, whilst if multiple types are going to be needed
            then internally there will be multiple organizations. Changing the organization
            needs to be done when the collection is empty.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection.OrganizationMode.GroupByPass">
            Group by pass
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection.OrganizationMode.Descending">
            Sort descending camera distance
        </member>
        <member name="F:Axiom.Graphics.QueuedRenderableCollection.OrganizationMode.Ascending">
            <summary>
            Sort ascending camera distance 
            </summary>
            <remarks>
            Note value overlaps with descending since both use same sort
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.HardwareBufferManager">
            <summary>
            	Abstract singleton class for managing hardware buffers, a concrete instance
            	of this will be created by the RenderSystem.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.#ctor(Axiom.Graphics.HardwareBufferManagerBase)">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
            <remarks>
                Protected internal because this singleton will actually hold the instance of a subclass
                created by a render system plugin.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.HardwareBufferManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.IShadowCameraSetup">
            <summary>
            This class allows you to plug in new ways to define the camera setup when
            rendering and projecting shadow textures.
            </summary>
            <remarks>
            The default projection used when rendering shadow textures is a uniform
            frustum. This is pretty straight forward but doesn't make the best use of
            the space in the shadow map since texels closer to the camera will be larger,
            resulting in 'jaggies'. There are several ways to distribute the texels
            in the shadow texture differently, and this class allows you to override
            that.
            <para/>
            Axiom is provided with several alternative shadow camera setups, including
            LiSPSM (<see name="LiSPSMShadowCameraSetup"/>) and Plane Optimal
            (<see name="PlaneOptimalShadowCameraSetup"/>).
            Others can of course be written to incorporate other algorithms. All you
            have to do is instantiate one of these classes and enable it using
            <see cref="P:Axiom.Core.SceneManager.ShadowCameraSetup"/> (global) or
            <see cref="P:Axiom.Core.Light.CustomShadowCameraSetup"/>
            (per light). In both cases the instance is be deleted automatically when
            no more references to it exist.
            <para/>
            Shadow map matrices, being projective matrices, have 15 degrees of freedom.
            3 of these degrees of freedom are fixed by the light's position.  4 are used to
            affinely affect z values.  6 affinely affect u,v sampling.  2 are projective
            degrees of freedom.  This class is meant to allow custom methods for
            handling optimization.
            </remarks>
        </member>
        <member name="M:Axiom.Core.IShadowCameraSetup.GetShadowCamera(Axiom.Core.SceneManager,Axiom.Core.Camera,Axiom.Core.Viewport,Axiom.Core.Light,Axiom.Core.Camera,System.Int32)">
            <summary>
            Gets a specific implementation of a ShadowCamera setup.
            </summary>
            <param name="sceneManager"></param>
            <param name="camera"></param>
            <param name="viewport"></param>
            <param name="light"></param>
            <param name="textureCamera"></param>
            <param name="iteration"></param>
        </member>
        <member name="M:Axiom.Core.DefaultShadowCameraSetup.GetShadowCamera(Axiom.Core.SceneManager,Axiom.Core.Camera,Axiom.Core.Viewport,Axiom.Core.Light,Axiom.Core.Camera,System.Int32)">
            <summary>
            Gets a default implementation of a ShadowCamera.
            </summary>
            <param name="sceneManager"></param>
            <param name="camera"></param>
            <param name="viewport"></param>
            <param name="light"></param>
            <param name="textureCamera"></param>
            <param name="iteration"></param>
        </member>
        <member name="T:Axiom.Media.Col3b">
            Type for R8G8B8/B8G8R8 
        </member>
        <member name="T:Axiom.Media.Col3f">
            Type for FLOAT32_RGB 
        </member>
        <member name="T:Axiom.Media.Col4f">
            Type for FLOAT32_RGBA 
        </member>
        <member name="T:Axiom.Media.OptimizedPixelConversion">
            <summary>
                A class to convert/copy pixels of the same or different formats
            </summary>
        </member>
        <member name="T:Axiom.Media.Bitwise">
            <summary>
                Class for manipulating bit patterns.
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.MostSignificantBitSet(System.UInt32)">
            <summary>
                Returns the most significant bit set in a value.
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.IsPow2(System.Int32)">
            <summary>
            checks if a number is a power of 2
            </summary>
            <param name="number"></param>
            <returns>true if the number is a power of two otherwise false</returns>
        </member>
        <member name="M:Axiom.Media.Bitwise.FirstPO2From(System.UInt32)">
            <summary>
                Returns the closest power-of-two number greater or equal to value.
            </summary>
            <remarks>
               0 and 1 are powers of two, so firstPO2From(0)==0 and firstPO2From(1)==1.
            </remarks>
        </member>
        <member name="M:Axiom.Media.Bitwise.FixedToFixed(System.UInt32,System.Int32,System.Int32)">
            <summary>
                Convert N bit colour channel value to P bits. It fills P bits with the
                bit pattern repeated. (this is /((1&lt;&lt;n)-1) in fixed point)
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.FixedToByteFixed(System.UInt32,System.Int32)">
            <summary>
                Convert N bit colour channel value to 8 bits, and return as a byte. It 
                fills P bits with thebit pattern repeated. (this is /((1&lt;&lt;n)-1) in fixed point)
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.FloatToFixed(System.Single,System.Int32)">
            <summary>
                Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped) 
                to integer of a certain number of bits. Works for any value of bits between 0 and 31.
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.FloatToByteFixed(System.Single)">
            <summary>
                Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped) 
                to an 8-bit integer, and return as a byte.
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.FixedToFloat(System.UInt32,System.Int32)">
            <summary>
                Fixed point to float
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.IntWrite(System.IntPtr,System.Int32,System.UInt32)">
            Write a n*8 bits integer value to memory in native endian.
        </member>
        <member name="M:Axiom.Media.Bitwise.IntRead(System.IntPtr,System.Int32)">
            <summary>
                Read a n*8 bits integer value to memory in native endian.
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.FloatToHalf(System.Single)">
            <summary>
                Convert a float32 to a float16 (NV_half_float)
                Courtesy of OpenEXR
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.FloatToHalfI(System.UInt32)">
            <summary>
                Converts float in uint format to a a half in ushort format
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.HalfToFloat(System.UInt16)">
            <summary>
                Convert a float16 (NV_half_float) to a float32
                Courtesy of OpenEXR
            </summary>
        </member>
        <member name="M:Axiom.Media.Bitwise.HalfToFloatI(System.UInt16)">
            <summary>
                Converts a half in ushort format to a float
                in uint format
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Vector3List">
            <summary>
            	A strongly-typed collection of <see cref="T:Axiom.Math.Vector3"/> objects.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Synchronized(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Creates a synchronized (thread-safe) wrapper for a 
                <c>Vector3List</c> instance.
            </summary>
            <returns>
                An <c>Vector3List</c> wrapper that is synchronized (thread-safe).
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.ReadOnly(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Creates a read-only wrapper for a 
                <c>Vector3List</c> instance.
            </summary>
            <returns>
                An <c>Vector3List</c> wrapper that is read-only.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that has the specified initial capacity.
            </summary>
            <param name="capacity">
            	The number of elements that the new <c>Vector3List</c> is initially capable of storing.
            </param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that contains elements copied from the specified <c>Vector3List</c>.
            </summary>
            <param name="c">The <c>Vector3List</c> whose elements are copied to the new collection.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor(Axiom.Math.Vector3[])">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that contains elements copied from the specified <see cref="T:Axiom.Math.Vector3"/> array.
            </summary>
            <param name="a">The <see cref="T:Axiom.Math.Vector3"/> array whose elements are copied to the new list.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.CopyTo(Axiom.Math.Vector3[])">
            <summary>
            	Copies the entire <c>Vector3List</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Vector3"/> array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Vector3"/> array to copy to.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.CopyTo(Axiom.Math.Vector3[],System.Int32)">
            <summary>
            	Copies the entire <c>Vector3List</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Vector3"/> array, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Vector3"/> array to copy to.</param>
            <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Add(Axiom.Math.Vector3)">
            <summary>
            	Adds a <see cref="T:Axiom.Math.Vector3"/> to the end of the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to be added to the end of the <c>Vector3List</c>.</param>
            <returns>The index at which the value has been added.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Clear">
            <summary>
            	Removes all elements from the <c>Vector3List</c>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Clone">
            <summary>
            	Creates a shallow copy of the <see cref="T:Axiom.Math.Collections.Vector3List"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Contains(Axiom.Math.Vector3)">
            <summary>
            	Determines whether a given <see cref="T:Axiom.Math.Vector3"/> is in the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to check for.</param>
            <returns><c>true</c> if <paramref name="item"/> is found in the <c>Vector3List</c>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.IndexOf(Axiom.Math.Vector3)">
            <summary>
            	Returns the zero-based index of the first occurrence of a <see cref="T:Axiom.Math.Vector3"/>
            	in the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to locate in the <c>Vector3List</c>.</param>
            <returns>
            	The zero-based index of the first occurrence of <paramref name="item"/> 
            	in the entire <c>Vector3List</c>, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Insert(System.Int32,Axiom.Math.Vector3)">
            <summary>
            	Inserts an element into the <c>Vector3List</c> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Remove(Axiom.Math.Vector3)">
            <summary>
            	Removes the first occurrence of a specific <see cref="T:Axiom.Math.Vector3"/> from the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to remove from the <c>Vector3List</c>.</param>
            <exception cref="T:System.ArgumentException">
            	The specified <see cref="T:Axiom.Math.Vector3"/> was not found in the <c>Vector3List</c>.
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.RemoveAt(System.Int32)">
            <summary>
            	Removes the element at the specified index of the <c>Vector3List</c>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.GetEnumerator">
            <summary>
            	Returns an enumerator that can iterate through the <c>Vector3List</c>.
            </summary>
            <returns>An <see cref="T:Axiom.Math.Collections.Vector3List.Enumerator"/> for the entire <c>Vector3List</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.AddRange(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Adds the elements of another <c>Vector3List</c> to the current <c>Vector3List</c>.
            </summary>
            <param name="x">The <c>Vector3List</c> whose elements should be added to the end of the current <c>Vector3List</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.Vector3List.Count"/> of the <c>Vector3List</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.AddRange(Axiom.Math.Vector3[])">
            <summary>
            	Adds the elements of a <see cref="T:Axiom.Math.Vector3"/> array to the current <c>Vector3List</c>.
            </summary>
            <param name="x">The <see cref="T:Axiom.Math.Vector3"/> array whose elements should be added to the end of the <c>Vector3List</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.Vector3List.Count"/> of the <c>Vector3List</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.TrimToSize">
            <summary>
            	Sets the capacity to the actual number of elements.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.ValidateIndex(System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="i"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="i"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.ValidateIndex(System.Int32,System.Boolean)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="i"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="i"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Count">
            <summary>
            	Gets the number of elements actually contained in the <c>Vector3List</c>.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IsSynchronized">
            <summary>
            	Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
            <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.SyncRoot">
            <summary>
            	Gets an object that can be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Item(System.Int32)">
            <summary>
            	Gets or sets the <see cref="T:Axiom.Math.Vector3"/> at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IsFixedSize">
            <summary>
            	Gets a value indicating whether the collection has a fixed size.
            </summary>
            <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IsReadOnly">
            <summary>
            	gets a value indicating whether the <B>IList</B> is read-only.
            </summary>
            <value>true if the collection is read-only; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Capacity">
            <summary>
            	Gets or sets the number of elements the <c>Vector3List</c> can contain.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator">
            <summary>
            	Supports type-safe iteration over a <see cref="T:Axiom.Math.Collections.Vector3List"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Vector3List.Enumerator">
            <summary>
            	Supports simple iteration over a <see cref="T:Axiom.Math.Collections.Vector3List"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Enumerator.#ctor(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
            <param name="tc"></param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Enumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Enumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.RotationalSpline">
            <summary>
            	A class used to interpolate orientations (rotations) along a spline using 
            	derivatives of quaternions.
            </summary>
            <remarks>
            	Like the PositionalSpline class, this class is about interpolating values 
            	smoothly over a spline. Whilst PositionalSpline deals with positions (the normal
            	sense we think about splines), this class interpolates orientations. The
            	theory is identical, except we're now in 4-dimensional space instead of 3.
            	<p/>
            	In positional splines, we use the points and tangents on those points to generate
            	control points for the spline. In this case, we use quaternions and derivatives
            	of the quaternions (i.e. the rate and direction of change at each point). This is the
            	same as PositionalSpline since a tangent is a derivative of a position. We effectively 
            	generate an extra quaternion in between each actual quaternion which when take with 
            	the original quaternion forms the 'tangent' of that quaternion.
            </remarks>
        </member>
        <member name="F:Axiom.Math.Spline`1.pointList">
            <summary>Collection of control points.</summary>
        </member>
        <member name="F:Axiom.Math.Spline`1.tangentList">
            <summary>Collection of generated tangents for the spline controls points.</summary>
        </member>
        <member name="F:Axiom.Math.Spline`1.autoCalculateTangents">
            <summary>Specifies whether or not to recalculate tangents as each control point is added.</summary>
        </member>
        <member name="M:Axiom.Math.Spline`1.AddPoint(`0)">
            <summary>
               Adds a new control point to the end of this spline.
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Axiom.Math.Spline`1.Clear">
            <summary>
               Removes all current control points from this spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.Spline`1.GetPoint(System.Int32)">
            <summary>
                Returns the point at the specified index.
            </summary>
            <param name="index">Index at which to retrieve a point.</param>
            <returns>Vector3 containing the point data.</returns>
        </member>
        <member name="M:Axiom.Math.Spline`1.RecalculateTangents">
            <summary>
            	Recalculates the tangents associated with this spline. 
            </summary>
            <remarks>
            	If you tell the spline not to update on demand by setting AutoCalculate to false,
            	then you must call this after completing your updates to the spline points.
            </remarks>
        </member>
        <member name="M:Axiom.Math.Spline`1.Interpolate(Axiom.Math.Real)">
            <summary>
            	Returns an interpolated point based on a parametric value over the whole series.
            </summary>
            <remarks>
            	Given a t value between 0 and 1 representing the parametric distance along the
            	whole length of the spline, this method returns an interpolated point.
            </remarks>
            <param name="t">Parametric value.</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.Spline`1.Interpolate(System.Int32,Axiom.Math.Real)">
            <summary>
            	Interpolates a single segment of the spline given a parametric value.
            </summary>
            <param name="index">The point index to treat as t=0. index + 1 is deemed to be t=1</param>
            <param name="t">Parametric value</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="P:Axiom.Math.Spline`1.AutoCalculate">
            <summary>
            	Specifies whether or not to recalculate tangents as each control point is added.
            </summary>
        </member>
        <member name="P:Axiom.Math.Spline`1.PointCount">
            <summary>
               Gets the number of control points in this spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.#ctor">
            <summary>
            	Creates a new Rotational Spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Interpolate(Axiom.Math.Real)">
            <summary>
            	Returns an interpolated point based on a parametric value over the whole series.
            </summary>
            <remarks>
            	Given a t value between 0 and 1 representing the parametric distance along the
            	whole length of the spline, this method returns an interpolated point.
            </remarks>
            <param name="t">Parametric value.</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Interpolate(System.Int32,Axiom.Math.Real)">
            <summary>
            	Interpolates a single segment of the spline given a parametric value.
            </summary>
            <param name="index">The point index to treat as t=0. index + 1 is deemed to be t=1</param>
            <param name="t">Parametric value</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Interpolate(Axiom.Math.Real,System.Boolean)">
            <summary>
            	Returns an interpolated point based on a parametric value over the whole series.
            </summary>
            <remarks>
            	Given a t value between 0 and 1 representing the parametric distance along the
            	whole length of the spline, this method returns an interpolated point.
            </remarks>
            <param name="t">Parametric value.</param>
            <param name="useShortestPath">True forces rotations to use the shortest path.</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Interpolate(System.Int32,Axiom.Math.Real,System.Boolean)">
            <summary>
            	Interpolates a single segment of the spline given a parametric value.
            </summary>
            <param name="index">The point index to treat as t=0. index + 1 is deemed to be t=1</param>
            <param name="t">Parametric value</param>
            <param name="useShortestPath"></param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.RecalculateTangents">
            <summary>
            	Recalculates the tangents associated with this spline. 
            </summary>
            <remarks>
            	If you tell the spline not to update on demand by setting AutoCalculate to false,
            	then you must call this after completing your updates to the spline points.
            </remarks>
        </member>
        <member name="T:Axiom.Math.PlaneBoundedVolume">
            <summary>
            	Represents a convex volume bounded by planes.
            </summary>
        </member>
        <member name="F:Axiom.Math.PlaneBoundedVolume.planes">
            <summary>
            	Publicly accessible plane list, you can modify this direct.
            </summary>
        </member>
        <member name="F:Axiom.Math.PlaneBoundedVolume.outside">
            <summary>
            	Side of the plane to be considered 'outside'.
            </summary>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.#ctor(Axiom.Math.PlaneSide)">
            <summary>
            	Constructor.
            </summary>
            <param name="outside">Side of the plane to be considered 'outside'.</param>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Intersection test with an <see cref="T:Axiom.Math.AxisAlignedBox"/>.
            </summary>
            <remarks>
            	May return false positives but will never miss an intersection.
            </remarks>
            <param name="box">Box to test.</param>
            <returns>True if interesecting, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Intersection test with <see cref="T:Axiom.Math.Sphere"/>.
            </summary>
            <param name="sphere">Sphere to test.</param>
            <returns>True if the sphere intersects this volume, and false otherwise.</returns>
        </member>
        <member name="T:Axiom.Graphics.HardwareAnimationData">
            <summary>
                Struct used to hold hardware morph / pose vertex data information
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexData">
            <summary>
            	Summary class collecting together vertex source information.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexDeclaration">
            <summary>
            	Declaration of the vertex to be used in this operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexBufferBinding">
            <summary>
            	The vertex buffer bindings to be used.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexStart">
            <summary>
            	The base vertex index to start from, if using unindexed geometry.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexCount">
            <summary>
            	The number of vertices used in this operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.HWAnimationDataList">
            <summary>
                VertexElements used for hardware morph / pose animation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.HWAnimDataItemsUsed">
            <summary>
                Number of hardware animation data items used
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.hardwareShadowVolWBuffer">
            <summary>
            	Additional shadow volume vertex buffer storage.
            </summary>
            <remarks>
            	This additional buffer is only used where we have prepared this VertexData for
            	use in shadow volume contruction, and where the current render system supports
            	vertex programs. This buffer contains the 'w' vertex position component which will
            	be used by that program to differentiate between extruded and non-extruded vertices.
            	This 'w' component cannot be included in the original position buffer because
            	DirectX does not allow 4-component positions in the fixed-function pipeline, and the original
            	position buffer must still be usable for fixed-function rendering.
            	<p/>
            	Note that we don't store any vertex declaration or vertex buffer binding here becuase this
            	can be reused in the shadow algorithm.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.VertexData.#ctor">
            <summary>
            	Default constructor.  Calls on the current buffer manager to initialize the bindings and declarations.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexData.Clone">
            <summary>
            	Clones this vertex data, potentially including replicating any vertex buffers.
            </summary>
            <returns>A cloned vertex data object.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexData.Clone(System.Boolean)">
            <summary>
            	Clones this vertex data, potentially including replicating any vertex buffers.
            </summary>
            <param name="copyData">
            	If true, makes a copy the vertex buffer in addition to the definition.
            	If false, the clone will refer to the same vertex buffer this object refers to.
            </param>
            <returns>A cloned vertex data object.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexData.PrepareForShadowVolume">
            <summary>
            	Modifies the vertex data to be suitable for use for rendering shadow geometry.
            </summary>
            <remarks>
            	<para>
            		Preparing vertex data to generate a shadow volume involves firstly ensuring that the
            		vertex buffer containing the positions is a standalone vertex buffer,
            		with no other components in it. This method will therefore break apart any existing
            		vertex buffers if position is sharing a vertex buffer.
            		Secondly, it will double the size of this vertex buffer so that there are 2 copies of
            		the position data for the mesh. The first half is used for the original, and the second
            		half is used for the 'extruded' version. The vertex count used to render will remain
            		the same though, so as not to add any overhead to regular rendering of the object.
            		Both copies of the position are required in one buffer because shadow volumes stretch
            		from the original mesh to the extruded version.
            	</para>
            	<para>
            		It's important to appreciate that this method can fundamentally change the structure of your
            		vertex buffers, although in reality they will be new buffers. As it happens, if other
            		objects are using the original buffers then they will be unaffected because the reference
            		counting will keep them intact. However, if you have made any assumptions about the
            		structure of the vertex data in the buffers of this object, you may have to rethink them.
            	</para>
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.VertexData.AllocateHardwareAnimationElements(System.UInt16)">
            <summary>
                Allocate elements to serve a holder of morph / pose target data
                for hardware morphing / pose blending.
            </summary>
            <remarks>
            	This method will allocate the given number of 3D texture coordinate
            	sets for use as a morph target or target pose offset (3D position).
            	These elements will be saved in hwAnimationDataList.
            	It will also assume that the source of these new elements will be new
            	buffers which are not bound at this time, so will start the sources to
            	1 higher than the current highest binding source. The caller is
            	expected to bind these new buffers when appropriate. For morph animation
            	the original position buffer will be the 'from' keyframe data, whilst
            	for pose animation it will be the original vertex data.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.IndexData">
            <summary>
            	Summary class collecting together index data source information.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IndexData.indexBuffer">
            <summary>
            	Reference to the <see cref="T:Axiom.Graphics.HardwareIndexBuffer"/> to use, must be specified if useIndexes = true
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IndexData.indexStart">
            <summary>
            	Index in the buffer to start from for this operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IndexData.indexCount">
            <summary>
            	The number of indexes to use from the buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.IndexData.Clone">
            <summary>
            	Creates a copy of the index data object, without a copy of the buffer data.
            </summary>
            <returns>A copy of this IndexData object without the data.</returns>
        </member>
        <member name="M:Axiom.Graphics.IndexData.Clone(System.Boolean)">
            <summary>
            	Clones this vertex data, potentially including replicating any index buffers.
            </summary>
            <param name="copyData">
            	If true, makes a copy the index buffer in addition to the definition.
            	If false, the clone will refer to the same index buffer this object refers to.
            </param>
            <returns>A copy of this IndexData object.</returns>
        </member>
        <member name="T:Axiom.Graphics.VertexElement">
            <summary>
            	This class declares the usage of a single vertex buffer as a component
            	of a complete <see cref="T:Axiom.Graphics.VertexDeclaration"/>. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.source">
            <summary>
                The source vertex buffer, as bound to an index using <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.offset">
            <summary>
                The offset in the buffer that this element starts at.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.type">
            <summary>
                The type of element.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.semantic">
            <summary>
                The meaning of the element.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.index">
            <summary>
                Index of the item, only applicable for some elements like texture coords.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.#ctor(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The source vertex buffer, as bound to an index using <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.</param>
            <param name="offset">The offset in the buffer that this element starts at.</param>
            <param name="type">The type of element.</param>
            <param name="semantic">The meaning of the element.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.#ctor(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The source vertex buffer, as bound to an index using <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.</param>
            <param name="offset">The offset in the buffer that this element starts at.</param>
            <param name="type">The type of element.</param>
            <param name="semantic">The meaning of the element.</param>
            <param name="index">Index of the item, only applicable for some elements like texture coords.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.GetTypeSize(Axiom.Graphics.VertexElementType)">
            <summary>
                Utility method for helping to calculate offsets.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.GetTypeCount(Axiom.Graphics.VertexElementType)">
            <summary>
                Utility method which returns the count of values in a given type.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.MultiplyTypeCount(Axiom.Graphics.VertexElementType,System.Int32)">
            <summary>
            	Returns proper enum for a base type multiplied by a value.  This is helpful
            	when working with tex coords especially since you might not know the number
            	of texture dimensions at runtime, and when creating the VertexBuffer you will
            	have to get a VertexElementType based on that amount to creating the VertexElement.
            </summary>
            <param name="type">Data type.</param>
            <param name="count">Multiplier.</param>
            <returns>
                A <see cref="T:Axiom.Graphics.VertexElementType"/> that represents the requested type and count.
            </returns>
            <example>
                MultiplyTypeCount(VertexElementType.Float1, 3) returns VertexElementType.Float3.
            </example>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.Clone">
            <summary>
                Simple memberwise clone since all local fields are value types.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Source">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Offset">
            <summary>
                Gets the offset into the buffer where this element starts.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Type">
            <summary>
                Gets the data format of this element.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Semantic">
            <summary>
                Gets the meaning of this element.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Index">
            <summary>
                Gets the index of this element, only applicable for repeating elements (like texcoords).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Size">
            <summary>
                Gets the size of this element in bytes.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderQueueGroup">
            <summary>
            	A grouping level underneath RenderQueue which groups renderables
            	to be issued at coarsely the same time to the renderer.	
            </summary>
            <remarks>
            	Each instance of this class itself hold RenderPriorityGroup instances, 
            	which are the groupings of renderables by priority for fine control
            	of ordering (not required for most instances).
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.parent">
            <summary>
            	Render queue that this queue group belongs to.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.splitPassesByLightingType">
            <summary>
            	Should passes be split by their lighting stage?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.priorityGroups">
            <summary>
            	List of priority groups.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.shadowsEnabled">
            <summary>
            	Are shadows enabled for this group?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.#ctor(Axiom.Graphics.RenderQueue,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Default constructor.
            </summary>
            <param name="parent">Render queue that owns this group.</param>
            <param name="splitPassesByLightingType">Split passes based on lighting stage?</param>
            <param name="splitNoShadowPasses"></param>
            <param name="shadowCastersCannotBeReceivers"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.AddRenderable(Axiom.Graphics.IRenderable,Axiom.Graphics.Technique,System.UInt16)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.Clear">
            <summary>
            	Clears all the priority groups within this group.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.Clear(System.Boolean)">
            <summary>
            Clears all the priority groups within this group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.NumPriorityGroups">
            <summary>
               Gets the number of priority groups within this queue group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.PriorityGroups">
            <summary>
            List of priority groups.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.ShadowsEnabled">
            <summary>
            	Indicate whether a given queue group will be doing any shadow setup.
            </summary>
            <remarks>
            	This method allows you to inform the queue about a queue group, and to 
            	indicate whether this group will require shadow processing of any sort.
            	In order to preserve rendering order, Axiom/Ogre has to treat queue groups
            	as very separate elements of the scene, and this can result in it
            	having to duplicate shadow setup for each group. Therefore, if you
            	know that a group which you are using will never need shadows, you
            	should preregister the group using this method in order to improve
            	the performance.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.SplitPassesByLightingType">
            <summary>
            	Gets/Sets whether or not the queue will split passes by their lighting type,
            	ie ambient, per-light and decal. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.SplitNoShadowPasses">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.ShadowCastersCannotBeReceivers">
            <summary>
            	Gets/Sets whether or not the queue will disallow receivers when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Pass">
            <summary>
            	Class defining a single pass of a Technique (of a Material), ie
               a single rendering call. 
            </summary>
            <remarks>
               Rendering can be repeated with many passes for more complex effects.
               Each pass is either a fixed-function pass (meaning it does not use
               a vertex or fragment program) or a programmable pass (meaning it does
               use either a vertex or a fragment program, or both). 
               <p/>
               Programmable passes are complex to define, because they require custom
               programs and you have to set all constant inputs to the programs (like
               the position of lights, any base material colors you wish to use etc), but
               they do give you much total flexibility over the algorithms used to render your
               pass, and you can create some effects which are impossible with a fixed-function pass.
               On the other hand, you can define a fixed-function pass in very little time, and
               you can use a range of fixed-function effects like environment mapping very
               easily, plus your pass will be more likely to be compatible with older hardware.
               There are pros and cons to both, just remember that if you use a programmable
               pass to create some great effects, allow more time for definition and testing.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.Pass._dirtyList">
            <summary>
            	List of passes with dirty hashes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._graveyardList">
            <summary>
            	List of passes queued for deletion.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._parent">
            <summary>
               A reference to the technique that owns this Pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._index">
            <summary>
               Index of this rendering pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._hashCode">
            <summary>
               Pass hash, used for sorting passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._name">
            <summary>
                Name of this pass (or the index if it isn't set)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._ambient">
            <summary>
               Ambient color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._diffuse">
            <summary>
               Diffuse color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._specular">
            <summary>
               Specular color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._emissive">
            <summary>
            Emissive color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._shininess">
            <summary>
               Shininess of the object's surface in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._tracking">
            <summary>
               Color parameters that should track the vertex color for fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._sourceBlendFactor">
            <summary>
               Source blend factor.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._destinationBlendFactor">
            <summary>
               Destination blend factor.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._depthCheck">
            <summary>
               Depth buffer checking setting for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._depthWrite">
            <summary>
               Depth write setting for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._depthFunction">
            <summary>
               Depth comparison function for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._depthBiasConstant">
            <summary>
               Depth bias for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._depthBiasSlopeScale">
            <summary>
            	Depth bias slope for this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetDepthBias(System.Single,System.Single)">
            <overloads>
            <summary>
               Sets the depth bias to be used for this Pass.
            </summary>
            <remarks>
               When polygons are coplanar, you can get problems with 'depth fighting' (or 'z fighting') where
               the pixels from the two polys compete for the same screen pixel. This is particularly
               a problem for decals (polys attached to another surface to represent details such as
               bulletholes etc.).
               <p/>
               A way to combat this problem is to use a depth bias to adjust the depth buffer value
               used for the decal such that it is slightly higher than the true value, ensuring that
               the decal appears on top. There are two aspects to the biasing, a constant
               bias value and a slope-relative biasing value, which varies according to the
               maximum depth slope relative to the camera, ie:
               <pre>finalBias = maxSlope * slopeScaleBias + constantBias</pre>
               Note that slope scale bias, whilst more accurate, may be ignored by old hardware.
            </remarks>
            <param name="constantBias">The constant bias value, expressed as a factor of the minimum observable depth</param>
            </overloads>
            <param name="slopeBias">The slope-relative bias value, expressed as a factor of the depth slope</param>
        </member>
        <member name="F:Axiom.Graphics.Pass._colorWriteEnabled">
            <summary>
               Color write setting for this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetAlphaRejectSettings(Axiom.Graphics.CompareFunction,System.Int32)">
            <summary>
            Sets the way the pass will have use alpha to totally reject pixels from the pipeline.
            </summary>
            <remarks>
            The default is <see ref="CompareFunction.AlwaysPass" /> i.e. alpha is not used to reject pixels.
            <para>This option applies in both the fixed function and the programmable pipeline.</para></remarks>
            <param name="alphaRejectFunction">The comparison which must pass for the pixel to be written.</param>
            <param name="value">value against which alpha values will be tested [(0-255]</param>
        </member>
        <member name="F:Axiom.Graphics.Pass._cullingMode">
            <summary>
               Hardware culling mode for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._manualCullingMode">
            <summary>
               Software culling mode for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._lightingEnabled">
            <summary>
               Is lighting enabled for this pass?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._maxSimultaneousLights">
            <summary>
               Max number of simultaneous lights that can be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._startLight">
            <summary>
               the light index that this pass will start at in the light list.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._iteratePerLight">
            <summary>
               Run this pass once per light? 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._runOnlyForOneLightType">
            <summary>
                Should it only be run for a certain light type? 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._onlyLightType">
            <summary>
               Type of light for a programmable pass that supports only one particular type of light.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._shadingMode">
            <summary>
               Shading options for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._polygonMode">
            <summary>
            the type of polygon rendering required
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fogOverride">
            <summary>
               Does this pass override global fog settings?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fogMode">
            <summary>
               Fog mode to use for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fogColor">
            <summary>
               Color of the fog used for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fogStart">
            <summary>
               Starting point of the fog for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fogEnd">
            <summary>
               Ending point of the fog for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fogDensity">
            <summary>
               Density of the fog for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.textureUnitStates">
            <summary>
               List of fixed function texture unit states for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._vertexProgramUsage">
            <summary>
               Details on the vertex program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._fragmentProgramUsage">
            <summary>
               Details on the fragment program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._geometryProgramUsage">
            <summary>
               Details on the geometry program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.shadowCasterVertexProgramUsage">
            <summary>
               Details on the shadow caster vertex program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._shadowCasterFragmentProgramUsage">
            <summary>
               Details on the shadow caster fragment program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._shadowReceiverVertexProgramUsage">
            <summary>
               Details on the shadow receiver vertex program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass._shadowReceiverFragmentProgramUsage">
            <summary>
               Details on the shadow receiver fragment program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.queuedForDeletion">
            <summary>
            	Is this pass queued for deletion?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.#ctor(Axiom.Graphics.Technique,System.Int32)">
            <summary>
               Default constructor.
            </summary>
            <param name="parent">Technique that owns this Pass.</param>
            <param name="index">Index of this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.AddTextureUnitState(Axiom.Graphics.TextureUnitState)">
            <summary>
               Adds the passed in TextureUnitState, to the existing Pass.
            </summary>
            <param name="state">TextureUnitState to add to this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.Clone(Axiom.Graphics.Technique,System.Int32)">
            <summary>
               Method for cloning a Pass object.
            </summary>
            <param name="parent">Parent technique that will own this cloned Pass.</param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.CopyTo(Axiom.Graphics.Pass)">
            <summary>
            	Copy the details of this pass to the target pass.
            </summary>
            <param name="target">Destination pass to copy this pass's attributes to.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.CreateTextureUnitState">
            <summary>
               Overloaded method.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.CreateTextureUnitState(System.String)">
            <summary>
               Overloaded method.
            </summary>
            <param name="textureName">The basic name of the texture (i.e. brickwall.jpg)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.CreateTextureUnitState(System.String,System.Int32)">
            <summary>
               Inserts a new TextureUnitState object into the Pass.
            </summary>
            <remarks>
               This unit is is added on top of all previous texture units.
               <p/>
               Applies to both fixed-function and programmable passes.
            </remarks>
            <param name="textureName">The basic name of the texture (i.e. brickwall.jpg)</param>
            <param name="texCoordSet">The index of the texture coordinate set to use.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.GetTextureUnitState(System.Int32)">
            <summary>
               Gets a reference to the TextureUnitState for this pass at the specified indx.
            </summary>
            <param name="index">Index of the state to retreive.</param>
            <returns>TextureUnitState at the specified index.</returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.Load">
            <summary>
               Internal method for loading this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.NotifyNeedsRecompile">
            <summary>
               Tells the pass that it needs recompilation.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.RecalculateHash">
            <summary>
               Internal method for recalculating the hash code used for sorting passes.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.RemoveAllTextureUnitStates">
            <summary>
               Removes all texture unit settings from this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.RemoveTextureUnitState(Axiom.Graphics.TextureUnitState)">
            <summary>
               Removes the specified TextureUnitState from this pass.
            </summary>
            <param name="state">A reference to the TextureUnitState to remove from this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.RemoveTextureUnitState(System.Int32)">
            <summary>
               Removes the specified TextureUnitState from this pass.
            </summary>
            <param name="index">Index of the TextureUnitState to remove from this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
               Sets the fogging mode applied to this pass.
            </summary>
            <remarks>
               Fogging is an effect that is applied as polys are rendered. Sometimes, you want
               fog to be applied to an entire scene. Other times, you want it to be applied to a few
               polygons only. This pass-level specification of fog parameters lets you easily manage
               both.
               <p/>
               The SceneManager class also has a SetFog method which applies scene-level fog. This method
               lets you change the fog behavior for this pass compared to the standard scene-level fog.
            </remarks>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref name="overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
            <param name="color">
               The color of the fog. Either set this to the same as your viewport background color,
               or to blend in with a skydome or skybox.
            </param>
            <param name="density">
               The density of the fog in FogMode.Exp or FogMode.Exp2 mode, as a value between 0 and 1. 
               The default is 0.001.
            </param>
            <param name="start">
               Distance in world units at which linear fog starts to encroach. 
               Only applicable if mode is FogMode.Linear.
            </param>
            <param name="end">
               Distance in world units at which linear fog becomes completely opaque.
               Only applicable if mode is FogMode.Linear.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref name="overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref name="overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
            <param name="color">
               The color of the fog. Either set this to the same as your viewport background color,
               or to blend in with a skydome or skybox.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref name="overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
            <param name="color">
               The color of the fog. Either set this to the same as your viewport background color,
               or to blend in with a skydome or skybox.
            </param>
            <param name="density">
               The density of the fog in FogMode.Exp or FogMode.Exp2 mode, as a value between 0 and 1. 
               The default is 0.001.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetRunOncePerLight(System.Boolean,System.Boolean,Axiom.Graphics.LightType)">
            <summary>
               Sets whether or not this pass should be run once per light which 
               can affect the object being rendered.
            </summary>
            <remarks>
               The default behavior for a pass (when this option is 'false'), is 
               for a pass to be rendered only once, with all the lights which could 
               affect this object set at the same time (up to the maximum lights 
               allowed in the render system, which is typically 8). 
               <p/>
               Setting this option to 'true' changes this behavior, such that 
               instead of trying to issue render this pass once per object, it 
               is run once <b>per light</b> which can affect this object. In 
               this case, only light index 0 is ever used, and is a different light 
               every time the pass is issued, up to the total number of lights 
               which is affecting this object. This has 2 advantages: 
               <ul><li>There is no limit on the number of lights which can be 
               supported</li> 
               <li>It's easier to write vertex / fragment programs for this because 
               a single program can be used for any number of lights</li> 
               </ul> 
               However, this technique is a lot more expensive, and typically you 
               will want an additional ambient pass, because if no lights are 
               affecting the object it will not be rendered at all, which will look 
               odd even if ambient light is zero (imagine if there are lit objects 
               behind it - the objects silhouette would not show up). Therefore, 
               use this option with care, and you would be well advised to provide 
               a less expensive fallback technique for use in the distance. 
               <p/>
               Note: The number of times this pass runs is still limited by the maximum 
               number of lights allowed as set in MaxLights, so 
               you will never get more passes than this. 
            </remarks>
            <param name="enabled">Whether this feature is enabled.</param>
            <param name="onlyForOneLightType">
               If true, the pass will only be run for a single type of light, other light types will be ignored. 
            </param>
            <param name="lightType">The single light type which will be considered for this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetSceneBlending(Axiom.Graphics.SceneBlendType)">
            <summary>
               Sets the kind of blending this pass has with the existing contents of the scene.
            </summary>
            <remarks>
               Whereas the texture blending operations seen in the TextureUnitState class are concerned with
               blending between texture layers, this blending is about combining the output of the Pass
               as a whole with the existing contents of the rendering target. This blending therefore allows
               object transparency and other special effects. If all passes in a technique have a scene
               blend, then the whole technique is considered to be transparent.
               <p/>
               This method allows you to select one of a number of predefined blending types. If you require more
               control than this, use the alternative version of this method which allows you to specify source and
               destination blend factors.
               <p/>
               This method is applicable for both the fixed-function and programmable pipelines.
            </remarks>
            <param name="type">One of the predefined SceneBlendType blending types.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetSceneBlending(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)">
            <summary>
               Allows very fine control of blending this Pass with the existing contents of the scene.
            </summary>
            <remarks>
               Wheras the texture blending operations seen in the TextureUnitState class are concerned with
               blending between texture layers, this blending is about combining the output of the material
               as a whole with the existing contents of the rendering target. This blending therefore allows
               object transparency and other special effects.
               <p/>
               This version of the method allows complete control over the blending operation, by specifying the
               source and destination blending factors. The result of the blending operation is:
               <span align="center">
               final = (texture * sourceFactor) + (pixel * destFactor)
               </span>
               <p/>
               Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor
               enumerated type.
               <p/>
               This method is applicable for both the fixed-function and programmable pipelines.
            </remarks>
            <param name="src">The source factor in the above calculation, i.e. multiplied by the texture color components.</param>
            <param name="dest">The destination factor in the above calculation, i.e. multiplied by the pixel color components.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFragmentProgram(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFragmentProgram(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="resetParams"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetGeometryProgram(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetGeometryProgram(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="resetParams"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetShadowCasterFragmentProgram(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetShadowReceiverFragmentProgram(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetVertexProgram(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetVertexProgram(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="resetParams"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetShadowCasterVertexProgram(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetShadowReceiverVertexProgram(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.Split(System.Int32)">
            <summary>
               Splits this Pass to one which can be handled in the number of
               texture units specified.
            </summary>
            <param name="numUnits">
               The target number of texture units.
            </param>
            <returns>
               A new Pass which contains the remaining units, and a scene_blend
               setting appropriate to approximate the multitexture. This Pass will be 
               attached to the parent Technique of this Pass.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.Unload">
            <summary>
               Internal method for unloaded this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.DirtyHash">
            <summary>
            	Mark the hash for this pass as dirty.	
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.QueueForDeletion">
            <summary>
            	Queue this pass for deletion when appropriate.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.ProcessPendingUpdates">
            <summary>
            	Process all dirty and pending deletion passes.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.GetHashCode">
            <summary>
               Gets the 'hash' of this pass, ie a precomputed number to use for sorting.
            </summary>
            <remarks>
               This hash is used to sort passes, and for this reason the pass is hashed
               using firstly its index (so that all passes are rendered in order), then
               by the textures which it's TextureUnitState instances are using.
            </remarks>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.Pass.DirtyList">
            <summary>
            	Gets a list of dirty passes.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.GraveyardList">
            <summary>
            	Gets a list of passes queued for deletion.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Parent">
            <summary>
               Gets a reference to the Technique that owns this pass.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Index">
            <summary>
               Gets the index of this Pass in the parent Technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Name">
            <summary>
                Name of this pass (or the index if it isn't set)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Ambient">
            <summary>
               Sets the ambient color reflectance properties of this pass.
            </summary>
            <remarks>
               The base color of a pass is determined by how much red, green and blue light is reflects
               (provided texture layer #0 has a blend mode other than LayerBlendOperation.Replace). 
               This property determines how much ambient light (directionless global light) is reflected. 
               The default is full white, meaning objects are completely globally illuminated. Reduce this 
               if you want to see diffuse or specular light effects, or change the blend of colors to make 
               the object have a base color other than white.
               <p/>
               This setting has no effect if dynamic lighting is disabled (see <see cref="P:Axiom.Graphics.Pass.LightingEnabled"/>),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.Diffuse">
            <summary>
               Sets the diffuse color reflectance properties of this pass.
            </summary>
            <remarks>
               The base color of a pass is determined by how much red, green and blue light is reflects
               (provided texture layer #0 has a blend mode other than LayerBlendOperation.Replace). This property determines how
               much diffuse light (light from instances of the Light class in the scene) is reflected. The default
               is full white, meaning objects reflect the maximum white light they can from Light objects.
               <p/>
               This setting has no effect if dynamic lighting is disabled (see <see cref="P:Axiom.Graphics.Pass.LightingEnabled"/>),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.Specular">
            <summary>
               Sets the specular color reflectance properties of this pass.
            </summary>
            <remarks>
               The base color of a pass is determined by how much red, green and blue light is reflects
               (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
               much specular light (highlights from instances of the Light class in the scene) is reflected.
               The default is to reflect no specular light.
               <p/>
               The size of the specular highlights is determined by the separate Shininess property.
               <p/>
               This setting has no effect if dynamic lighting is disabled (see <see cref="P:Axiom.Graphics.Pass.LightingEnabled"/>),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.Emissive">
            <summary>
            Emissive color in fixed function passes.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.SelfIllumination">
            <summary>
            Emissive color in fixed function passes.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Shininess">
            <summary>
               Sets the shininess of the pass, affecting the size of specular highlights.
            </summary>
            <remarks>
               This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexColorTracking">
            <summary>
               Color parameters that should track the vertex color for fixed function passes.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.SourceBlendFactor">
            <summary>
               Retrieves the source blending factor for the material (as set using SetSceneBlending).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.DestinationBlendFactor">
            <summary>
               Retrieves the destination blending factor for the material (as set using SetSceneBlending).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthCheck">
            <summary>
               Gets/Sets whether or not this pass renders with depth-buffer checking on or not.
            </summary>
            <remarks>
               If depth-buffer checking is on, whenever a pixel is about to be written to the frame buffer
               the depth buffer is checked to see if the pixel is in front of all other pixels written at that
               point. If not, the pixel is not written.
               <p/>
               If depth checking is off, pixels are written no matter what has been rendered before.
               Also see <see cref="P:Axiom.Graphics.Pass.DepthFunction"/> for more advanced depth check configuration.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthWrite">
            <summary>
               Gets/Sets whether or not this pass renders with depth-buffer writing on or not.
            </summary>
            <remarks>
               If depth-buffer writing is on, whenever a pixel is written to the frame buffer
               the depth buffer is updated with the depth value of that new pixel, thus affecting future
               rendering operations if future pixels are behind this one.
               <p/>
               If depth writing is off, pixels are written without updating the depth buffer. Depth writing should
               normally be on but can be turned off when rendering static backgrounds or when rendering a collection
               of transparent objects at the end of a scene so that they overlap each other correctly.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthFunction">
            <summary>
               Gets/Sets the function used to compare depth values when depth checking is on.
            </summary>
            <remarks>
               If depth checking is enabled (see <see cref="P:Axiom.Graphics.Pass.DepthCheck"/>) a comparison occurs between the depth
               value of the pixel to be written and the current contents of the buffer. This comparison is
               normally CompareFunction.LessEqual, i.e. the pixel is written if it is closer (or at the same distance)
               than the current contents. If you wish, you can change this comparison using this method.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthBiasConstant">
            <summary>
            Returns the current DepthBiasConstant value for this pass.
            </summary>
            <remarks>Use <see cref="M:Axiom.Graphics.Pass.SetDepthBias(System.Single,System.Single)"/> to set this property</remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthBiasSlopeScale">
            <summary>
            Returns the current DepthBiasSlopeScale value for this pass.
            </summary>
            <remarks>Use <see cref="M:Axiom.Graphics.Pass.SetDepthBias(System.Single,System.Single)"/> to set this property</remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.ColorWriteEnabled">
            <summary>
               Sets whether or not color buffer writing is enabled for this Pass.
            </summary>
            <remarks>
               For some effects, you might wish to turn off the color write operation
               when rendering geometry; this means that only the depth buffer will be
               updated (provided you have depth buffer writing enabled, which you 
               probably will do, although you may wish to only update the stencil
               buffer for example - stencil buffer state is managed at the RenderSystem
               level only, not the Material since you are likely to want to manage it 
               at a higher level).
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.AlphaRejectFunction">
            <summary>
            The comparison which must pass for the pixel to be written.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.AlphaRejectValue">
            <summary>
            value against which alpha values will be tested [(0-255]
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsAlphaToCoverageEnabled">
            <summary>
            Whether to use alpha to coverage (A2C) when blending alpha rejected values
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.CullingMode">
            <summary>
               Sets the culling mode for this pass based on the 'vertex winding'.
            </summary>
            <remarks>
               A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of
               triangles. Vertex winding refers to the direction in which the vertices are passed or indexed
               to in the rendering operation as viewed from the camera, and will wither be clockwise or
               counterclockwise. The default is Clockwise i.e. that only triangles whose vertices are passed/indexed in 
               counter-clockwise order are rendered - this is a common approach and is used in 3D studio models for example. 
               You can alter this culling mode if you wish but it is not advised unless you know what you are doing.
               <p/>
               You may wish to use the CullingMode.None option for mesh data that you cull yourself where the vertex
               winding is uncertain.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.ManualCullingMode">
            <summary>
               Sets the manual culling mode, performed by CPU rather than hardware.
            </summary>
            <remarks>
               In some situations you want to use manual culling of triangles rather than sending the
               triangles to the hardware and letting it cull them. This setting only takes effect on SceneManager's
               that use it (since it is best used on large groups of planar world geometry rather than on movable
               geometry since this would be expensive), but if used can cull geometry before it is sent to the
               hardware.
            </remarks>
            <value>
               The default for this setting is ManualCullingMode.Back.
            </value>
        </member>
        <member name="P:Axiom.Graphics.Pass.LightingEnabled">
            <summary>
               Sets whether or not dynamic lighting is enabled.
            </summary>
            <remarks>
               If true, dynamic lighting is performed on geometry with normals supplied, geometry without
               normals will not be displayed.
               If false, no lighting is applied and all geometry will be full brightness.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.MaxSimultaneousLights">
            <summary>
               Sets the maximum number of lights to be used by this pass. 
            </summary>
            <remarks>
               During rendering, if lighting is enabled (or if the pass uses an automatic
               program parameter based on a light) the engine will request the nearest lights 
               to the object being rendered in order to work out which ones to use. This
               parameter sets the limit on the number of lights which should apply to objects 
               rendered with this pass. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.StartLight">
            <summary>
               Sets the light index that this pass will start at in the light list.
            </summary>
            <remarks>
            Normally the lights passed to a pass will start from the beginning
            of the light list for this object. This option allows you to make this
            pass start from a higher light index, for example if one of your earlier
            passes could deal with lights 0-3, and this pass dealt with lights 4+. 
            This option also has an interaction with pass iteration, in that
            if you choose to iterate this pass per light too, the iteration will
            only begin from light 4.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.IteratePerLight">
            <summary>
               Does this pass run once for every light in range?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.LightsPerIteration">
            <summary>
            If light iteration is enabled, determine the number of lights per iteration.
            </summary>
            <remarks>
            The default for this setting is 1, so if you enable light iteration
            (<see cref="P:Axiom.Graphics.Pass.IteratePerLight"/>), the pass is rendered once per light. If
            you set this value higher, the passes will occur once per 'n' lights.
            The start of the iteration is set by <see cref="P:Axiom.Graphics.Pass.StartLight"/> and the end
            by <see cref="P:Axiom.Graphics.Pass.MaxSimultaneousLights"/>.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.RunOnlyOncePerLightType">
            <summary>
               Does this pass run only for a single light type (if RunOncePerLight is true). 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.OnlyLightType">
            <summary>
                Gets the single light type this pass runs for if RunOncePerLight and 
                RunOnlyForOneLightType are both true. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.ShadingMode">
            <summary>
               Sets the type of light shading required.
            </summary>
            <value>
               The default shading method is Gouraud shading.
            </value>
        </member>
        <member name="P:Axiom.Graphics.Pass.PolygonMode">
            <summary>
            Sets the type of polygon rendering required
            </summary>
            <remarks>
            The default shading method is Solid
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogOverride">
            <summary>
               Returns true if this pass is to override the scene fog settings.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogMode">
            <summary>
               Returns the fog mode for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogColor">
            <summary>
               Returns the fog color for the scene.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogStart">
            <summary>
               Returns the fog start distance for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogEnd">
            <summary>
               Returns the fog end distance for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogDensity">
            <summary>
               Returns the fog density for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.TextureUnitStageCount">
            <summary>
               Gets the number of fixed function texture unit states for this Pass.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.TextureAnisotropy">
            <summary>
               Sets the anisotropy level to be used for all textures.
            </summary>
            <remarks>
               This property has been moved to the TextureUnitState class, which is accessible via the 
               Technique and Pass. For simplicity, this method allows you to set these properties for 
               every current TeextureUnitState, If you need more precision, retrieve the Technique, 
               Pass and TextureUnitState instances and set the property there.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.TextureFiltering">
            <summary>
               Set texture filtering for every texture unit.
            </summary>
            <remarks>
               This property actually exists on the TextureUnitState class
               For simplicity, this method allows you to set these properties for 
               every current TeextureUnitState, If you need more precision, retrieve the  
               TextureUnitState instance and set the property there.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsProgrammable">
            <summary>
               Returns true if this pass is programmable ie includes either a vertex or fragment program.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasVertexProgram">
            <summary>
               Returns true if this Pass uses the programmable vertex pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexProgram">
            <summary>
               Gets the vertex program used by this pass.
            </summary>
            <remarks>
               Only available after Load() has been called.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexProgramName">
            <summary>
               Gets/Sets the name of the vertex program to use.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level programs.
               <p/>
               This must have been created using GpuProgramManager by the time that 
               this Pass is loaded.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexProgramParameters">
            <summary>
               Gets/Sets the vertex program parameters used by this pass.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level program parameters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasFragmentProgram">
            <summary>
               Returns true if this Pass uses the programmable fragment pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.FragmentProgram">
            <summary>
               Gets the fragment program used by this pass.
            </summary>
            <remarks>
               Only available after Load() has been called.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FragmentProgramName">
            <summary>
               Gets/Sets the name of the fragment program to use.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level programs.
               <p/>
               This must have been created using GpuProgramManager by the time that 
               this Pass is loaded.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FragmentProgramParameters">
            <summary>
               Gets/Sets the fragment program parameters used by this pass.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level program parameters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasGeometryProgram">
            <summary>
               Returns true if this Pass uses the programmable geometry pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.GeometryProgram">
            <summary>
               Gets the geometry program used by this pass.
            </summary>
            <remarks>
               Only available after Load() has been called.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.GeometryProgramName">
            <summary>
               Gets/Sets the name of the geometry program to use.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level programs.
               <p/>
               This must have been created using GpuProgramManager by the time that 
               this Pass is loaded.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.GeometryProgramParameters">
            <summary>
               Gets/Sets the geometry program parameters used by this pass.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level program parameters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasShadowCasterVertexProgram">
            <summary>
               Returns true if this Pass uses the programmable shadow caster vertex pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasShadowCasterFragmentProgram">
            <summary>
               Returns true if this Pass uses the programmable shadow caster fragment pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasShadowReceiverVertexProgram">
            <summary>
               Returns true if this Pass uses the programmable shadow receiver vertex pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasShadowReceiverFragmentProgram">
            <summary>
               Returns true if this Pass uses the programmable shadow receiver fragment pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IterationCount">
            <summary>
            the number of iterations that this pass should perform when doing fast multi pass operation.
            </summary>
            <remarks>
            Only applicable for programmable passes.
            A value greater than 1 will cause the pass to be executed count number of
            times without changing the render state.  This is very usefull for passes
            that use programmable shaders that have to iterate more than once but don't
            need a render state change.  Using multi pass can dramatically speed up rendering
            for materials that do things like fur, blur.
            A value of 1 turns off multi pass operation and the pass does
            the normal pass operation.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsAmbientOnly">
            <summary>
            	Gets a flag indicating whether this pass is ambient only.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsLoaded">
            <summary>
               Returns true if this pass is loaded.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsTransparent">
            <summary>
               Returns true if this pass has some element of transparency.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IlluminationPass">
            <summary>
            	Struct recording a pass which can be used for a specific illumination stage.
            </summary>
            <remarks>
            	This structure is used to record categorized passes which fit into a 
            	number of distinct illumination phases - ambient, diffuse / specular 
            	(per-light) and decal (post-lighting texturing).
            	An original pass may fit into one of these categories already, or it
            	may require splitting into its component parts in order to be categorized 
            	properly.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.Stage">
            <summary>
            	The stage at which this pass is relevant.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.Pass">
            <summary>
            	The pass to use in this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.DestroyOnShutdown">
            <summary>
            	Whether this pass is one which should be deleted itself.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.OriginalPass">
            <summary>
            	The original pass which spawned this one.
            </summary>
        </member>
        <member name="T:Axiom.Core.SubEntity">
            <summary>
            	Utility class which defines the sub-parts of an Entity.
            </summary>
            <remarks>
            	<para>
            	Just as models are split into meshes, an Entity is made up of
            	potentially multiple SubEntities. These are mainly here to provide the
            	link between the Material which the SubEntity uses (which may be the
            	default Material for the SubMesh or may have been changed for this
            	object) and the SubMesh data.
            	</para>
            	<para>
            	SubEntity instances are never created manually. They are created at
            	the same time as their parent Entity by the SceneManager method
            	CreateEntity.
            	</para>
            </remarks>
        </member>
        <member name="F:Axiom.Core.SubEntity.parent">
            <summary>
               Reference to the parent Entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.materialName">
            <summary>
               Name of the material being used.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.material">
            <summary>
               Reference to the material being used by this SubEntity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.subMesh">
            <summary>
               Reference to the subMesh that represents the geometry for this SubEntity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.isVisible">
            <summary>
            	Flag indicating whether this sub entity should be rendered or not.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.skelAnimVertexData">
            <summary>
            	Blend buffer details for dedicated geometry.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.tempSkelAnimInfo">
            <summary>
            	Temp buffer details for software skeletal anim geometry
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.tempVertexAnimInfo">
            <summary>
            	Temp buffer details for software Vertex anim geometry
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.softwareVertexAnimVertexData">
            <summary>
            	Vertex data details for software Vertex anim of shared geometry
            </summary>
            Temp buffer details for software Vertex anim geometry
        </member>
        <member name="F:Axiom.Core.SubEntity.hardwareVertexAnimVertexData">
            <summary>
                Vertex data details for hardware Vertex anim of shared geometry
                - separate since we need to s/w anim for shadows whilst still altering
                  the vertex data for hardware morphing (pos2 binding)
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.vertexAnimationAppliedThisFrame">
            <summary>
            	Have we applied any vertex animation to geometry?
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.hardwarePoseCount">
            <summary>
            	Number of hardware blended poses supported by material
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.hardwareSkinningEnabled">
            <summary>
            	Flag indicating whether hardware skinning is supported by this subentity's materials.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.useVertexProgram">
            <summary>
            	Flag indicating whether vertex programs are used by this subentity's materials.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.#ctor">
            <summary>
            	Internal constructor, only allows creation of SubEntities within the engine core.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.PrepareTempBlendBuffers">
            <summary>
            	Internal method for preparing this sub entity for use in animation.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity._materialLodIndex">
            <summary>
            current LOD index to use.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.GetWorldTransforms(Axiom.Math.Matrix4[])">
             <summary>
            
             </summary>
             <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.SubEntity.GetSquaredViewDepth(Axiom.Core.Camera)">
             <summary>
            
             </summary>
             <param name="camera"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.SubEntity.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Core.SubEntity.IsVisible">
            <summary>
            	Gets a flag indicating whether or not this sub entity should be rendered or not.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Name">
            <summary>
            Name of this SubEntity.
            It is the name of the associated SubMesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.MaterialName">
            <summary>
            	Gets/Sets the name of the material used for this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.SubMesh">
            <summary>
            	Gets/Sets the subMesh to be used for rendering this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Parent">
            <summary>
            	Gets/Sets the parent entity of this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.BuffersMarkedForAnimation">
            <summary>
            	Are buffers already marked as vertex animated?
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Material">
            <summary>
            	Gets/Sets a reference to the material being used by this SubEntity.
            </summary>
            <remarks>
            	By default, the SubEntity will use the material defined by the SubMesh.  However,
            	this can be overridden by the SubEntity in the case where several entities use the
            	same SubMesh instance, but want to shade it different.
                This should probably call parent.ReevaluateVertexProcessing.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SubEntity.RenderOperation">
             <summary>
            
             </summary>
             <param name="value"></param>
        </member>
        <member name="P:Axiom.Core.SubEntity.NumWorldTransforms">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.UseIdentityProjection">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.UseIdentityView">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.WorldOrientation">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.WorldPosition">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Lights">
             <summary>
            
             </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.HardwareSkinningEnabled">
            <summary>
            	Returns whether or not hardware skinning is enabled.
            </summary>
            <remarks>
            	Because fixed-function indexed vertex blending is rarely supported
            	by existing graphics cards, hardware skinning can only be done if
            	the vertex programs in the materials used to render an entity support
            	it. Therefore, this method will only return true if all the materials
            	assigned to this entity have vertex programs assigned, and all those
            	vertex programs must support 'include_skeletal_animation true'.
            </remarks>
        </member>
        <member name="T:Axiom.Animating.VertexAnimationType">
            <summary>
            	Types of vertex animations
            </summary>
        </member>
        <member name="F:Axiom.Animating.VertexAnimationType.None">
            No animation
        </member>
        <member name="F:Axiom.Animating.VertexAnimationType.Morph">
            Morph animation is made up of many interpolated snapshot keyframes
        </member>
        <member name="F:Axiom.Animating.VertexAnimationType.Pose">
            Pose animation is made up of a single delta pose keyframe
        </member>
        <member name="T:Axiom.Animating.VertexDataBindChoice">
            <summary>
            	Identify which vertex data we should be sending to the renderer
            </summary>
        </member>
        <member name="T:Axiom.Animating.VertexAnimationTargetMode">
            <summary>
            	Do we do vertex animation in hardware or software?
            </summary>
        </member>
        <member name="F:Axiom.Animating.VertexAnimationTargetMode.Software">
            In software
        </member>
        <member name="F:Axiom.Animating.VertexAnimationTargetMode.Hardware">
            In hardware
        </member>
        <member name="T:Axiom.Animating.SkeletalAnimBlendMode">
            <summary>
            	Used to specify how animations are applied to a skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletalAnimBlendMode.Average">
            <summary>
            	Animations are applied by calculating a weighted average of all animations.
             </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletalAnimBlendMode.Cumulative">
            <summary>
            	Animations are applied by calculating a weighted cumulative total.
            </summary>
        </member>
        <member name="T:Axiom.Math.Tuple`2">
            <summary>
            Represents two related values
            </summary>
        </member>
        <member name="F:Axiom.Math.Tuple`2.First">
            <summary></summary>
        </member>
        <member name="F:Axiom.Math.Tuple`2.Second">
            <summary></summary>
        </member>
        <member name="T:Axiom.Math.Tuple`3">
            <summary>
            Represents three related values
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
            <typeparam name="C"></typeparam>
        </member>
        <member name="F:Axiom.Math.Tuple`3.First">
            <summary></summary>
        </member>
        <member name="F:Axiom.Math.Tuple`3.Second">
            <summary></summary>
        </member>
        <member name="F:Axiom.Math.Tuple`3.Third">
            <summary></summary>
        </member>
        <member name="T:Axiom.Math.Tuple`4">
            <summary>
            Represents four related values
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
            <typeparam name="C"></typeparam>
            <typeparam name="D"></typeparam>
        </member>
        <member name="F:Axiom.Math.Tuple`4.First">
            <summary></summary>
        </member>
        <member name="F:Axiom.Math.Tuple`4.Second">
            <summary></summary>
        </member>
        <member name="F:Axiom.Math.Tuple`4.Third">
            <summary></summary>
        </member>
        <member name="F:Axiom.Math.Tuple`4.Fourth">
            <summary></summary>
        </member>
        <member name="T:Axiom.Math.Degree">
            <summary>
            Wrapper class which indicates a given angle value is in Radian.
            </summary>
            <remarks>
            Degree values are interchangeable with Radian values, and conversions
            will be done automatically between them.
            </remarks>
        </member>
        <member name="M:Axiom.Core.IWindowEventListener.WindowMoved(Axiom.Graphics.RenderWindow)">
            <summary>
            Window has moved position
            </summary>
            <param name="rw">The RenderWindow which created this event</param>
        </member>
        <member name="M:Axiom.Core.IWindowEventListener.WindowResized(Axiom.Graphics.RenderWindow)">
            <summary>
            Window has resized
            </summary>
            <param name="rw">The RenderWindow which created this event</param>
        </member>
        <member name="M:Axiom.Core.IWindowEventListener.WindowClosed(Axiom.Graphics.RenderWindow)">
            <summary>
            Window has closed
            </summary>
            <param name="rw">The RenderWindow which created this event</param>
        </member>
        <member name="M:Axiom.Core.IWindowEventListener.WindowFocusChange(Axiom.Graphics.RenderWindow)">
            <summary>
            Window lost/regained the focus
            </summary>
            <param name="rw">The RenderWindow which created this event</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.RegisterListener(Axiom.Graphics.RenderWindow,Axiom.Core.IWindowEventListener)">
            <summary>
            Add a listener to listen to renderwindow events (multiple listener's per renderwindow is fine)
            The same listener can listen to multiple windows, as the Window Pointer is sent along with
            any messages.
            </summary>
            <param name="window">The RenderWindow you are interested in monitoring</param>
            <param name="listener">Your callback listener</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.UnregisterListener(Axiom.Graphics.RenderWindow,Axiom.Core.IWindowEventListener)">
            <summary>
            Remove previously added listener
            </summary>
            <param name="window">The RenderWindow you registered with</param>
            <param name="listener">The listener registered</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.RegisterWindow(Axiom.Graphics.RenderWindow)">
            <summary>
            Called by RenderWindows upon creation for Ogre generated windows. You are free to add your
            external windows here too if needed.
            </summary>
            <param name="window">The RenderWindow to monitor</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.UnregisterWindow(Axiom.Graphics.RenderWindow)">
            <summary>
            Called by RenderWindows upon destruction for Ogre generated windows. You are free to remove your
            external windows here too if needed.
            </summary>
            <param name="window">The RenderWindow to remove from list</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.WindowFocusChange(Axiom.Graphics.RenderWindow,System.Boolean)">
            <summary>
            Window has either gained or lost the focus
            </summary>
            <param name="window">RenderWindow that caused the event</param>
            <param name="hasFocus">True if window has focus</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.WindowMoved(Axiom.Graphics.RenderWindow)">
            <summary>
            Window has moved position
            </summary>
            <param name="window">RenderWindow that caused the event</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.WindowResized(Axiom.Graphics.RenderWindow)">
            <summary>
            Window has changed size
            </summary>
            <param name="window">RenderWindow that caused the event</param>
        </member>
        <member name="M:Axiom.Core.WindowEventMonitor.WindowClosed(Axiom.Graphics.RenderWindow)">
            <summary>
            Window has closed
            </summary>
            <param name="window">RenderWindow that caused the event</param>
        </member>
        <member name="P:Axiom.Core.WindowEventMonitor.Instance">
            <summary>
            Singleton Instance of the class
            </summary>
        </member>
        <member name="T:Axiom.Core.WindowEventMonitor.MessagePumpDelegate">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Core.SpecialCaseRenderQueueMode">
            <summary>
            Enumeration of the possible modes allowed for processing the special case render queue list.
            <see cref="P:Axiom.Core.SpecialCaseRenderQueue.RenderQueueMode"/>
            </summary>
        </member>
        <member name="F:Axiom.Core.SpecialCaseRenderQueueMode.Include">
            <summary>
            Render only the queues in the special case list
            </summary>
        </member>
        <member name="F:Axiom.Core.SpecialCaseRenderQueueMode.Exclude">
            <summary>
            Render all except the queues in the special case list
            </summary>
        </member>
        <member name="M:Axiom.Core.SpecialCaseRenderQueue.AddRenderQueue(Axiom.Core.RenderQueueGroupID)">
            <summary>
            Adds an item to the 'special case' render queue list.
            </summary>
            <remarks>Normally all render queues are rendered, in their usual sequence,
            only varying if a RenderQueueListener nominates for the queue to be
            repeated or skipped. This method allows you to add a render queue to
            a 'special case' list, which varies the behaviour. The effect of this
            list depends on the 'mode' in which this list is in, which might be
            to exclude these render queues, or to include them alone (excluding
            all other queues). This allows you to perform broad selective
            rendering without requiring a RenderQueueListener.</remarks>
            <param name="queueId">The identifier of the queue which should be added to the
             special case list. Nothing happens if the queue is already in the list.</param>
        </member>
        <member name="M:Axiom.Core.SpecialCaseRenderQueue.RemoveRenderQueue(Axiom.Core.RenderQueueGroupID)">
            <summary>
            Removes an item to the 'special case' render queue list
            </summary>
            <param name="queueId">The identifier of the queue which should be removed from the
            special case list. Nothing happens if the queue is not in the list.</param>
        </member>
        <member name="M:Axiom.Core.SpecialCaseRenderQueue.ClearRenderQueues">
            <summary>
            Clears the 'special case' render queue list.
            </summary>
        </member>
        <member name="M:Axiom.Core.SpecialCaseRenderQueue.IsRenderQueueToBeProcessed(Axiom.Core.RenderQueueGroupID)">
            <summary>
            Returns whether or not the named queue will be rendered based on the
            current 'special case' render queue list and mode.
            </summary>
            <param name="queueId">The identifier of the queue which should be tested</param>
            <returns>true if the queue will be rendered, false otherwise</returns>
        </member>
        <member name="P:Axiom.Core.SpecialCaseRenderQueue.RenderQueueMode">
            <summary>
            Gets the way the special case render queue list is processed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.SceneManagerDefaultFactory">
            <summary>
            	Factory for default scene manager.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultSceneManager">
            <summary>
            	Default scene manager.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneManagerEnumerator">
            <summary>
                Enumerates the <see cref="T:Axiom.Core.SceneManager"/> classes available to applications.
            </summary>
            <remarks>
            	As described in the SceneManager class, SceneManagers are responsible
                for organising the scene and issuing rendering commands to the
                <see cref="T:Axiom.Graphics.RenderSystem"/>. Certain scene types can benefit from different
                rendering approaches, and it is intended that subclasses will
                be created to special case this.
            <p/>
                In order to give applications easy access to these implementations,
                this class has a number of methods to create or retrieve a SceneManager
                which is appropriate to the scene type.
            <p/>
            	SceneManagers are created by <see cref="T:Axiom.Core.SceneManagerFactory"/> instances. New factories
            	for new types of SceneManager can be registered with this class to make
            	them available to clients.
            <p/>
            	Note that you can still plug in your own custom SceneManager without
            	using a factory, should you choose, it's just not as flexible that way.
            	Just instantiate your own SceneManager manually and use it directly.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.AddFactory(Axiom.Core.SceneManagerFactory)">
            <summary>
            	Registers a new <see cref="T:Axiom.Core.SceneManagerFactory"/>.
            </summary>
            <remarks>
            	Plugins should call this to register as new <see cref="T:Axiom.Core.SceneManager"/> providers.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.RemoveFactory(Axiom.Core.SceneManagerFactory)">
            <summary>
            		Removes a <see cref="T:Axiom.Core.SceneManagerFactory"/>.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.CreateSceneManager(Axiom.Core.SceneType,System.String)">
            <summary>
            	Creates a SceneManager instance based on scene type support.
            </summary>
            <remarks>
            	Creates an instance of a SceneManager which supports the scene types
            	identified in the parameter. If more than one type of SceneManager
            	has been registered as handling that combination of scene types,
            	in instance of the last one registered is returned.
            <p/>
            	Note that this method always succeeds, if a specific scene manager is not
            	found, the default implementation is always returned.
            </remarks>
            <param name="sceneType">A mask containing one or more <see cref="T:Axiom.Core.SceneType"/> flags.</param>
            <param name="instanceName">
            	Optional name to given the new instance that is created.
            	If you leave this blank, an auto name will be assigned.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.CreateSceneManager(System.String,System.String)">
            <summary>
            	Creates a SceneManager instance of a given type.
            </summary>
            <remarks>
            	You can use this method to create a SceneManager instance of a
            	given specific type. You may know this type already, or you may
            	have discovered it by looking at the results from <see cref="P:Axiom.Core.SceneManagerEnumerator.MetaDataList"/>.
            </remarks>
            <param name="typeName">String identifying a unique SceneManager type.</param>
            <param name="instanceName">
            	Optional name to given the new instance that is
            	created. If you leave this blank, an auto name will be assigned.
            </param>
            <exception cref="T:Axiom.Core.AxiomException">
            	This method throws an exception if the named type is not found.
            </exception>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.DestroySceneManager(Axiom.Core.SceneManager)">
            <summary>
            	Destroys an instance of a SceneManager.
            </summary>
            <param name="sm"></param>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.GetSceneManager(System.String)">
            <summary>
            	Gets an existing SceneManager instance that has already been created,
            	identified by the instance name.
            </summary>
            <param name="instanceName"> The name of the instance to retrieve.</param>
            <exception cref="T:Axiom.Core.AxiomException">If the instance can't be retrieved.</exception>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.GetMetaData(System.String)">
            <summary>
            	Gets more information about a given type of SceneManager.
            </summary>
            <remarks>
            	The metadata returned tells you a few things about a given type
            	of SceneManager, which can be created using a factory that has been
            	registered already.
            </remarks>
            <param name="typeName">
            	The type name of the SceneManager you want to enquire on.
            	If you don't know the typeName already, you can iterate over the
            	metadata for all types using getMetaDataIterator.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.ShutdownAll">
            <summary>
            		Shuts down all registered scene managers.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManagerEnumerator.RenderSytem">
            <summary>
            	Notifies all SceneManagers of the destination rendering system.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManagerEnumerator.MetaDataList">
            <summary>
            	A list of all types of SceneManager available for construction,
            	providing some information about each one.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManagerEnumerator.SceneManagerList">
            <summary>
            	A list of all types of SceneManager available for construction,
            	providing some information about each one.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Collections.AnimationCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Animating.Animation">Animations</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.OgreSkeletonSerializer">
            <summary>
            	Summary description for OgreSkeletonSerializer.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonSerializer.ReadAnimation(System.IO.BinaryReader)">
            <summary>
               Reads animation information from the file.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonSerializer.ReadAnimationTrack(System.IO.BinaryReader,Axiom.Animating.Animation)">
            <summary>
               Reads an animation track.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonSerializer.ReadBone(System.IO.BinaryReader)">
            <summary>
               Reads bone information from the file.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonSerializer.ReadBoneParent(System.IO.BinaryReader)">
            <summary>
               Reads bone information from the file.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonSerializer.ReadKeyFrame(System.IO.BinaryReader,Axiom.Animating.NodeAnimationTrack)">
            <summary>
               Reads an animation track section.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonSerializer.ReadAttachmentPoint(System.IO.BinaryReader)">
            <summary>
               Reads bone information from the file.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.SkeletonChunkID">
            <summary>
               Chunk ID's that can be found within the Ogre .skeleton format.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexBufferLicense">
            <summary>
            	Structure holding details of a license to use a temporary shared buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferLicense.#ctor(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,System.Int32,Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.IHardwareBufferLicensee)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.PluginException">
            <summary>
            Summary description for PluginException.
            </summary>
        </member>
        <member name="T:Axiom.Core.PatchMesh">
            <summary>
                Patch specialization of <see cref="T:Axiom.Core.Mesh"/>.
            </summary>
            <remarks>
                Instances of this class should be created by calling
                <see cref="M:Axiom.Core.MeshManager.CreateBezierPatch(System.String,System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Mesh">
            <summary>
               Resource holding data about a 3D mesh.
            </summary>
            <remarks>
               This class holds the data used to represent a discrete
               3-dimensional object. Mesh data usually contains more
               than just vertices and triangle information; it also
               includes references to materials (and the faces which use them),
               level-of-detail reduction information, convex hull definition,
               skeleton/bones information, keyframe animation etc.
               However, it is important to note the emphasis on the word
               'discrete' here. This class does not cover the large-scale
               sprawling geometry found in level / landscape data.
               <p/>
               Multiple world objects can (indeed should) be created from a
               single mesh object - see the Entity class for more info.
               The mesh object will have its own default
               material properties, but potentially each world instance may
               wish to customize the materials from the original. When the object
               is instantiated into a scene node, the mesh material properties
               will be taken by default but may be changed. These properties
               are actually held at the SubMesh level since a single mesh may
               have parts with different materials.
               <p/>
               As described above, because the mesh may have sections of differing
               material properties, a mesh is inherently a compound construct,
               consisting of one or more SubMesh objects.
               However, it strongly 'owns' its SubMeshes such that they
               are loaded / unloaded at the same time. This is contrary to
               the approach taken to hierarchically related (but loosely owned)
               scene nodes, where data is loaded / unloaded separately. Note
               also that mesh sub-sections (when used in an instantiated object)
               share the same scene node as the parent.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Mesh._sharedVertexData">
            <summary>
            	Shared vertex data between multiple meshes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._subMeshList">
            <summary>
            	Collection of sub meshes for this mesh.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._boundingBox">
            <summary>
            	Local bounding box of this mesh.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._boundingSphereRadius">
            <summary>
            	Radius of this mesh's bounding sphere.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._skeleton">
            <summary>Reference to the skeleton bound to this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh._skeletonName">
            <summary>Name of the skeleton bound to this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh._boneAssignmentList">
            <summary>List of bone assignment for this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.boneAssignmentsOutOfDate">
            <summary>Flag indicating that bone assignments need to be recompiled.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.numBlendWeightsPerVertex">
            <summary>Number of blend weights that are assigned to each vertex.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.useSoftwareBlending">
            <summary>Option whether to use software or hardware blending, there are tradeoffs to both.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh._vertexBufferUsage">
            <summary>
            	Usage type for the vertex buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._indexBufferUsage">
            <summary>
            	Usage type for the index buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._useVertexShadowBuffer">
            <summary>
            	Use a shadow buffer for the vertex data?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._useIndexShadowBuffer">
            <summary>
            	Use a shadow buffer for the index data?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._isPreparedForShadowVolumes">
            <summary>
            	Flag indicating whether precalculation steps to support shadows have been taken.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._autoBuildEdgeLists">
            <summary>
            	Should edge lists be automatically built for this mesh?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._edgeListsBuilt">
            <summary>
                Have the edge lists been built for this mesh yet?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._attachmentPoints">
            <summary>Internal list of named transforms attached to this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh._animationsList">
            <summary>
                Storage of morph animations, lookup by name
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._sharedVertexDataAnimationType">
            <summary>
                The vertex animation type associated with the shared vertex data
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._animationTypesDirty">
            <summary>
                Do we need to scan animations for animation types?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._poseList">
            <summary>
                List of available poses for shared and dedicated geometryPoseList
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh._triangleIntersector">
            <summary>
                A list of triangles, plus machinery to determine the closest intersection point
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.GetEdgeList">
            <summary>
            	Gets the edge list for this mesh, building it if required.
            </summary>
            <returns>The edge list for mesh LOD 0.</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetEdgeList(System.Int32)">
            <summary>
            	Gets the edge list for this mesh, building it if required.
            </summary>
            <remarks>
            	You must ensure that the Mesh as been prepared for shadow volume
            	rendering if you intend to use this information for that purpose.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.AddBoneAssignment(Axiom.Animating.VertexBoneAssignment)">
            <summary>
               Assigns a vertex to a bone with a given weight, for skeletal animation.
            </summary>
            <remarks>
               This method is only valid after setting SkeletonName.
               You should not need to modify bone assignments during rendering (only the positions of bones)
               and the engine reserves the right to do some internal data reformatting of this information,
               depending on render system requirements.
            </remarks>
            <param name="boneAssignment">Bone assignment to add.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.AddVertexAndIndexSets(Axiom.Graphics.AnyBuilder,System.Int32)">
            <summary>
               Adds the vertex and index sets necessary for a builder instance
               to iterate over the triangles in a mesh
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.BuildEdgeList">
            <summary>
            	Builds an edge list for this mesh, which can be used for generating a shadow volume
            	among other things.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateTriangleIntersector">
            <summary>
                Create the list of triangles used to query mouse hits
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.BuildTangentVectors(System.Int16,System.Int16)">
            <summary>
                Builds tangent space vector required for accurate bump mapping.
            </summary>
            <remarks>
               Adapted from bump mapping tutorials at:
               http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
               author : paul.baker@univ.ox.ac.uk
               <p/>
               Note: Only the tangent vector is calculated, it is assumed the binormal
               will be calculated in a vertex program.
            </remarks>
            <param name="sourceTexCoordSet">Source texcoord set that holds the current UV texcoords.</param>
            <param name="destTexCoordSet">Destination texcoord set to hold the tangent vectors.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.BuildTangentVectors">
            <summary>
                Builds tangent space vector required for accurate bump mapping.
            </summary>
            <remarks>
               Adapted from bump mapping tutorials at:
               http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
               author : paul.baker@univ.ox.ac.uk
               <p/>
               Note: Only the tangent vector is calculated, it is assumed the binormal
               will be calculated in a vertex program.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.ClearBoneAssignments">
            <summary>
               Removes all bone assignments for this mesh.
            </summary>
            <remarks>
               This method is for modifying weights to the shared geometry of the Mesh. To assign
               weights to the per-SubMesh geometry, see the equivalent methods on SubMesh.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.CompileBoneAssignments">
            <summary>
               Compile bone assignments into blend index and weight buffers.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.CompileBoneAssignments(System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{Axiom.Animating.VertexBoneAssignment}},System.Int32,Axiom.Graphics.VertexData)">
            <summary>
               Software blending oriented bone assignment compilation.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.OrganizeTangentsBuffer(Axiom.Graphics.VertexData,System.Int16)">
            <summary>
               Internal method for making the space for a 3D texture coord buffer to hold tangents.
            </summary>
            <param name="vertexData">Target vertex data.</param>
            <param name="destCoordSet">Destination texture coordinate set.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.SuggestTangentVectorBuildParams(System.Int16@,System.Int16@)">
            <summary>
                Ask the mesh to suggest parameters to a future <see cref="M:Axiom.Core.Mesh.BuildTangentVectors"/> call.
            </summary>
            <remarks>
                This helper method will suggest source and destination texture coordinate sets
                for a call to <see cref="M:Axiom.Core.Mesh.BuildTangentVectors"/>. It will detect when there are inappropriate
                conditions (such as multiple geometry sets which don't agree).
                Moreover, it will return 'true' if it detects that there are aleady 3D
                coordinates in the mesh, and therefore tangents may have been prepared already.
            </remarks>
            <param name="sourceCoordSet">A source texture coordinate set which will be populated.</param>
            <param name="destCoordSet">A destination texture coordinate set which will be populated.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.GetSubMesh(System.Int32)">
            <summary>
               Gets the sub mesh at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetTrackHandle(System.String)">
            <summary>
              Gets the animation track handle for a named submesh.
            </summary>
            <param name="name">The name of the submesh</param>
            <returns>The track handle to use for animation tracks associated with the give submesh</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetSubMesh(System.String)">
            <summary>
                Gets the sub mesh with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.RemoveSubMesh(System.String)">
            <summary>
               Remove the sub mesh with the given name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.InitAnimationState(Axiom.Animating.AnimationStateSet)">
            <summary>
               Initialize an animation set suitable for use with this mesh.
            </summary>
            <remarks>
               Only recommended for use inside the engine, not by applications.
            </remarks>
            <param name="animSet"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.HasAnimationState(Axiom.Animating.AnimationStateSet,System.String)">
            <summary>Returns whether or not this mesh has some kind of vertex animation.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.ContainsAnimation(System.String)">
            <summary>Returns whether or not this mesh has the named vertex animation.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.NotifySkeleton(Axiom.Animating.Skeleton)">
            <summary>
               Internal notification, used to tell the Mesh which Skeleton to use without loading it.
            </summary>
            <remarks>
               This is only here for unusual situation where you want to manually set up a
               Skeleton. Best to let the engine deal with this, don't call it yourself unless you
               really know what you're doing.
            </remarks>
            <param name="skeleton"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.PrepareForShadowVolume">
            <summary>
            	This method prepares the mesh for generating a renderable shadow volume.
            </summary>
            <remarks>
            	Preparing a mesh to generate a shadow volume involves firstly ensuring that the
            	vertex buffer containing the positions for the mesh is a standalone vertex buffer,
            	with no other components in it. This method will therefore break apart any existing
            	vertex buffers this mesh holds if position is sharing a vertex buffer.
            	Secondly, it will double the size of this vertex buffer so that there are 2 copies of
            	the position data for the mesh. The first half is used for the original, and the second
            	half is used for the 'extruded' version of the mesh. The vertex count of the main
            	<see cref="T:Axiom.Graphics.VertexData"/> used to render the mesh will remain the same though, so as not to add any
            	overhead to regular rendering of the object.
            	Both copies of the position are required in one buffer because shadow volumes stretch
            	from the original mesh to the extruded version.
            	<p/>
            	Because shadow volumes are rendered in turn, no additional
            	index buffer space is allocated by this method, a shared index buffer allocated by the
            	shadow rendering algorithm is used for addressing this extended vertex buffer.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.RationalizeBoneAssignments(System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{Axiom.Animating.VertexBoneAssignment}})">
            <summary>
                Rationalizes the passed in bone assignment list.
            </summary>
            <remarks>
                We support up to 4 bone assignments per vertex. The reason for this limit
                is that this is the maximum number of assignments that can be passed into
                a hardware-assisted blending algorithm. This method identifies where there are
                more than 4 bone assignments for a given vertex, and eliminates the bone
                assignments with the lowest weights to reduce to this limit. The remaining
                weights are then re-balanced to ensure that they sum to 1.0.
            </remarks>
            <param name="vertexCount">The number of vertices.</param>
            <param name="assignments">
                The bone assignment list to rationalize. This list will be modified and
                entries will be removed where the limits are exceeded.
            </param>
            <returns>The maximum number of bone assignments per vertex found, clamped to [1-4]</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateSubMesh(System.String)">
            <summary>
            	Creates a new <see cref="T:Axiom.Core.SubMesh"/> and gives it a name.
            </summary>
            <param name="name">Name of the new <see cref="T:Axiom.Core.SubMesh"/>.</param>
            <returns>A new <see cref="T:Axiom.Core.SubMesh"/> with this Mesh as its parent.</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateSubMesh">
            <summary>
            	Creates a new <see cref="T:Axiom.Core.SubMesh"/>.
            </summary>
            <remarks>
            	Method for manually creating geometry for the mesh.
            	Note - use with extreme caution - you must be sure that
            	you have set up the geometry properly.
            </remarks>
            <returns>A new SubMesh with this Mesh as its parent.</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.SetVertexBufferPolicy(Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Sets the policy for the vertex buffers to be used when loading this Mesh.
            </summary>
            <remarks>
            	By default, when loading the Mesh, static, write-only vertex and index buffers
            	will be used where possible in order to improve rendering performance.
            	However, such buffers
            	cannot be manipulated on the fly by CPU code (although shader code can). If you
            	wish to use the CPU to modify these buffers, you should call this method. Note,
            	however, that it only takes effect after the Mesh has been reloaded. Note that you
            	still have the option of manually repacing the buffers in this mesh with your
            	own if you see fit too, in which case you don't need to call this method since it
            	only affects buffers created by the mesh itself.
            	<p/>
            	You can define the approach to a Mesh by changing the default parameters to
            	<see cref="M:Axiom.Core.MeshManager.Load(System.String,System.String)"/> if you wish; this means the Mesh is loaded with those options
            	the first time instead of you having to reload the mesh after changing these options.
            </remarks>
            <param name="usage">The usage flags, which by default are <see cref="F:Axiom.Graphics.BufferUsage.StaticWriteOnly"/></param>
            <param name="useShadowBuffer">
            	If set to true, the vertex buffers will be created with a
            	system memory shadow buffer. You should set this if you want to be able to
            	read from the buffer, because reading from a hardware buffer is a no-no.
            </param>
        </member>
        <member name="M:Axiom.Core.Mesh.SetIndexBufferPolicy(Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Sets the policy for the index buffers to be used when loading this Mesh.
            </summary>
            <remarks>
            	By default, when loading the Mesh, static, write-only vertex and index buffers
            	will be used where possible in order to improve rendering performance.
            	However, such buffers
            	cannot be manipulated on the fly by CPU code (although shader code can). If you
            	wish to use the CPU to modify these buffers, you should call this method. Note,
            	however, that it only takes effect after the Mesh has been reloaded. Note that you
            	still have the option of manually repacing the buffers in this mesh with your
            	own if you see fit too, in which case you don't need to call this method since it
            	only affects buffers created by the mesh itself.
            	<p/>
            	You can define the approach to a Mesh by changing the default parameters to
            	<see cref="M:Axiom.Core.MeshManager.Load(System.String,System.String)"/> if you wish; this means the Mesh is loaded with those options
            	the first time instead of you having to reload the mesh after changing these options.
            </remarks>
            <param name="usage">The usage flags, which by default are <see cref="F:Axiom.Graphics.BufferUsage.StaticWriteOnly"/></param>
            <param name="useShadowBuffer">
            	If set to true, the index buffers will be created with a
            	system memory shadow buffer. You should set this if you want to be able to
            	read from the buffer, because reading from a hardware buffer is a no-no.
            </param>
        </member>
        <member name="M:Axiom.Core.Mesh.AddManualLodEntries(System.Collections.Generic.List{Axiom.Core.MeshLodUsage})">
            <summary>
              This method is fairly internal, and is used to add new manual lod info
            </summary>
            <param name="manualLodEntries"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateAttachmentPoint(System.String,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
              TODO: should this replace an existing attachment point with the same name?
            </summary>
            <param name="name"></param>
            <param name="rotation"></param>
            <param name="translation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.DetermineAnimationTypes">
            <summary>
                Internal method which, if animation types have not been determined,
                scans any vertex animations and determines the type for each set of
                vertex data (cannot have 2 different types).
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateAnimation(System.String,System.Single)">
            <summary>
                Creates a new Animation object for vertex animating this mesh.
            </summary>
            <param name="name">The name of this animation</param>
            <param name="length">The length of the animation in seconds</param>
        </member>
        <member name="M:Axiom.Core.Mesh.GetAnimation(System.String)">
            <summary>
                Returns the named vertex Animation object.
            </summary>
            <param name="name">The name of the animation</param>
        </member>
        <member name="M:Axiom.Core.Mesh.GetAnimation(System.UInt16)">
            <summary>Gets a single morph animation by index.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.HasAnimation(System.String)">
            <summary>Returns whether this mesh contains the named vertex animation.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.RemoveAnimation(System.String)">
            <summary>Removes vertex Animation from this mesh.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.RemoveAllAnimations">
            <summary>Removes all morph Animations from this mesh.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.GetVertexDataByTrackHandle(System.UInt16)">
            <summary>
                Gets a pointer to a vertex data element based on a morph animation
               	track handle.
            </summary>
            <remarks>
                0 means the shared vertex data, 1+ means a submesh vertex data (index+1)
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.CreatePose(System.UInt16,System.String)">
            <summary>
                Create a new Pose for this mesh or one of its submeshes.
            </summary>
            <param name="target">
                The target geometry index; 0 is the shared Mesh geometry, 1+ is the
               	dedicated SubMesh geometry belonging to submesh index + 1.
            </param>
            <param name="name">Name to give the pose, which is optional</param>
            <returns>A new Pose ready for population</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetPose(System.UInt16)">
            <summary>Retrieve an existing Pose by index.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.GetPose(System.String)">
            <summary>Retrieve an existing Pose by name.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.GetPoseIndex(System.String)">
            <summary>Retrieve an existing Pose index by name.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.RemovePose(System.UInt16)">
            <summary>Destroy a pose by index.</summary>
            <remarks>This will invalidate any animation tracks referring to this pose or those after it.</remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.RemovePose(System.String)">
            <summary>Destroy a pose by name.</summary>
            <remarks>This will invalidate any animation tracks referring to this pose or those after it.</remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.RemoveAllPoses">
            <summary>Destroy all poses.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh._isLodManual">
            <summary>
            Flag indicating the use of manually created LOD meshes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.meshLodUsageList">
            <summary>
            List of data structures describing LOD usage.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.GetLodIndex(Axiom.Math.Real)">
            <summary>
               Retrieves the level of detail index for the given lod value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetLodLevel(System.Int32)">
            <summary>
               Gets the mesh lod level at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.SoftwareVertexBlend(Axiom.Graphics.VertexData,Axiom.Graphics.VertexData,Axiom.Math.Matrix4[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Performs a software indexed vertex blend, of the kind used for
            	skeletal animation although it can be used for other purposes.
            </summary>
            <remarks>
            	This function is supplied to update vertex data with blends
            	done in software, either because no hardware support is available,
            	or that you need the results of the blend for some other CPU operations.
            </remarks>
            <param name="sourceVertexData">
            	<see cref="T:Axiom.Graphics.VertexData"/> class containing positions, normals, blend indices and blend weights.
            </param>
            <param name="targetVertexData">
            	<see cref="T:Axiom.Graphics.VertexData"/> class containing target position
            	and normal buffers which will be updated with the blended versions.
            	Note that the layout of the source and target position / normal
            	buffers must be identical, ie they must use the same buffer indexes.
            </param>
            <param name="matrices">An array of matrices to be used to blend.</param>
            <param name="blendNormals">If true, normals are blended as well as positions.</param>
            <param name="blendTangents"></param>
            <param name="blendBinorms"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.SoftwareVertexMorph(System.Single,Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.VertexData)">
            <summary>
                Performs a software vertex morph, of the kind used for
                morph animation although it can be used for other purposes.
            </summary>
            <remarks>
              	This function will linearly interpolate positions between two
            	source buffers, into a third buffer.
            </remarks>
            <param name="t">Parametric distance between the start and end buffer positions</param>
            <param name="b1">Vertex buffer containing VertexElementType.Float3 entries for the start positions</param>
            <param name="b2">Vertex buffer containing VertexElementType.Float3 entries for the end positions</param>
            <param name="targetVertexData"> VertexData destination; assumed to have a separate position
                 buffer already bound, and the number of vertices must agree with the
              number in start and end
            </param>
        </member>
        <member name="M:Axiom.Core.Mesh.SoftwareVertexPoseBlend(System.Single,System.Collections.Generic.Dictionary{System.Int32,Axiom.Math.Vector3},Axiom.Graphics.VertexData)">
            <summary>
                Performs a software vertex pose blend, of the kind used for
                morph animation although it can be used for other purposes.
            </summary>
            <remarks>
                This function will apply a weighted offset to the positions in the
                incoming vertex data (therefore this is a read/write operation, and
                if you expect to call it more than once with the same data, then
                you would be best to suppress hardware uploads of the position buffer
                for the duration)
            </remarks>
            <param name="weight">Parametric weight to scale the offsets by</param>
            <param name="vertexOffsetMap"> Potentially sparse map of vertex index -> offset</param>
            <param name="targetVertexData"> VertexData destination; assumed to have a separate position
                buffer already bound, and the number of vertices must agree with the
                number in start and end
            </param>
        </member>
        <member name="M:Axiom.Core.Mesh.load">
            <summary>
            	Loads the mesh data.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.unload">
            <summary>
            	Unloads the mesh data.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SharedVertexData">
            <summary>
            	Gets/Sets the shared VertexData for this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SubMeshCount">
            <summary>
               Gets the number of submeshes belonging to this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.BoundingBox">
            <summary>
            	Gets/Sets the bounding box for this mesh.
            </summary>
            <remarks>
            	Setting this property is required when building manual meshes now, because Axiom can no longer
            	update the bounds for you, because it cannot necessarily read vertex data back from
            	the vertex buffers which this mesh uses (they very well might be write-only, and even
            	if they are not, reading data from a hardware buffer is a bottleneck).
            </remarks>
        </member>
        <member name="P:Axiom.Core.Mesh.BoundingSphereRadius">
            <summary>
               Bounding spehere radius from this mesh in local coordinates.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.Skeleton">
            <summary>
               Gets the skeleton currently bound to this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SkeletonName">
            <summary>
               Get/Sets the name of the skeleton which will be bound to this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.HasSkeleton">
            <summary>
               Determins whether or not this mesh has a skeleton associated with it.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.BoneAssignmentList">
            <summary>
            	Gets bone assigment list
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.VertexBufferUsage">
            <summary>
               Gets the usage setting for this meshes vertex buffers.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IndexBufferUsage">
            <summary>
               Gets the usage setting for this meshes index buffers.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.UseVertexShadowBuffer">
            <summary>
               Gets whether or not this meshes vertex buffers are shadowed.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.UseIndexShadowBuffer">
            <summary>
               Gets whether or not this meshes index buffers are shadowed.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsPreparedForShadowVolumes">
            <summary>
            	Gets whether this mesh has already had its geometry prepared for use in
            	rendering shadow volumes.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.AutoBuildEdgeLists">
            <summary>
            	Gets/Sets whether or not this Mesh should automatically build edge lists
            	when asked for them, or whether it should never build them if
            	they are not already provided.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsEdgeListBuilt">
            <summary>
                Returns whether this mesh has an attached edge list.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.AttachmentPoints">
            <summary>
            Llist of named transforms attached to this mesh.
            </summary>
            <value>The attachment points.</value>
        </member>
        <member name="P:Axiom.Core.Mesh.AnimationCount">
            <summary>
              The number of vertex animations in the mesh
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.HasVertexAnimation">
            <summary>Returns whether or not this mesh has some kind of vertex animation.</summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SharedVertexDataAnimationType">
            <summary>
            	Gets bone assigment list
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.AnimationTypesDirty">
            <summary>Are the derived animation types out of date?</summary>
        </member>
        <member name="P:Axiom.Core.Mesh.PoseList">
            <summary>
            	Gets bone assigment list
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.TriangleIntersector">
            <summary>A list of triangles, plus machinery to determine the closest intersection point</summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsLodManual">
            <summary>
            Returns true if this mesh is using manual LOD.
            </summary>
            <remarks>
            A mesh can either use automatically generated LOD, or it can use alternative
            meshes as provided by an artist. A mesh can only use either all manual LODs
            or all generated LODs, not a mixture of both.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Mesh.LodLevelCount">
            <summary>
            Gets the current number of Lod levels associated with this mesh.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchMesh.patchSurface">
            <summary>
                Internal surface definition.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchMesh.vertexDeclaration">
            <summary>
                Vertex declaration, cloned from the input.
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchMesh.#ctor(Axiom.Core.ResourceManager,System.String,System.UInt64,System.String)">
            <summary>
                Creates a new PatchMesh.
            </summary>
            <remarks>
                As defined in <see cref="M:Axiom.Core.MeshManager.CreateBezierPatch(System.String,System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Axiom.Collections.NameValuePairList">
            <summary>
            Represents a collection of names and values.
            </summary>
        </member>
        <member name="M:Axiom.Collections.NameValuePairList.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Axiom.Collections.NameValuePairList"/> class.
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimationTrack">
            <summary>
            	A 'track' in an animation sequence, ie a sequence of keyframes which affect a
            	certain type of object that can be animated.
            </summary>
            <remarks>
            	This class is intended as a base for more complete classes which will actually
            	animate specific types of object, e.g. a bone in a skeleton to affect
            	skeletal animation. An animation will likely include multiple tracks each of which
            	can be made up of many KeyFrame instances. Note that the use of tracks allows each animable
            	object to have it's own number of keyframes, i.e. you do not have to have the
            	maximum number of keyframes for all animable objects just to cope with the most
            	animated one.
            	<p/>
            	Since the most common animable object is a Node, there are options in this class for associating
            	the track with a Node which will receive keyframe updates automatically when the 'apply' method
            	is called.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.handle">
            <summary>
            	Handle of this animation track.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.parent">
            <summary>
            	Animation that owns this track.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.maxKeyFrameTime">
            <summary>
            	Maximum keyframe time.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.keyFrameList">
            <summary>
            	Collection of key frames in this track.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.#ctor(Axiom.Animating.Animation)">
            <summary>
            	Internal constructor, to prevent direction instantiation.  Should be created
            	via a call to the CreateTrack method of an Animation.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetInterpolatedKeyFrame(System.Single,Axiom.Animating.KeyFrame)">
            <summary>
                Gets a KeyFrame object which contains the interpolated transforms at the time index specified.
            </summary>
            <remarks>
               The KeyFrame objects held by this class are transformation snapshots at 
               discrete points in time. Normally however, you want to interpolate between these
               keyframes to produce smooth movement, and this method allows you to do this easily.
               In animation terminology this is called 'tweening'. 
            </remarks>
            <param name="time">The time (in relation to the whole animation sequence)</param>
            <param name="kf">Keyframe object to store results </param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.Apply(System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            	Applies an animation track to the designated target.
            </summary>
            <param name="time">The time position in the animation to apply.</param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, 
               less to blend with other animations.</param>
            <param name="accumulate">Don't make weights relative to overall weights applied,
               make them absolute and just add. </param>          
            <param name="scale">The scale to apply to translations and scalings, useful for 
               adapting an animation to a different size target.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.CreateKeyFrameImpl(System.Single)">
            <summary>
            	Create a keyframe implementation - must be overridden
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetKeyFramesAtTime(System.Single,Axiom.Animating.KeyFrame@,Axiom.Animating.KeyFrame@,System.Int16@)">
             <summary>
            		Gets the 2 KeyFrame objects which are active at the time given, and the blend value between them.
             </summary>
             <remarks>
            		At any point in time  in an animation, there are either 1 or 2 keyframes which are 'active',
            		1 if the time index is exactly on a keyframe, 2 at all other times i.e. the keyframe before
            		and the keyframe after.
             </remarks>
             <param name="time">The time index in seconds.</param>
             <param name="keyFrame1">Receive the keyframe just before or at this time index.</param>
             <param name="keyFrame2">Receive the keyframe just after this time index.</param>
             <param name="firstKeyIndex">If supplied, will receive the index of the 'from' keyframe incase the caller needs it.</param>
             <returns>
            		Parametric value indicating how far along the gap between the 2 keyframes the time
                value is, e.g. 0.0 for exactly at 1, 0.25 for a quarter etc. By definition the range of this 
                value is:  0.0 &lt;= returnValue &lt; 1.0 .
            </returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetTransformKeyFrame(System.Int32)">
            <summary>
            	Creates a new KeyFrame and adds it to this animation at the given time index.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)">
            <summary>
            	Creates a new KeyFrame and adds it to this animation at the given time index.
            </summary>
            <remarks>
            	It is better to create KeyFrames in time order. Creating them out of order can result 
            	in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            	for you, so you don't need to create this one, just access it using KeyFrames[0];
            </remarks>
            <param name="time">Time within the animation at which this keyframe will lie.</param>
            <returns>A new KeyFrame.</returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.RemoveKeyFrame(System.Int32)">
            <summary>
            	Removes the keyframe at the specified index.
            </summary>
            <param name="index">Index of the keyframe to remove from this track.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.RemoveAllKeyFrames">
            <summary>
            	Removes all key frames from this animation track.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.Apply(System.Single)">
            <summary>
            	Overloaded Apply method.  
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.OnKeyFrameDataChanged">
            <summary>
            	Called internally when keyframes belonging to this track are changed, in order to
            	trigger a rebuild of the animation splines.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.HasNonZeroKeyFrames">
            <summary>
            	Method to determine if this track has any KeyFrames which are
            	doing anything useful - can be used to determine if this track
            	can be optimised out.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.Optimise">
            <summary>
            	Optimise the current track by removing any duplicate keyframes.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.Handle">
            <summary>
            	The name of this animation track.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.KeyFrames">
            <summary>
            	Collection of the KeyFrames present in this AnimationTrack.
            </summary>
        </member>
        <member name="M:Axiom.Animating.NumericAnimationTrack.ApplyToAnimable(Axiom.Animating.AnimableValue,System.Single,System.Single,System.Single)">
            <summary> Applies an animation track to a given animable value. </summary>
            <param name="anim">The AnimableValue to which to apply the animation </param>
            <param name="time">The time position in the animation to apply. </param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
                   other animations. </param>
            <param name="scale">The scale to apply to translations and scalings, useful for 
                   adapting an animation to a different size target. </param>
        </member>
        <member name="P:Axiom.Animating.NumericAnimationTrack.TargetAnimable">
            <summary>
            	The aniable value with which this track is associated.
            </summary>
        </member>
        <member name="F:Axiom.Animating.NodeAnimationTrack.target">
            <summary>
            	Target node to be animated.
            </summary>
        </member>
        <member name="F:Axiom.Animating.NodeAnimationTrack.isSplineRebuildNeeded">
            <summary>
            	Flag indicating we need to rebuild the splines next time.
            </summary>
        </member>
        <member name="F:Axiom.Animating.NodeAnimationTrack.positionSpline">
            <summary>
            	Spline for position interpolation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.NodeAnimationTrack.scaleSpline">
            <summary>
            	Spline for scale interpolation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.NodeAnimationTrack.rotationSpline">
            <summary>
            	Spline for rotation interpolation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.NodeAnimationTrack.useShortestPath">
            <summary>
            	Defines if rotation is done using shortest path
            </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.#ctor(Axiom.Animating.Animation,Axiom.Core.Node)">
            <summary>
            	Internal constructor, to prevent direction instantiation.  Should be created
            	via a call to the CreateTrack method of an Animation.
            </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.GetInterpolatedKeyFrame(System.Single,Axiom.Animating.KeyFrame)">
             <summary>
            		Gets a KeyFrame object which contains the interpolated transforms at the time index specified.
             </summary>
             <remarks>
            		The KeyFrame objects held by this class are transformation snapshots at 
            		discrete points in time. Normally however, you want to interpolate between these
            		keyframes to produce smooth movement, and this method allows you to do this easily.
            		In animation terminology this is called 'tweening'. 
             </remarks>
             <param name="time">The time (in relation to the whole animation sequence).</param>
            <param name="kf"></param>
            <returns>
            		A new keyframe object containing the interpolated transforms. Note that the
            		position and scaling transforms are linearly interpolated (lerp), whilst the rotation is
            		spherically linearly interpolated (slerp) for the most natural result.
             </returns>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.Apply(System.Single,System.Single,System.Boolean,System.Single)">
             <summary>
            		Applies an animation track at a certain position to the target node.
             </summary>
             <remarks>
            		When a track has bee associated with a target node, you can eaisly apply the animation
            		to the target by calling this method.
             </remarks>
             <param name="time">The time position in the animation to apply.</param>
             <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
            		other animations.</param>
             <param name="accumulate"></param>
            <param name="scale"></param>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.ApplyToNode(Axiom.Core.Node,System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            	Same as the Apply method, but applies to a specified Node instead of it's associated node.
            </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.OnKeyFrameDataChanged">
            <summary>
            	Called internally when keyframes belonging to this track are changed, in order to
            	trigger a rebuild of the animation splines.
            </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.BuildInterpolationSplines">
            <summary>Used to rebuild the internal interpolation splines for translations, rotations, and scaling.</summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.HasNonZeroKeyFrames">
            <summary>
                Method to determine if this track has any KeyFrames which are
                doing anything useful - can be used to determine if this track
                can be optimised out.
            </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.Optimise">
            <summary> Optimise the current track by removing any duplicate keyframes. </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.CreateKeyFrameImpl(System.Single)">
            <summary> Specialised keyframe creation </summary>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.CreateNodeKeyFrame(System.Single)">
            <summary> 
                Creates a new KeyFrame and adds it to this animation at the given time index.
            </summary>
            <remarks>
               It is better to create KeyFrames in time order. Creating them out of order can result 
               in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
               for you, so you don't need to create this one, just access it using getKeyFrame(0);
            </remarks>
            <param> name="timePos">The time from which this KeyFrame will apply. </param>
        </member>
        <member name="M:Axiom.Animating.NodeAnimationTrack.GetNodeKeyFrame(System.UInt16)">
            <summary> Returns the KeyFrame at the specified index. </summary>
        </member>
        <member name="P:Axiom.Animating.NodeAnimationTrack.TargetNode">
            <summary>
            	Gets/Sets the target node that this track is associated with.
            </summary>
        </member>
        <member name="F:Axiom.Animating.VertexAnimationTrack.animationType">
            Animation type
        </member>
        <member name="F:Axiom.Animating.VertexAnimationTrack.targetVertexData">
            Target to animate
        </member>
        <member name="F:Axiom.Animating.VertexAnimationTrack.targetMode">
            Mode to apply
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.#ctor(Axiom.Animating.Animation,Axiom.Animating.VertexAnimationType)">
            Constructor
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.#ctor(Axiom.Animating.Animation,Axiom.Animating.VertexAnimationType,Axiom.Graphics.VertexData,Axiom.Animating.VertexAnimationTargetMode)">
            Constructor, associates with target VertexData and temp buffer (for software)
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.CreateVertexMorphKeyFrame(System.Single)">
            <summary> Creates a new morph KeyFrame and adds it to this animation at the given time index. </summary>
            <remarks>
                It is better to create KeyFrames in time order. Creating them out of order can result 
                in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
                for you, so you don't need to create this one, just access it using getKeyFrame(0);
            </remarks>
            <param name="time">The time from which this KeyFrame will apply.</param>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.ApplyToVertexData(Axiom.Graphics.VertexData,System.Single,System.Single,System.Collections.Generic.List{Axiom.Animating.Pose})">
            <summary>
                As the 'apply' method but applies to specified VertexData instead of 
                associated data.
            </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.CreateVertexPoseKeyFrame(System.Single)">
            <summary> Creates the single pose KeyFrame and adds it to this animation. </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.GetInterpolatedKeyFrame(System.Single,Axiom.Animating.KeyFrame)">
            <summary>
                This method in fact does nothing, since interpolation is not performed
             	inside the keyframes for this type of track. 
            </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.ApplyPoseToVertexData(Axiom.Animating.Pose,Axiom.Graphics.VertexData,System.Single)">
            <summary> Utility method for applying pose animation </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.GetVertexMorphKeyFrame(System.UInt16)">
            <summary> Returns the morph KeyFrame at the specified index. </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.GetVertexPoseKeyFrame(System.UInt16)">
            <summary> Returns the pose KeyFrame at the specified index. </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.HasNonZeroKeyFrames">
            <summary>
                Method to determine if this track has any KeyFrames which are
                doing anything useful - can be used to determine if this track
                can be optimised out.
            </summary>
        </member>
        <member name="M:Axiom.Animating.VertexAnimationTrack.Optimise">
            <summary> Optimise the current track by removing any duplicate keyframes. </summary>
        </member>
        <member name="P:Axiom.Animating.VertexAnimationTrack.AnimationType">
            <summary>
            	Gets/Sets the vertex animation type that this track is associated with.
            </summary>
        </member>
        <member name="P:Axiom.Animating.VertexAnimationTrack.TargetVertexData">
            <summary>
            	Gets/Sets the target vertex data that this track is associated with.
            </summary>
        </member>
        <member name="P:Axiom.Animating.VertexAnimationTrack.TargetMode">
            <summary>
            	Gets/Sets the target node that this track is associated with.
            </summary>
        </member>
        <member name="T:Axiom.Core.PrefabFactory">
            <summary>
            A factory class that can create various mesh prefabs.
            </summary>
            <remarks>
            This class is used by MeshManager to offload the loading of various prefab types
            to a central location.
            </remarks>
        </member>
        <member name="M:Axiom.Core.PrefabFactory.Create(Axiom.Core.Mesh)">
            <summary>
            If the given mesh has a known prefab resource name (e.g "Prefab_Plane")
            then this prefab will be created as a submesh of the given mesh.
            </summary>
            <param name="mesh">The mesh that the potential prefab will be created in.</param>
            <returns><c>true</c> if a prefab has been created, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Axiom.Core.PrefabFactory._createPlane(Axiom.Core.Mesh)">
            <summary>
            Creates a plane as a submesh of the given mesh
            </summary>
        </member>
        <member name="M:Axiom.Core.PrefabFactory._createCube(Axiom.Core.Mesh)">
            <summary>
            Creates a 100x100x100 cube as a submesh of the given mesh
            </summary>
        </member>
        <member name="M:Axiom.Core.PrefabFactory._createSphere(Axiom.Core.Mesh)">
            <summary>
            Creates a sphere with a diameter of 100 units as a submesh of the given mesh
            </summary>
        </member>
        <member name="T:Axiom.Core.PixelCountStrategy">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Core.PixelCountStrategy.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Collections.ViewportCollection">
            <summary>
            Represents a collection of Viewports that are sorted by zOrder key based on the associated <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that is empty, has the default initial capacity, and uses the default <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that is empty, has the specified initial capacity, and uses the default <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Generic.SortedList`2"/> can contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.
            </exception>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor(System.Collections.Generic.IComparer{System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys.
            -or-
            null to use the default <see cref="T:System.Collections.Generic.Comparer`1"/> for the type of the key.
            </param>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor(System.Int32,System.Collections.Generic.IComparer{System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Generic.SortedList`2"/> can contain.
            </param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys.
            -or-
            null to use the default <see cref="T:System.Collections.Generic.Comparer`1"/> for the type of the key.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.
            </exception>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor(System.Collections.Generic.IDictionary{System.Int32,Axiom.Core.Viewport})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"/>, has sufficient capacity to accommodate the number of elements copied, and uses the default <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"/> whose elements are copied to the new <see cref="T:System.Collections.Generic.SortedList`2"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="dictionary"/> contains one or more duplicate keys.
            </exception>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor(System.Collections.Generic.IDictionary{System.Int32,Axiom.Core.Viewport},System.Collections.Generic.IComparer{System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.SortedList`2"/> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"/>, has sufficient capacity to accommodate the number of elements copied, and uses the specified <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"/> whose elements are copied to the new <see cref="T:System.Collections.Generic.SortedList`2"/>.
            </param><param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> implementation to use when comparing keys.
            -or-
            null to use the default <see cref="T:System.Collections.Generic.Comparer`1"/> for the type of the key.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="dictionary"/> contains one or more duplicate keys.
            </exception>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.Add(Axiom.Core.Viewport)">
            <summary>
            Adds a Viewport into the SortedList, automatically using its zOrder as key.
            </summary>
            <param name="item">A Viewport</param>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.AbstractNodeType">
            <summary>
            the types of the possible abstract nodes
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanel">
            <summary>
            	A specialization of the Panel element to provide a panel with a border with a seperate material.
            </summary>
            <remarks>
            	Whilst the standard panel can use a single tiled material, this class allows
            	panels with a tileable backdrop plus a border texture. This is handy for large
            	panels that are too big to use a single large texture with a border, or
            	for multiple different size panels where you want the border a constant width
            	but the center to repeat.
            	<p/>
            	In addition to the usual PanelGuiElement properties, this class has a 'border
            	material', which specifies the material used for the edges of the panel,
            	a border width (which can either be constant all the way around, or specified
            	per edge), and the texture coordinates for each of the border sections.
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.#ctor(System.String)">
            <summary>
               Internal constructor, used when objects create by the factory.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.Initialize">
            <summary>
               Override from Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetBorderSize(System.Single)">
            <summary>
               Sets the size of the border.
            </summary>
            <remarks>
               This method sets a constant size for all borders. There are also alternative
               methods which allow you to set border widths for individual edges separately.
               Remember that the dimensions specified here are in relation to the size of
               the screen, so 0.1 is 1/10th of the screen width or height. Also note that because
               most screen resolutions are 1.333:1 width:height ratio that using the same
               border size will look slightly bigger across than up.
            </remarks>
            <param name="size">The size of the border as a factor of the screen dimensions ie 0.2 is one-fifth
               of the screen size.
            </param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetBorderSize(System.Single,System.Single)">
            <summary>
               Sets the size of the border, with different sizes for vertical and horizontal borders.
            </summary>
            <remarks>
               This method sets a size for the side and top / bottom borders separately.
               Remember that the dimensions specified here are in relation to the size of
               the screen, so 0.1 is 1/10th of the screen width or height. Also note that because
               most screen resolutions are 1.333:1 width:height ratio that using the same
               border size will look slightly bigger across than up.
            </remarks>
            <param name="sides">The size of the side borders as a factor of the screen dimensions ie 0.2 is one-fifth
               of the screen size.</param>
            <param name="topAndBottom">The size of the top and bottom borders as a factor of the screen dimensions.</param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetBorderSize(System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Sets the size of the border separately for all borders.
            </summary>
            <remarks>
               This method sets a size all borders separately.
               Remember that the dimensions specified here are in relation to the size of
               the screen, so 0.1 is 1/10th of the screen width or height. Also note that because
               most screen resolutions are 1.333:1 width:height ratio that using the same
               border size will look slightly bigger across than up.
            </remarks>
            <param name="left">The size of the left border as a factor of the screen dimensions ie 0.2 is one-fifth
            of the screen size.</param>
            <param name="right">The size of the right border as a factor of the screen dimensions.</param>
            <param name="top">The size of the top border as a factor of the screen dimensions.</param>
            <param name="bottom">The size of the bottom border as a factor of the screen dimensions.</param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetCellUV(Axiom.Overlays.Elements.BorderPanel.BorderCell,System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Sets the texture coordinates for the left edge of the border.
            </summary>
            <remarks>
               The border panel uses 8 panels for the border (9 including the center).
               Imagine a table with 3 rows and 3 columns. The corners are always the same size,
               but the edges stretch depending on how big the panel is. Those who have done
               resizable HTML tables will be familiar with this approach.
               <p/>
               We only require 2 sets of uv coordinates, one for the top-left and one for the
               bottom-right of the panel, since it is assumed the sections are aligned on the texture.
            </remarks>
            <param name="cell">Index of the cell to update.</param>
            <param name="u1">Top left u.</param>
            <param name="v1">Top left v.</param>
            <param name="u2">Bottom right u.</param>
            <param name="v2">Bottom right v.</param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.Update">
            <summary>
               Overriden from Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.UpdatePositionGeometry">
            <summary>
               Override from Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
               Overriden from Panel.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.LeftBorderSize">
            <summary>
               Gets the size of the left border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.RightBorderSize">
            <summary>
               Gets the size of the right border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.TopBorderSize">
            <summary>
               Gets the size of the top border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.BottomBorderSize">
            <summary>
               Gets the size of the bottom border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.BorderMaterialName">
            <summary>
               Gets/Sets the name of the material to use for just the borders.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.MetricsMode">
            <summary>
               Override of Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderSizeAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderSizeAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderMaterialHeightAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderMaterialHeightAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderTopLeftUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderTopLeftUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderTopRightUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderTopRightUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderBottomLeftUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderBottomLeftUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderBottomRightUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderBottomRightUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderLeftUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderLeftUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderTopUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderTopUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderRightUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderRightUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderBottomUVAttributeCommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderBottomUVAttributeCommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanel.BorderRenderable">
            <summary>
               Class for rendering the border of a BorderPanel.
            </summary>
            <remarks>
               We need this because we have to render twice, once with the inner panel's repeating
               material (handled by superclass) and once for the border's separate meterial.
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderRenderable.#ctor(Axiom.Overlays.Elements.BorderPanel)">
             <summary>
            
             </summary>
             <param name="parent"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderRenderable.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
            
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base.dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.BorderRenderable.isDisposed">
            <summary>
            Determines if this instance has been disposed of already.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanel.BorderCell">
            <summary>
               Enum for border cells.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.OverlayElementManager">
            <summary>
               This class acts as a repository and regitrar of overlay components.
            </summary>
            <remarks>
               OverlayElementManager's job is to manage the lifecycle of OverlayElement (subclass)
               instances, and also to register plugin suppliers of new components.
            </remarks>
        </member>
        <member name="F:Axiom.Overlays.OverlayElementManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.AddElementFactory(Axiom.Overlays.IOverlayElementFactory)">
            <summary>
                Registers a new OverlayElementFactory with this manager.
            </summary>
            <remarks>
               Should be used by plugins or other apps wishing to provide
               a new OverlayElement subclass.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElement(System.String,System.String)">
            <summary>
               Creates a new OverlayElement of the type requested.
            </summary>
            <param name="typeName">The type of element to create is passed in as a string because this
               allows plugins to register new types of component.</param>
            <param name="instanceName">The type of element to create.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElement(System.String,System.String,System.Boolean)">
            <summary>
               Creates a new OverlayElement of the type requested.
            </summary>
            <param name="typeName">The type of element to create is passed in as a string because this
               allows plugins to register new types of component.</param>
            <param name="instanceName">The type of element to create.</param>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElementFromFactory(System.String,System.String)">
            <summary>
               Creates an element of the specified type, with the specified name
            </summary>
            <remarks>
               A factory must be available to handle the requested type, or an exception will be thrown.
            </remarks>
            <param name="typeName"></param>
            <param name="instanceName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElementFromTemplate(System.String,System.String,System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElementFromTemplate(System.String,System.String,System.String,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CloneOverlayElementFromTemplate(System.String,System.String)">
            <summary>
            Clones an overlay element from a template
            </summary>
            <param name="template">template to clone</param>
            <param name="name">name of the new element</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.GetElement(System.String)">
            <summary>
               Gets a reference to an existing element.
            </summary>
            <param name="name">Name of the element to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.GetElement(System.String,System.Boolean)">
            <summary>
               Gets a reference to an existing element.
            </summary>
            <param name="name">Name of the element to retrieve.</param>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.GetElementTable(System.Boolean)">
            <summary>
               Quick helper method to return the lookup table for the right element type.
            </summary>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.DestroyElement(System.String)">
            <summary>
            Destroys the specified OverlayElement
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.DestroyElement(System.String,System.Boolean)">
            <summary>
            Destroys the specified OverlayElement
            </summary>
            <param name="name"></param>
            <param name="isTemplate"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.DestroyElement(Axiom.Overlays.OverlayElement)">
            <summary>
            Destroys the supplied OvelayElement
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.DestroyElement(Axiom.Overlays.OverlayElement,System.Boolean)">
            <summary>
            Destroys the supplied OvelayElement
            </summary>
            <param name="element"></param>
            <param name="isTemplate"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.DestroyAllElements">
            <summary>
            destroys all OverlayElements
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.DestroyAllElements(System.Boolean)">
            <summary>
            destroys all OverlayElements
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.dispose(System.Boolean)">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementManager.Instances">
            <summary>
            returns all elemnt instances
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementManager.Templates">
            <summary>
            returns all element templates
            </summary>
        </member>
        <member name="T:Axiom.Media.PixelConverter">
            <summary>
                A class to convert/copy pixels of the same or different formats
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelConverter.UnindexedPixelFormats">
            <summary>
                Pixel format database
            </summary>
        </member>
        <member name="M:Axiom.Media.PixelConverter.PackColor(Axiom.Core.ColorEx,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
                Pack a color value to memory
            </summary>
            <param name="color">The color</param>
            <param name="format">Pixel format in which to write the color</param>
            <param name="dest">Destination memory location</param>
        </member>
        <member name="M:Axiom.Media.PixelConverter.PackColor(System.UInt32,System.UInt32,System.UInt32,System.UInt32,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
                Pack a color value to memory
            </summary>
            <param name="r">Red component, range 0x00 to 0xFF</param>
            <param name="g">Green component, range 0x00 to 0xFF</param>
            <param name="b">Blue component, range 0x00 to 0xFF</param>
            <param name="a">Alpha component, range 0x00 to 0xFF</param>
            <param name="format">Pixelformat in which to write the color</param>
            <param name="dest">Destination memory location</param>
        </member>
        <member name="M:Axiom.Media.PixelConverter.PackColor(System.Single,System.Single,System.Single,System.Single,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
                Pack a color value to memory
            </summary>
            <param name="r">
                The four color components, range 0.0f to 1.0f
                (an exception to this case exists for floating point pixel
                formats, which don't clamp to 0.0f..1.0f)
            </param>
            <param name="g">
                The four color components, range 0.0f to 1.0f
                (an exception to this case exists for floating point pixel
                formats, which don't clamp to 0.0f..1.0f)
            </param>
            <param name="b">
                The four color components, range 0.0f to 1.0f
                (an exception to this case exists for floating point pixel
                formats, which don't clamp to 0.0f..1.0f)
            </param>
            <param name="a">
                The four color components, range 0.0f to 1.0f
                (an exception to this case exists for floating point pixel
                formats, which don't clamp to 0.0f..1.0f)
            </param>
            <param name="format">Pixelformat in which to write the color</param>
            <param name="dest">Destination memory location</param>
        </member>
        <member name="M:Axiom.Media.PixelConverter.UnpackColor(Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
            Unpack a color value from memory
            </summary>
            <param name="pf">Pixelformat in which to read the color</param>
            <param name="src">Source memory location</param>
            <returns>The color is returned here</returns>
        </member>
        <member name="M:Axiom.Media.PixelConverter.UnpackColor(System.Byte@,System.Byte@,System.Byte@,System.Byte@,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
            Unpack a color value from memory
            </summary>
            <param name="r">The color is returned here (as byte)</param>
            <param name="g">The color is returned here (as byte)</param>
            <param name="b">The color is returned here (as byte)</param>
            <param name="a">The color is returned here (as byte)</param>
            <param name="pf">Pixelformat in which to read the color</param>
            <param name="src">Source memory location</param>
            <remarks>
            This function returns the color components in 8 bit precision,
            this will lose precision when coming from A2R10G10B10 or floating
            point formats.
            </remarks>
        </member>
        <member name="M:Axiom.Media.PixelConverter.UnpackColor(System.Single@,System.Single@,System.Single@,System.Single@,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
            Unpack a color value from memory
            </summary>
            <param name="r">The color is returned here (as float)</param>
            <param name="g">The color is returned here (as float)</param>
            <param name="b">The color is returned here (as float)</param>
            <param name="a">The color is returned here (as float)</param>
            <param name="pf">Pixelformat in which to read the color</param>
            <param name="src">Source memory location</param>
        </member>
        <member name="M:Axiom.Media.PixelConverter.BulkPixelConversion(System.IntPtr,System.Int32,Axiom.Media.PixelFormat,System.IntPtr,System.Int32,Axiom.Media.PixelFormat,System.Int32)">
            <summary>
                Convert consecutive pixels from one format to another. No dithering or filtering is being done. 
                Converting from RGB to luminance takes the R channel.  In case the source and destination format match,
                just a copy is done.
            </summary>
            <param name="srcBytes">Pointer to source region</param>
            <param name="srcOffset"></param>
            <param name="srcFormat">Pixel format of source region</param>
            <param name="dstBytes">Pointer to destination region</param>
            <param name="dstOffset"></param>
            <param name="dstFormat">Pixel format of destination region</param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Media.PixelConverter.BulkPixelConversion(Axiom.Media.PixelBox,Axiom.Media.PixelBox)">
            <summary>
                Convert pixels from one format to another. No dithering or filtering is being done. Converting
                from RGB to luminance takes the R channel. 
            </summary>
            <param name="src">PixelBox containing the source pixels, pitches and format</param>
            <param name="dst">PixelBox containing the destination pixels, pitches and format</param>
            <remarks>
                The source and destination boxes must have the same
                dimensions. In case the source and destination format match, a plain copy is done.
            </remarks>
        </member>
        <member name="T:Axiom.Media.PixelConverter.PixelFormatDescription">
            <summary>
             Description of Pixel Formats.
            </summary>
        </member>
        <member name="T:Axiom.Input.MouseEventArgs">
            <summary>
            	Events args for mouse input events.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.x">
            <summary>
            	X coordinate of the mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.y">
            <summary>
            	Y coordinate of the mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.z">
            <summary>
            	Z coordinate of the mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.relativeX">
            <summary>
            	Relative X coordinate of the mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.relativeY">
            <summary>
            	Relative Y coordinate of the mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.relativeZ">
            <summary>
            	Relative Z coordinate of the mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseEventArgs.button">
            <summary>
            	Mouse button pressed during this event.
            </summary>
        </member>
        <member name="M:Axiom.Input.MouseEventArgs.#ctor(Axiom.Input.MouseButtons,Axiom.Input.ModifierKeys,System.Single,System.Single,System.Single)">
            <summary>
            	Constructor.
            </summary>
            <param name="button">Mouse button pressed.</param>
            <param name="modifiers">Any modifier keys that are down.</param>
            <param name="x">Mouse X position.</param>
            <param name="y">Mouse Y position.</param>
            <param name="z">Mouse Z position.</param>
        </member>
        <member name="M:Axiom.Input.MouseEventArgs.#ctor(Axiom.Input.MouseButtons,Axiom.Input.ModifierKeys,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Constructor.
            </summary>
            <param name="button">Mouse button pressed.</param>
            <param name="modifiers">Any modifier keys that are down.</param>
            <param name="x">Mouse X position.</param>
            <param name="y">Mouse Y position.</param>
            <param name="z">Mouse Z position.</param>
            <param name="relX">Relative mouse X position.</param>
            <param name="relY">Relative mouse Y position.</param>
            <param name="relZ">Relative mouse Z position.</param>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.Button">
            <summary>
            	Mouse button pressed during this event.
            </summary>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.X">
            <summary>
            	Mouse X coordinate.
            </summary>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.Y">
            <summary>
            	Mouse Y coordinate.
            </summary>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.Z">
            <summary>
            	Mouse Z coordinate.
            </summary>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.RelativeX">
            <summary>
            	Relative mouse X coordinate.
            </summary>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.RelativeY">
            <summary>
            	Relative mouse Y coordinate.
            </summary>
        </member>
        <member name="P:Axiom.Input.MouseEventArgs.RelativeZ">
            <summary>
            	Relative mouse Z coordinate.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderOperation">
            <summary>
            	Contains all the information required to render a set of vertices.  This includes
            	a list of VertexBuffers. 
            </summary>
            <remarks>
            	This class contains
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.operationType">
            <summary>
            	Type of operation to perform.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.vertexData">
            <summary>
            	Contains a list of hardware vertex buffers for this complete render operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.indexData">
            <summary>
            	When <code>useIndices</code> is set to true, this must hold a reference to an index
            	buffer containing indices into the vertices stored here. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.useIndices">
            <summary>
            	Specifies whether or not a list of indices should be used when rendering the vertices in
            	the buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.numberOfInstances">
            <summary>
            The number of instances for the render operation - this option is supported 
            in only a part of the render systems.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.useGlobalInstancingVertexBufferIsAvailable">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderOperation.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderOperation.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="T:Axiom.Graphics.Rectangle2D">
            <summary>
            	Allows the rendering of a simple 2D rectangle
            	This class renders a simple 2D rectangle; this rectangle has no depth and
            	therefore is best used with specific render queue and depth settings,
            	like <see cref="F:Axiom.Core.RenderQueueGroupID.Background"/> and 'depth_write off' for backdrops, and 
            	<see cref="F:Axiom.Core.RenderQueueGroupID.Overlay"/> and 'depth_check off' for fullscreen quads.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Rectangle2D.SetCorners(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the corners of the rectangle, in relative coordinates.
            </summary>
            <param name="left">Left position in screen relative coordinates, -1 = left edge, 1.0 = right edge.</param>
            <param name="top">Top position in screen relative coordinates, 1 = top edge, -1 = bottom edge.</param>
            <param name="right">Position in screen relative coordinates.</param>
            <param name="bottom">Position in screen relative coordinates.</param>
        </member>
        <member name="M:Axiom.Graphics.Rectangle2D.SetCorners(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            	Sets the corners of the rectangle, in relative coordinates.
            </summary>
            <param name="left">Left position in screen relative coordinates, -1 = left edge, 1.0 = right edge.</param>
            <param name="top">Top position in screen relative coordinates, 1 = top edge, -1 = bottom edge.</param>
            <param name="right">Position in screen relative coordinates.</param>
            <param name="bottom">Position in screen relative coordinates.</param>
            <param name="updateAABB"></param>
        </member>
        <member name="M:Axiom.Graphics.Rectangle2D.SetNormals(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            Sets the normals of the rectangle
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareVertexBuffer">
            <summary>
            	Describes the graphics API independent functionality required by a hardware
            	vertex buffer.  
            </summary>
            <remarks>
            	
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.HardwareVertexBuffer.CheckIfVertexInstanceDataIsSupported">
            <summary>
            Checks if vertex instance data is supported by the render system
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.HardwareVertexBuffer.VertexDeclaration">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareVertexBuffer.VertexSize">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferLicenseRelease">
            <summary>
                Describes types of hardware buffer licenses.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLicenseRelease.Manual">
            <summary>
                Licensee will only release buffer when it says so.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLicenseRelease.Automatic">
            <summary>
                Licensee can have license revoked.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferLocking">
            <summary>
            	Describes how a vertex buffer should act when it is locked.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.Normal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.Discard">
            <summary>
            	Discards the <em>entire</em> buffer while locking; this allows optimisation to be 
            	performed because synchronisation issues are relaxed. Only allowed on buffers 
            	created with the Dynamic flag. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.ReadOnly">
            <summary>
            	Lock the buffer for reading only. Not allowed in buffers which are created with WriteOnly. 
            	Mandatory on static buffers, ie those created without the Dynamic flag.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.NoOverwrite">
            <summary>
               Potential optimization for some API's.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferUsage">
            <summary>
            	Describes how a vertex buffer is to be used, and affects how it is created.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.Static">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.Dynamic">
            <summary>
            	Indicates the application would like to modify this buffer with the CPU
            	sometimes. Absence of this flag means the application will never modify. 
            	Buffers created with this flag will typically end up in AGP memory rather 
            	than video memory.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.WriteOnly">
            <summary>
            	Indicates the application will never read the contents of the buffer back, 
            	it will only ever write data. Locking a buffer with this flag will ALWAYS 
            	return a pointer to new, blank memory rather than the memory associated 
            	with the contents of the buffer; this avoids DMA stalls because you can 
            	write to a new memory area while the previous one is being used
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.Discardable">
            <summary>
                Indicates that the application will be refilling the contents
                of the buffer regularly (not just updating, but generating the
                contents from scratch), and therefore does not mind if the contents 
                of the buffer are lost somehow and need to be recreated. This
                allows and additional level of optimisation on the buffer.
                This option only really makes sense when combined with 
                DynamicWriteOnly.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.StaticWriteOnly">
            <summary>
               Combination of Static and WriteOnly
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.DynamicWriteOnly">
            <summary>
               Combination of Dynamic and WriteOnly. If you use 
               this, strongly consider using DynamicWriteOnlyDiscardable
               instead if you update the entire contents of the buffer very 
               regularly. 
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Capabilities">
            <summary>
            	Various types of capabilities supported by hardware that must be checked.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.HardwareMipMaps">
            <summary>
            	Supports generating mipmaps in hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.Blending">
            <summary>
            Supports anisotropic texture filtering
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.AnisotropicFiltering">
            <summary>
            Supports anisotropic texture filtering
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.Dot3">
            <summary>
            	Supports fixed-function DOT3 texture blend.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.CubeMapping">
            <summary>
            	Supports cube mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.StencilBuffer">
            <summary>
            	Supports hardware stencil buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexBuffer">
            <summary>
            	Supports hardware vertex and index buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexPrograms">
            <summary>
            	Supports vertex programs (vertex shaders).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.FragmentPrograms">
            <summary>
            	Supports fragment programs (pixel shaders).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.ScissorTest">
            <summary>
            	Supports performing a scissor test to exclude areas of the screen.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TwoSidedStencil">
            <summary>
            	Supports separate stencil updates for both front and back faces.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.StencilWrap">
            <summary>
            	Supports wrapping the stencil value at the range extremeties.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.HardwareOcculusion">
            <summary>
            	Hardware occlusion queries.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.UserClipPlanes">
            <summary>
            	User clipping planes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexFormatUByte4">
            <summary>
            	Supports the VET_UBYTE4 vertex element type
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.InfiniteFarPlane">
            <summary>
            	Supports infinite far plane projection
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.HardwareRenderToTexture">
            <summary>
                Supports hardware render-to-texture (bigger than framebuffer)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureFloat">
            <summary>
                Supports float textures and render targets
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.NonPowerOf2Textures">
            <summary>
                Supports non-power of two textures
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.Texture3D">
            <summary>
                Supports 3d (volume) textures
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.PointSprites">
            <summary>
                Supports basic point sprite rendering
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.PointExtendedParameters">
            <summary>
                Supports extra point parameters (minsize, maxsize, attenuation)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexTextureFetch">
            <summary>
            	Supports vertex texture fetch
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.MipmapLODBias">
            <summary>
            	Supports mipmap LOD biasing
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.GeometryPrograms">
            <summary>
            	Supports hardware geometry programs
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompression">
            <summary>
            	Supports compressed textures.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompressionDXT">
            <summary>
            	Supports compressed textures in the DXT/ST3C formats.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompressionVTC">
            <summary>
            	Supports compressed textures in the VTC format.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompressionPVRTC">
            <summary>
                Supports compressed textures in the PVRTC format
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.FixedFunction">
            <summary>
                Supports fixed-function pipeline
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.MRTDifferentBitDepths">
            <summary>
                Supports MRTs with different bit depths
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.AlphaToCoverage">
            <summary>
                Supports Alpha to Coverage (A2C)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.AdvancedBlendOperations">
            <summary>
                Supports Blending operations other than +
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Graphics.Capabilities.RTTSerperateDepthBuffer" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Graphics.Capabilities.RTTMainDepthbufferAttachable" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Graphics.Capabilities.RTTDepthbufferResolutionLessEqual" -->
        <member name="F:Axiom.Graphics.Capabilities.VertexBufferInstanceData">
            <summary>
                Supports using vertex buffers for instance data
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.CanGetCompiledShaderBuffer">
            <summary>
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.PerStageConstant">
            <summary>
            Is DirectX feature "per stage constants" supported
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.GL15NoVbo">
            <summary>
                Supports openGL GLEW version 1.5
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.FrameBufferObjects">
            <summary>
                Support for Frame Buffer Objects (FBOs)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.FrameBufferObjectsARB">
            <summary>
               Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.FrameBufferObjectsATI">
            <summary>
               Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.PBuffer">
            <summary>
                Support for PBuffer
            </summary>
            
        </member>
        <member name="F:Axiom.Graphics.Capabilities.GL15NoHardwareOcclusion">
            <summary>
                Support for GL 1.5 but without HW occlusion workaround
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.PointExtendedParametersARB">
            <summary>
                Support for point parameters ARB implementation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.PointExtendedParametersEXT">
            <summary>
                Support for point parameters EXT implementation
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompareFunction">
            <summary>
             Comparison functions, for things such as stencil buffer or depth comparisons.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CullingMode">
            <summary>
            Options for deciding what geometry gets excluded from the rendering process.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CullingMode.None">
            <summary>
            	Draw everything (2 sided geometry).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CullingMode.Clockwise">
            <summary>
            	Only draw geomtry where vertices were specified in clockwise order.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CullingMode.CounterClockwise">
            <summary>
            	Only draw geomtry where vertices were specified in counterclockwise order.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.EnvironmentMap">
            <summary>
            	Specifes the type of environment mapping to use.
            </summary>
            <remarks>
               Note that these have no effect when using the programmable pipeline, since their
               effect is overridden by the vertex / fragment programs.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Curved">
            <summary>
            	Envmap based on vector from camera to vertex position, good for planar geometry.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Planar">
            <summary>
            	Envmap based on dot of vector from camera to vertex and vertex normal, good for curves.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Reflection">
            <summary>
            	Envmap entended to supply reflection vectors for cube mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Normal">
            <summary>
            	Envmap entended to supply normal vectors for cube mapping
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FaceGroup">
            <summary>
                A type of face group, i.e. face list of procedural etc
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FilterOptions">
            <summary>
               Filtering options for textures / mipmaps.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.None">
            <summary>
               No filtering, used for FilterType.Mip to turn off mipmapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.Point">
            <summary>
               Use the closest pixel.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.Linear">
            <summary>
               Average of a 2x2 pixel area, denotes bilinear for Min and Mag, trilinear for Mip.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.Anisotropic">
            <summary>
               Similar to Linear, but compensates for the angle of the texture plane.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FilterType">
            <summary>
               Stages of texture rendering to which filters can be applied.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterType.Min">
            <summary>
               The filter used when shrinking a texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterType.Mag">
            <summary>
               The filter used when magnifiying a texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterType.Mip">
            <summary>
               The filter used when determining the mipmap.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FogMode">
            <summary>
            Type of fog to use in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.None">
            <summary>
            	No fog.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.Exp">
            <summary>
            	Fog density increases exponentially from the camera (fog = 1/e^(distance * density)).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.Exp2">
            <summary>
            	Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.Linear">
            <summary>
            	Fog density increases linearly between the start and end distances.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramType">
            <summary>
               Enumerates the types of programs which can run on the GPU.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramType.Vertex">
            <summary>
               Executes for each vertex passed through the pipeline while this program is active.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramType.Fragment">
            <summary>
               Executes for each fragment (or pixel) for primitives that are passed through the pipeline
               while this program is active..
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramType.Geometry">
            <summary>
               Executes for each geometry for primitives that are passed through the pipeline
               while this program is active..
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameterType">
            <summary>
               Enumerates the types of parameters that can be specified for shaders
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.Indexed">
            <summary>
               Parameter is passed in by index. Used for ASM shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.IndexedAuto">
            <summary>
               Parameter is managed by Axiom and passed in by index. Used for ASM shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.Named">
            <summary>
               Parameter is passed in by name. Used for high-level shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.NamedAuto">
            <summary>
               Parameter is managed by Axiom and passed in by name. Used for HL shaders.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FrameBufferType">
            <summary>
            	Defines the frame buffers which can be cleared.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IlluminationRenderStage">
            <summary>
            	Describes the stage of rendering when performing complex illumination.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.None">
            <summary>
            	No special illumination stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.Ambient">
            <summary>
            	Ambient stage, when background light is added.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.PerLight">
            <summary>
            	Diffuse / specular stage, when individual light contributions are added.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.Decal">
            <summary>
            	Decal stage, when texture detail is added to the lit base.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.RenderToTexture">
            <summary>
            	Render to texture stage, used for texture based shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.RenderReceiverPass">
            <summary>
            	Render from shadow texture to receivers stage.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IlluminationStage">
            <summary>
            	Possible stages of illumination during the rendering process.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationStage.Ambient">
            <summary>
            	Part of the rendering which occurs without any kind of direct lighting.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationStage.PerLight">
            <summary>
            	Part of the rendering which occurs per light.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationStage.Decal">
            <summary>
            	Post-lighting rendering.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IndexType">
            <summary>
            	Type of index buffer to use.
            </summary>
            <remarks>
            	No declarations can begin with a number, so Size prefix is used.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendOperation">
            <summary>
            	Lists the texture layer operations that are available on both multipass and multitexture
            	hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.Replace">
            <summary>
            	Replace all color with texture and no adjustment.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.Add">
            <summary>
            	Add color components together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.Modulate">
            <summary>
            	Multiply the color components together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.AlphaBlend">
            <summary>
            	Blend based on texture alpha.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendOperationEx">
            <summary>
            	Full and complete list of valid texture blending operations.  Fallbacks will be required on older hardware
            	that does not supports some of these multitexturing techniques.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Source1">
            <summary>
            	Use source 1 as is.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Source2">
            <summary>
            	Use source 2 as is.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Modulate">
            <summary>
            	Multiply source 1 and source 2 together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.ModulateX2">
            <summary>
            	Same as Modulate, but brightens as a result.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.ModulateX4">
            <summary>
            	Same as ModuleX2, but brightens even more as a result.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Add">
            <summary>
            	Add source 1 and source 2 together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.AddSigned">
            <summary>
            	Same as Add, but subtracts 0.5 from the result.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.AddSmooth">
            <summary>
            	Same as Add, but subtracts the product from the sum.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Subtract">
            <summary>
            	Subtract source 2 from source 1.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendDiffuseAlpha">
            <summary>
            	Use interpolated alpha value from vertices to scale source 1, then add source 2 scaled by 1 - alpha
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendTextureAlpha">
            <summary>
            	Same as BlendDiffuseAlpha, but uses current alpha from the texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendCurrentAlpha">
            <summary>
            	Same as BlendDiffuseAlpha, but uses current alpha from previous stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendManual">
            <summary>
            	Sames as BlendDiffuseAlpha, but uses a constant manual blend value from [0.0,1.0]
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendDiffuseColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.DotProduct">
            <summary>
            	Takes the dot product of color 1 and color 2.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendSource">
            <summary>
            	Valid sources of values for texture layer blending operations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Current">
            <summary>
            	The color as built up from previous stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Texture">
            <summary>
            	The color derived from the texture assigned to the current layer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Diffuse">
            <summary>
            	The interpolated diffuse color from the vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Specular">
            <summary>
            	The interpolated specular color from the vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Manual">
            <summary>
            	A color supplied manually as a seperate argument.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendType">
            <summary>
            	Texture blending mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendType.Color">
            <summary>
            	Based on diffuse color of the texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendType.Alpha">
            <summary>
            	Based on the alpha value of the texture.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LightType">
            <summary>
            	Defines the types of lights that can be added to a scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LightType.Point">
            <summary>
            	Point light sources give off light equally in all directions, so require only position not direction.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.LightType.Directional">
            <summary>
            	Directional lights simulate parallel light beams from a distant source, hence have direction but no position.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.LightType.Spotlight">
            <summary>
            	Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.ManualCullingMode">
            <summary>
            	Manual culling modes based on vertex normals.
            	This setting applies to how the software culls triangles before sending them to the 
            	hardware API. This culling mode is used by scene managers which choose to implement it -
            	normally those which deal with large amounts of fixed world geometry which is often 
            	planar (software culling movable variable geometry is expensive).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ManualCullingMode.None">
            <summary>
            	No culling so everything is sent to the hardware.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.ManualCullingMode.Back">
            <summary>
            	Cull triangles whose normal is pointing away from the camera (default).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.ManualCullingMode.Front">
            <summary>
            	Cull triangles whose normal is pointing towards the camera.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.Projection">
            <summary>
            Type of projection used by the camera.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Projection.Orthographic">
            <summary> Things stay the same size no matter where they are in terms of the camera.  Normally only used in 3D HUD elements. </summary>
        </member>
        <member name="F:Axiom.Graphics.Projection.Perspective">
            <summary> Things get smaller when they are furthur away from the camera. </summary>
        </member>
        <member name="T:Axiom.Graphics.OperationType">
            <summary>
            	Types for determining which render operation to do for a series of vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.PointList">
            <summary>
            	Render the vertices as individual points.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.LineList">
            <summary>
            	Render the vertices as a series of individual lines.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.LineStrip">
            <summary>
            	Render the vertices as a continuous line.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.TriangleList">
            <summary>
            	Render the vertices as a series of individual triangles.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.TriangleStrip">
            <summary>
            	Render the vertices as a continous set of triangles in a zigzag type fashion.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.TriangleFan">
            <summary>
            	Render the vertices as a set of trinagles in a fan like formation.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetPriority">
            <summary>
               Specifies priorities for processing Render Targets.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTargetPriority.Default">
            <summary>
               Will be processed last.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTargetPriority.RenderToTexture">
            <summary>
               Will be processed first (i.e. RenderTextures).
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SceneBlendFactor">
            <summary>
            	Blending factors for manually blending objects with the scene. If there isn't a predefined
            	SceneBlendType that you like, then you can specify the blending factors directly to affect the
            	combination of object and the existing scene. See Material.SceneBlending for more details.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.One">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.Zero">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.DestColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.SourceColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusDestColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusSourceColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.DestAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.SourceAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusDestAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusSourceAlpha">
            <summary></summary>
        </member>
        <member name="T:Axiom.Graphics.SceneBlendType">
            <summary>
            	Types of blending that you can specify between an object and the existing contents of the scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.TransparentAlpha">
            <summary>
            	Make the object transparent based on the final alpha values in the texture.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.TransparentColor">
            <summary>
            	Make the object transparent based on the color values in the texture (brighter = more opaque).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.Modulate">
            <summary>
            	Make the object transparent based on the color values in the texture (brighter = more opaque).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.Add">
            <summary>
            	Add the texture values to the existing scene content.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.Replace">
            <summary>
            The default blend mode where source replaces destination
            </summary>
        </member>
        <member name="T:Axiom.Graphics.PolygonMode">
            <summary>
            The broad type of detail for rendering.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.PolygonMode.Points">
            <summary>
            	Render subsequent requests drawing only the vertices in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.PolygonMode.Wireframe">
            <summary>
            	Render subsequent requests drawing only objects using wireframe mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.PolygonMode.Solid">
            <summary>
            	Render everything in the scene normally (textures, etc).
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Shading">
            <summary>
            Types for deciding how to shade geometry primitives.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Shading.Flat">
            <summary>
            	Draw with a single color.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.Shading.Gouraud">
            <summary>
            	Interpolate color across primitive vertices.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.Shading.Phong">
            <summary>
            	Draw everything (2 sided geometry).
             </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowRenderableFlags">
            <summary>
            	A set of flags that can be used to influence <see cref="T:Axiom.Graphics.ShadowRenderable"/> creation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderableFlags.IncludeLightCap">
            <summary>
            	For shadow volume techniques only, generate a light cap on the volume.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderableFlags.IncludeDarkCap">
            <summary>
            	For shadow volume techniques only, generate a dark cap on the volume.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderableFlags.ExtrudeToInfinity">
            <summary>
            	For shadow volume techniques only, indicates volume is extruded to infinity
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowTechnique">
            <summary>
            An enumeration of broad shadow techniques .
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.None">
            <summary>
            	No shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.StencilModulative">
            <summary>
            	Stencil shadow technique which renders all shadow volumes as
            	a modulation after all the non-transparent areas have been 
            	rendered. This technique is considerably less fillrate intensive 
            	than the additive stencil shadow approach when there are multiple
            	lights, but is not an accurate model. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.StencilAdditive">
            <summary>		
            	Stencil shadow technique which renders each light as a separate
            	additive pass to the scene. This technique can be very fillrate
            	intensive because it requires at least 2 passes of the entire
            	scene, more if there are multiple lights. However, it is a more
            	accurate model than the modulative stencil approach and this is
            	especially apparant when using coloured lights or bump mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.TextureModulative">
            <summary>
            	Texture-based shadow technique which involves a monochrome render-to-texture
            	of the shadow caster and a projection of that texture onto the 
            	shadow receivers as a modulative pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.TextureAdditive">
            <summary>
            	Texture-based shadow technique which involves a render-to-texture
            	of the shadow caster and a projection of that texture onto the 
            	shadow receivers, followed by a depth test to detect the closest
            	fragment to the light.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.StencilOperation">
            <summary>
            	Describes the various actions which can be taken on the stencil buffer.
            </summary> 
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Keep">
            <summary>
            	Leave the stencil buffer unchanged.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Zero">
            <summary>
            	Set the stencil value to zero.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Replace">
            <summary>
            	Set the stencil value to the reference value.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Increment">
            <summary>
            	Increase the stencil value by 1, clamping at the maximum value.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Decrement">
            <summary>
            	Decrease the stencil value by 1, clamping at 0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.IncrementWrap">
            <summary>
            	Increase the stencil value by 1, wrapping back to 0 when incrementing the maximum value.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.DecrementWrap">
            <summary>
            	Decrease the stencil value by 1, wrapping when decrementing 0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Invert">
            <summary>
            	Invert the bits of the stencil buffer.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureAddressing">
            <summary>
            Texture addressing modes - default is Wrap.
            </summary>
            <remarks>
               These settings are relevant in both the fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Wrap">
            <summary>
            	Texture wraps at values over 1.0 
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Mirror">
            <summary>
            	Texture mirrors (flips) at joins over 1.0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Clamp">
            <summary>
            	Texture clamps at 1.0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Border">
            <summary>
            	Values outside the range [0.0, 1.0] are set to the border colour
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TexCoordCalcMethod">
            <summary>
            	Describes the ways to generate texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.None">
            <summary>
            	No calculated texture coordinates.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.EnvironmentMap">
            <summary>
            	Environment map based on vertex normals.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.EnvironmentMapPlanar">
            <summary>
            	Environment map based on vertex positions.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.ProjectiveTexture">
            <summary>
            	Projective texture.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureCubeFace">
            <summary>
            Enum identifying the frame indexes for faces of a cube map (not the composite 3D type.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureEffectType">
            <summary>
               Definition of the broad types of texture effect you can apply to a texture layer.
            </summary>
            <remarks>
               Note that these have no effect when using the programmable pipeline, since their
               effect is overridden by the vertex / fragment programs.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.EnvironmentMap">
            <summary>
            	Generate all texture coords based on angle between camera and vertex.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.ProjectiveTexture">
            <summary>
            	Generate texture coords based on a frustum.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.UVScroll">
            <summary>
            	Constant u/v scrolling effect.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.UScroll">
            <summary>
            	Constant u scrolling effect.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.VScroll">
            <summary>
            	Constant v scrolling effect.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.Rotate">
            <summary>
            	Constant rotation.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.Transform">
            <summary>
            	More complex transform.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureFiltering">
            <summary>
               Texture filtering defining the different minification and magnification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.None">
            <summary>
            	Equal to: min=Point, mag=Point, mip=None
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.Bilinear">
            <summary>
            	Equal to: min=Linear, mag=Linear, mip=Point
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.Trilinear">
            <summary>
            	Equal to: min=Linear, mag=Linear, mip=Linear
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.Anisotropic">
            <summary>
               Equal to: min=Anisotropic, max=Anisotropic, mip=Linear
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureTransform">
            <summary>
            Useful enumeration when dealing with procedural transforms.
            </summary>
            <remarks>
               Note that these have no effect when using the programmable pipeline, since their
               effect is overridden by the vertex / fragment programs.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.TranslateU">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.TranslateV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.ScaleU">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.ScaleV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.Rotate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureType">
            <summary>
               Enum identifying the texture type.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.OneD">
            <summary>
               1D texture, used in combination with 1D texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.TwoD">
            <summary>
               2D texture, used in combination with 2D texture coordinates (default).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.ThreeD">
            <summary>
               3D volume texture, used in combination with 3D texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.CubeMap">
            <summary>
               3D cube map, used in combination with 3D texture coordinates.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureMipmap">
            <summary>
            Enum identifying special mipmap numbers
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureMipmap.Unlimited">
            Generate mipmaps up to 1x1
        </member>
        <member name="F:Axiom.Graphics.TextureMipmap.Default">
            Use TextureManager default
        </member>
        <member name="T:Axiom.Graphics.TextureUsage">
            <summary>
            	Specifies how a texture is to be used in the engine.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUsage.AutoMipMap">
            <summary>
               Mipmaps will be automatically generated for this texture
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUsage.RenderTarget">
            <summary>
               This texture will be a render target, ie. used as a target for render to texture
               setting this flag will ignore all other texture usages except AutoMipMap
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUsage.Default">
            <summary>
               Default to automatic mipmap generation static textures
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexFlags">
            <summary>
            	Types for definings what information a vertex will hold.
            </summary>
            <remarks>
            	Implemented with the Flags attribute to treat this enum with bitwise addition
            	and comparisons.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Position">
            <summary>
            	Specifies the 3D coordinates of the vertex.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.BlendWeights">
            <summary>
            	When applying 1 or more world matrices to a vertex, the weight values of a vertex dictate how much
            	of an effect each matrix has in determining its final position.  
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Normals">
            <summary>
            	Normal vector, determines the logical direction the vertex is facing for use in
            	lighting calculations.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.TextureCoords">
            <summary>
            	Texture coordinate for the vertex.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Diffuse">
            <summary>
            	The primary color of the vertex.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Specular">
            <summary>
            	Specular color for this vertex.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexElementSemantic">
            <summary>
                Vertex element semantics, used to identify the meaning of vertex buffer contents.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Position">
            <summary>
                Position, 3 reals per vertex.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.BlendWeights">
            <summary>
                Blending weights.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.BlendIndices">
            <summary>
                Blending indices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Normal">
            <summary>
                Normal, 3 reals per vertex.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Diffuse">
            <summary>
                Diffuse colors.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Specular">
            <summary>
                Specular colors.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.TexCoords">
            <summary>
                Texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Binormal">
            <summary>
                Binormal (Y axis if normal is Z).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Tangent">
            <summary>
                Tangent (X axis if normal is Z).
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexElementType">
            <summary>
                Vertex element type, used to identify the base types of the vertex contents.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementType.Color_ARGB">
            D3D style compact colour
        </member>
        <member name="F:Axiom.Graphics.VertexElementType.Color_ABGR">
            GL style compact colour
        </member>
        <member name="T:Axiom.Graphics.CompositorPassType">
            <summary>
                The types of compositing passes
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorPassType.Clear">
            <summary>
            Clear target to one colour
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorPassType.Stencil">
            <summary>
            Set stencil operation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorPassType.RenderScene">
            <summary>
            Render the scene or part of it
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositorPassType.RenderQuad">
            <summary>
            Render a full screen quad
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompositorInputMode">
            <summary>
                Input mode of a TargetPass
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData">
            <summary>
                This class contains the information required to describe the edge connectivity of a
                given set of vertices and indexes. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.triangles">
            <summary>
                List of triangles.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.edgeGroups">
            <summary>
                List of edge groups.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.UpdateTriangleLightFacing(Axiom.Math.Vector4)">
            <summary>
                Calculate the light facing state of the triangles in this edge list.
            </summary>
            <remarks>
                This is normally the first stage of calculating a silhouette, ie
                establishing which tris are facing the light and which are facing
                away. This state is stored in the 'lightFacing' flag in each 
                Triangle.
            </remarks>
            <param name="lightPos">
                4D position of the light in object space, note that 
                for directional lights (which have no position), the w component
                is 0 and the x/y/z position are the direction.
            </param>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.UpdateFaceNormals(System.Int32,Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
            	Updates the face normals for this edge list based on (changed)
            	position information, useful for animated objects. 
            </summary>
            <param name="vertexSet">The vertex set we are updating.</param>
            <param name="positionBuffer">The updated position buffer, must contain ONLY xyz.</param>
        </member>
        <member name="P:Axiom.Graphics.EdgeData.EdgeGroups">
            <summary>
                Accessor needed by Region.cs
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData.Triangle">
            <summary>
                Basic triangle structure.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.indexSet">
            <summary>
                The set of indexes this triangle came from (NB it is possible that the triangles on 
                one side of an edge are using a different vertex buffer from those on the other side.)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.vertexSet">
            <summary>
                The vertex set these vertices came from.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.vertIndex">
            <summary>
                Vertex indexes, relative to the original buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.sharedVertIndex">
            <summary>
                Vertex indexes, relative to a shared vertex buffer with 
                duplicates eliminated (this buffer is not exposed).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.normal">
            <summary>
                 Unit vector othogonal to this face, plus distance from origin.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.lightFacing">
            <summary>
                Working vector used when calculating the silhouette.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.Triangle.#ctor">
            <summary>
            	Default contructor.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData.Edge">
            <summary>
                Edge data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.triIndex">
            <summary>
                The indexes of the 2 tris attached, note that tri 0 is the one where the 
                indexes run *counter* clockwise along the edge. Indexes must be
                reversed for tri 1.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.vertIndex">
            <summary>
                The vertex indices for this edge. Note that both vertices will be in the vertex
                set as specified in 'vertexSet', which will also be the same as tri 0.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.sharedVertIndex">
            <summary>
                Vertex indices as used in the shared vertex list, not exposed.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.isDegenerate">
            <summary>
            	Indicates if this is a degenerate edge, ie it does not have 2 triangles.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.Edge.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData.EdgeGroup">
            <summary>
                A group of edges sharing the same vertex data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.EdgeGroup.vertexSet">
            <summary>
                The vertex set index that contains the vertices for this edge group.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.EdgeGroup.vertexData">
            <summary>
                Reference to vertex data used by this edge group.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.EdgeGroup.edges">
            <summary>
                The edges themselves.
            </summary>
        </member>
        <member name="T:Axiom.Core.ObjectCreator">
            <summary>
            Used by configuration classes to store assembly/class names and instantiate
            objects from them.
            </summary>
        </member>
        <member name="M:Axiom.Core.DynamicLoader.#ctor">
            <summary>
            Creates a loader instance for the current executing assembly
            </summary>
        </member>
        <member name="M:Axiom.Core.DynamicLoader.#ctor(System.String)">
            <summary>
            Creates a loader instance for the specified assembly
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshLodUsage">
            <summary>
            A way of recording the way each LOD is recorded this Mesh.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.UserValue">
            <summary>
            User-supplied values used to determine when th is lod applies.
            </summary>
            <remarks>
            This is required in case the lod strategy changes.
            </remarks>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.Value">
            <summary>
            Value used by to determine when this lod applies.
            </summary>
            <remarks>
            May be interpretted differently by different strategies.
            Transformed from user-supplied values with <see cref="M:Axiom.Core.LodStrategy.TransformUserValue(Axiom.Math.Real)"/>.
            </remarks>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.ManualName">
            <summary>
            Only relevant if isLodManual is true, the name of the alternative mesh to use.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.ManualMesh">
            <summary>
            	Reference to the manual mesh to avoid looking up each time.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.EdgeData">
            <summary>
            	Edge list for this LOD level (may be derived from manual mesh).
            </summary>
        </member>
        <member name="T:Axiom.Core.LogManager">
            <summary>
            Summary description for LogManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.LogManager.logList">
            <summary>
                List of logs created by the log manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.LogManager.defaultLog">
            <summary>
                The default log to which output is done.
            </summary>
        </member>
        <member name="M:Axiom.Core.LogManager.CreateLog(System.String)">
            <summary>
                Creates a new log with the given name.
            </summary>
            <param name="name">Name to give to the log, i.e. "Axiom.log"</param>
            <returns>A newly created Log object, opened and ready to go.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.CreateLog(System.String,System.Boolean)">
            <summary>
                Creates a new log with the given name.
            </summary>
            <param name="name">Name to give to the log, i.e. "Axiom.log"</param>
            <param name="isDefaultLog">
                If true, this is the default log output will be
                sent to if the generic logging methods on this class are
                used. The first log created is always the default log unless
                this parameter is set.
            </param>
            <returns>A newly created Log object, opened and ready to go.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.CreateLog(System.String,System.Boolean,System.Boolean)">
            <summary>
                Creates a new log with the given name.
            </summary>
            <param name="name">Name to give to the log, i.e. "Axiom.log"</param>
            <param name="isDefaultLog">
                If true, this is the default log output will be
                sent to if the generic logging methods on this class are
                used. The first log created is always the default log unless
                this parameter is set.
            </param>
            <param name="debuggerOutput">
                If true, output to this log will also be routed to <see cref="T:System.Diagnostics.Debug"/>
                Not only will this show the messages into the debugger, but also allows you to hook into
                it using a custom TraceListener to receive message notification wherever you want.
            </param>
            <returns>A newly created Log object, opened and ready to go.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.GetLog(System.String)">
            <summary>
                Retrieves a log managed by this class.
            </summary>
            <param name="name">Name of the log to retrieve.</param>
            <returns>Log with the specified name.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.Write(System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.LogManager.Write(System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.LogManager.Write(Axiom.Core.LogMessageLevel,System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <param name="level">Importance of this logged message.</param>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to
                inject into the formatted string.
            </param>
        </member>
        <member name="P:Axiom.Core.LogManager.DefaultLog">
            <summary>
                Gets/Sets the default log to use for writing.
            </summary>
            <value></value>
        </member>
        <member name="P:Axiom.Core.LogManager.LogDetail">
            <summary>
                Sets the level of detail of the default log.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.FrameTimeControllerValue">
            <summary>
            Summary description for FrameTimeControllerValue.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.FrameTimeControllerValue.frameTime">
            <summary>
            	Stores the value of the time elapsed since the last frame.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.FrameTimeControllerValue.timeFactor">
            <summary>
            	Float value that should be used to scale controller time.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.FrameTimeControllerValue.RenderSystem_FrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	Event handler to the Frame Started event so that we can capture the
            	time since last frame to use for controller functions.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Controllers.FrameTimeControllerValue.Axiom#Controllers#IControllerValue{System#Single}#Value">
            <summary>
            	Gets a time scaled value to use for controller functions.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.FrameTimeControllerValue.TimeFactor">
            <summary>
            	Float value that should be used to scale controller time.  This could be used
            	to either speed up or slow down controller functions independent of slowing
            	down the render loop.
            </summary>
        </member>
        <member name="T:Axiom.Collections.KeyFrameCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Animating.KeyFrame">KeyFrames</see>.
            </summary>
        </member>
        <member name="T:Axiom.Animating.InterpolationMode">
            <summary>
            	Types of interpolation used in animation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.InterpolationMode.Linear">
            <summary>
            	Values are interpolated along straight lines.  
            	More robotic movement, not as realistic.
             </summary>
        </member>
        <member name="F:Axiom.Animating.InterpolationMode.Spline">
            <summary>
            	Values are interpolated along a spline, resulting in smoother changes in direction.  
            	Smooth movement between keyframes.
             </summary>
        </member>
        <member name="T:Axiom.Animating.RotationInterpolationMode">
            <summary>
            The types of rotational interpolation available.
            </summary>
        </member>
        <member name="F:Axiom.Animating.RotationInterpolationMode.Linear">
            <summary>
            Values are interpolated linearly. This is faster but does not 
               necessarily give a completely accurate result.
            </summary>
        </member>
        <member name="F:Axiom.Animating.RotationInterpolationMode.Spherical">
            <summary>
             Values are interpolated spherically. This is more accurate but
               has a higher cost.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Animation">
            <summary>
            	An animation sequence. 
            </summary>
            <remarks>
            	This class defines the interface for a sequence of animation, whether that
            	be animation of a mesh, a path along a spline, or possibly more than one
            	type of animation in one. An animation is made up of many 'tracks', which are
            	the more specific types of animation.
            	<p/>
            	You should not create these animations directly. They will be created via a parent
            	object which owns the animation, e.g. Skeleton, SceneManager, etc.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Animation.name">
            <summary>Name of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.length">
            <summary>The total length of this animation (sum of the tracks).</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.nodeTrackList">
            <summary>Collection of NodeAnimationTracks.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.numericTrackList">
            <summary>Collection of NumericAnimationTracks.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.vertexTrackList">
            <summary>Collection of VertexAnimationTracks.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.interpolationMode">
            <summary>Interpolation mode of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.rotationInterpolationMode">
            <summary>Rotation interpolation mode of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.defaultInterpolationMode">
            <summary>Default interpolation mode of any animations.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.defaultRotationInterpolationMode">
            <summary>default rotation interpolation mode of this animation.</summary>
        </member>
        <member name="M:Axiom.Animating.Animation.#cctor">
            <summary>Static constructor.</summary>
        </member>
        <member name="M:Axiom.Animating.Animation.#ctor(System.String,System.Single)">
            <summary>
            	Internal constructor, to prevent from using new outside of the engine.
            	<p/>
            	Animations should be created within objects that can own them (skeletons, scene managers, etc).
            </summary>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateNodeTrack(System.UInt16)">
            <summary>
            	Creates an NodeAnimationTrack. 
            </summary>
            <param name="handle">Handle to give the track, used for accessing the track later.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateNodeTrack(System.UInt16,Axiom.Core.Node)">
            <summary>
            	Creates a new NodeAnimationTrack automatically associated with a Node. 
            </summary>
            <param name="handle">Handle to give the track, used for accessing the track later.</param>
            <param name="targetNode">Node object which will be affected by this track.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateNumericTrack(System.UInt16)">
            <summary>
            	Creates an NumericAnimationTrack. 
            </summary>
            <param name="handle">Handle to give the track, used for accessing the track later.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateNumericTrack(System.UInt16,Axiom.Animating.AnimableValue)">
            <summary>
            	Creates a new NumericAnimationTrack automatically associated with a Numeric. 
            </summary>
            <param name="handle">Handle to give the track, used for accessing the track later.</param>
            <param name="animable">AnimableValue which will be affected by this track.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateVertexTrack(System.UInt16,Axiom.Animating.VertexAnimationType)">
            <summary>
            	Creates an VertexAnimationTrack. 
            </summary>
            <param name="handle">Handle to give the track, used for accessing the track later.</param>
            <param name="animType"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateVertexTrack(System.UInt16,Axiom.Graphics.VertexData,Axiom.Animating.VertexAnimationType)">
            <summary>
            	Creates a new VertexAnimationTrack automatically associated with a Vertex. 
            </summary>
            <param name="handle">Handle to give the track, used for accessing the track later.</param>
            <param name="targetVertexData">Vertex object which will be affected by this track.</param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.Apply(System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            	Applies an animation given a specific time point and weight.
            </summary>
            <remarks>
            	Where you have associated animation tracks with Node objects, you can eaily apply
            	an animation to those nodes by calling this method.
            </remarks>
            <param name="time">The time position in the animation to apply.</param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
            	other animations.</param>
            <param name="accumulate"></param>
            <param name="scale"></param>
        </member>
        <member name="P:Axiom.Animating.Animation.Name">
            <summary>
            	Gets the name of this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.Length">
            <summary>
            	Gets the total length of this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.InterpolationMode">
            <summary>
            	Gets/Sets the current interpolation mode for this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.RotationInterpolationMode">
            <summary>
            	Gets/Sets the current interpolation mode for this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.NodeTracks">
            <summary>
            	A collection of the node tracks in this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.NumericTracks">
            <summary>
            	A collection of the numeric tracks in this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.VertexTracks">
            <summary>
            	A collection of the vertex tracks in this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.DefaultInterpolationMode">
            <summary>
            	Gets/Sets the default interpolation mode to be used for all animations.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.DefaultRotationInterpolationMode">
            <summary>
            	Gets/Sets the default interpolation mode to be used for all animations.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.DefaultHardwareBufferManagerBase">
            <summary>
            Specialization of HardwareBufferManagerBase to emulate hardware buffers.
            </summary>
            <remarks>
            You might want to instantiate this class if you want to utilize
            classes like MeshSerializer without having initialized the 
            rendering system (which is required to create a 'real' hardware
            buffer manager.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.DefaultHardwareBufferManagerBase.CreateVertexBuffer(Axiom.Graphics.VertexDeclaration,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            Creates a vertex buffer
        </member>
        <member name="M:Axiom.Graphics.DefaultHardwareBufferManagerBase.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            Create a hardware vertex buffer
        </member>
        <member name="M:Axiom.Graphics.DefaultHardwareBufferManagerBase.dispose(System.Boolean)">
            Create a hardware vertex buffer
        </member>
        <member name="T:Axiom.Core.LodStrategyManager">
            <summary>
            Manager for lod strategies.
            </summary>
        </member>
        <member name="F:Axiom.Core.LodStrategyManager._strategies">
            <summary>
            Internal map of strategies.
            </summary>
        </member>
        <member name="F:Axiom.Core.LodStrategyManager._defaultStrategy">
            <summary>
            Default strategy.
            </summary>
        </member>
        <member name="M:Axiom.Core.LodStrategyManager.SetDefaultStrategy(System.String)">
            <summary>
            Set the default strategy by name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.LodStrategyManager.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.LodStrategyManager.AddStrategy(Axiom.Core.LodStrategy)">
            <summary>
            Add a strategy to the manager.
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Axiom.Core.LodStrategyManager.RemoveStrategy(System.String)">
            <summary>
            Remove a strategy from the manager with a specified name.
            </summary>
            <remarks>
            The removed strategy is returned so the user can control
            how it is destroyed.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LodStrategyManager.RemoveAllStrategies">
            <summary>
             Remove and delete all strategies from the manager.
            </summary>
            <remarks>
            All strategies are deleted.  If finer control is required
            over strategy destruction, use removeStrategy.
            </remarks>
        </member>
        <member name="M:Axiom.Core.LodStrategyManager.GetStrategy(System.String)">
            <summary>
            Get the strategy with the specified name.
            </summary>
            <param name="name">name of the strategy</param>
            <returns>strategy with the given name</returns>
        </member>
        <member name="P:Axiom.Core.LodStrategyManager.DefaultStrategy">
            <summary>
            Get's or set's the default strategy.
            </summary>
        </member>
        <member name="T:Axiom.Collections.NamedParameterList">
            <summary>
            Represents a collection of names and parameters.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.Compiler.ScriptCompilerEvent">
            <summary>
            This struct is a base class for events which can be thrown by the compilers and caught by
            subscribers. There are a set number of standard events which are used by Ogre's core.
            New event types may be derived for more custom compiler processing.
            </summary>
        </member>
        <member name="P:Axiom.Scripting.Compiler.ScriptCompilerEvent.Type">
            <summary>
            Return the type of this ScriptCompilerEvent
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleAffector">
            <summary>
            	Abstract class defining the interface to be implemented by particle affectors.
            </summary>
            <remarks>
            	Particle affectors modify particles in a particle system over their lifetime. They can be
            	grouped into types, e.g. 'vector force' affectors, 'fader' affectors etc; each type will
            	modify particles in a different way, using different parameters.
            	<para/>
            	Because there are so many types of affectors you could use, the engine chooses not to dictate
            	the available types. It comes with some in-built, but allows plugins or applications to extend the affector types available.
            	This is done by subclassing ParticleAffector to have the appropriate emission behavior you want,
            	and also creating a subclass of ParticleAffectorFactory which is responsible for creating instances
            	of your new affector type. You register this factory with the ParticleSystemManager using
            	AddAffectorFactory, and from then on affectors of this type can be created either from code or through
            	.particle scripts by naming the type.
            	<para/>
            	This same approach is used for ParticleEmitters (which are the source of particles in a system).
            	This means that the engine is particularly flexible when it comes to creating particle system effects,
            	with literally infinite combinations of affector and affector types, and parameters within those
            	types.
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleAffector.type">
            <summary>Name of the affector type.  Must be initialized by subclasses.</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.AffectParticles(Axiom.ParticleSystems.ParticleSystem,System.Single)">
            <summary>
            	Method called to allow the affector to 'do it's stuff' on all active particles in the system.
            </summary>
            <remarks>
            	This is where the affector gets the chance to apply it's effects to the particles of a system.
            	The affector is expected to apply it's effect to some or all of the particles in the system
            	passed to it, depending on the affector's approach.
            </remarks>
            <param name="system">Reference to a ParticleSystem to affect.</param>
            <param name="timeElapsed">The number of seconds which have elapsed since the last call.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.CopyTo(Axiom.ParticleSystems.ParticleAffector)">
             <summary>
            
             </summary>
             <param name="affector"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.InitParticle(Axiom.ParticleSystems.Particle@)">
            <summary>
            	Method called to allow the affector to 'do it's stuff' on all active particles in the system.
            </summary>
            <remarks>
            	This is where the affector gets the chance to apply it's effects to the particles of a system.
            	The affector is expected to apply it's effect to some or all of the particles in the system
            	passed to it, depending on the affector's approach.
            </remarks>
            <param name="particle">Reference to a ParticleSystem to affect.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.SetParam(System.String,System.String)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.RegisterCommands">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleAffector.Type">
            <summary>
            	Gets the type name of this affector.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TempBlendedBufferInfo">
            <summary>
                Records the use of temporary blend buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.srcPositionBuffer">
            <summary>
                Pre-blended position buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.srcNormalBuffer">
            <summary>
                Pre-blended normal buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.srcTangentBuffer">
            <summary>
                Pre-blended tangent buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.srcBinormalBuffer">
            <summary>
                Pre-blended binormal buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.destPositionBuffer">
            <summary>
                Post-blended position buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.destNormalBuffer">
            <summary>
                Post-blended normal buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.destTangentBuffer">
            <summary>
                Post-blended tangent buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.destBinormalBuffer">
            <summary>
                Post-blended binormal buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.posNormalShareBuffer">
            <summary>
                Both positions and normals are contained in the same buffer
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.posBindIndex">
            <summary>
                Index at which the positions are bound in the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.normBindIndex">
            <summary>
                Index at which the normals are bound in the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.tanBindIndex">
            <summary>
                Index at which the tangents are bound in the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.binormBindIndex">
            <summary>
                Index at which the binormals are bound in the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.bindPositions">
            <summary>
            	Should we bind the position buffer
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.bindNormals">
            <summary>
            	Should we bind the normals buffer
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.bindTangents">
            <summary>
            	Should we bind the tangents buffer
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.bindBinormals">
            <summary>
            	Should we bind the binormals buffer
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.ExtractFrom(Axiom.Graphics.VertexData)">
            <summary>
            	Utility method, extract info from the given VertexData
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.CheckoutTempCopies(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Utility method, checks out temporary copies of src into dest.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.BuffersCheckedOut(System.Boolean,System.Boolean)">
            <summary>
                Detect currently have buffer copies checked out and touch it
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.BindTempCopies(Axiom.Graphics.VertexData,System.Boolean)">
            <summary>
                Utility method, binds dest copies into a given VertexData.
            </summary>
            <param name="targetData">VertexData object to bind the temp buffers into.</param>
            <param name="suppressHardwareUpload"></param>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.LicenseExpired(Axiom.Graphics.HardwareBuffer)">
            <summary>
                Implementation of LicenseExpired.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="T:Axiom.Graphics.RenderWindow">
             <summary>
            		Manages the target rendering window.
             </summary>
             <remarks>
            		This class handles a window into which the contents
            		of a scene are rendered. There is a many-to-1 relationship
            		between instances of this class an instance of RenderSystem
            		which controls the rendering of the scene. There may be
            		more than one window in the case of level editor tools etc.
            		This class is abstract since there may be
            		different implementations for different windowing systems.
            
            		Instances are created and communicated with by the render system
            		although client programs can get a reference to it from
            		the render system if required for resizing or moving.
            		Note that you can have multiple viewpoints
            		in the window for effects like rear-view mirrors and
            		picture-in-picture views (see Viewport and Camera).
            	</remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.Create(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)">
            <summary>
            	Creates &amp; displays the new window.
            </summary>
            <param name="name"></param>
            <param name="width">The width of the window in pixels.</param>
            <param name="height">The height of the window in pixels.</param>
            <param name="fullScreen">If true, the window fills the screen, with no title bar or border.</param>
            <param name="miscParams">A variable number of platform-specific arguments. 
            The actual requirements must be defined by the implementing subclasses.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.Resize(System.Int32,System.Int32)">
            <summary>
            	Alter the size of the window.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.Reposition(System.Int32,System.Int32)">
            <summary>
            	Reposition the window.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.WindowMovedOrResized">
            <summary>
            Notify that the window has been resized
            </summary>
            <remarks>You don't need to call this unless you created the window externally.</remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.GetMetrics(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieve information about the render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.top">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.left">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsFullScreen">
            <summary>
            Returns true if window is running in fullscreen mode.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsVisible">
            <summary>
            Indicates whether the window is visible (not minimized or obscured)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsClosed">
            <summary>
            Indicates whether the window has been closed by the user.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsPrimary">
            <summary>
            Indicates wether the window is the primary window. The
            primary window is special in that it is destroyed when 
            ogre is shut down, and cannot be destroyed directly.
            This is the case because it holds the context for vertex,
            index buffers and textures.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GPUVendor">
            <summary>
            Enumeration of GPU vendors.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderSystemCapabilities">
            <summary>
            	This serves as a way to query information about the capabilies of a 3D API and the
            	users hardware configuration.  A RenderSystem should create and initialize an instance
            	of this class during startup so that it will be available for use ASAP for checking caps.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._caps">
            <summary>
               Flag enum holding the bits that identify each supported feature.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._textureUnitCount">
            <summary>
               Max number of texture units available on the current hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._worldMatrixCount">
            <summary>
               Max number of world matrices supported.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._maxVertexProgramVersion">
            <summary>
               The best vertex program version supported by the hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._vertexProgramConstantFloatCount">
            <summary>
               The number of floating point constants the current hardware supports for vertex programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._vertexProgramConstantIntCount">
            <summary>
               The number of integer constants the current hardware supports for vertex programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._vertexProgramConstantBoolCount">
            <summary>
               The number of boolean constants the current hardware supports for vertex programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._maxFragmentProgramVersion">
            <summary>
               The best fragment program version supported by the hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._fragmentProgramConstantFloatCount">
            <summary>
               The number of floating point constants the current hardware supports for fragment programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._fragmentProgramConstantIntCount">
            <summary>
               The number of integer constants the current hardware supports for fragment programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._fragmentProgramConstantBoolCount">
            <summary>
               The number of boolean constants the current hardware supports for fragment programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._multiRenderTargetCount">
            <summary>
            The number of simultaneous render targets supported
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._stencilBufferBitCount">
            <summary>
               Stencil buffer bits available.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._maxLights">
            <summary>
               Maximum number of lights that can be active in the scene at any given time.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._deviceName">
            <summary>
            name of the adapter
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._driverVersion">
            <summary>
            This is used to build a database of RSC's
            if a RSC with same name, but newer version is introduced, the older one 
            will be removed
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._maxPointSize">
            <summary>
            The maximum point size
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._nonPOW2TexturesLimited">
            <summary>
            Are non-POW2 textures feature-limited?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._vertexTextureUnitCount">
            <summary>
            The number of vertex texture units supported
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities._vertexTextureUnitsShared">
            <summary>
            Are vertex texture units shared with fragment processor?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.HasCapability(Axiom.Graphics.Capabilities)">
            <summary>
               Returns true if the current hardware supports the requested feature.
            </summary>
            <param name="cap">Feature to query (i.e. Dot3 bump mapping)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.SetCapability(Axiom.Graphics.Capabilities)">
            <summary>
               Sets a flag stating the specified feature is supported.
            </summary>
            <param name="cap"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.Log">
            <summary>
               Write all hardware capability information to registered listeners.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.Log(Axiom.Core.Log)">
            <summary>
               Write all hardware capability information to registered listeners.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.ConvertBool(System.Boolean)">
            <summary>
                Helper method to convert true/false to yes/no.
            </summary>
            <param name="val">Bool bal.</param>
            <returns>"yes" if true, else "no".</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.VendorFromString(System.String)">
            <summary>
            
            </summary>
            <param name="vendorString"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.VendorToString(Axiom.Graphics.GPUVendor)">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Graphics.RenderSystemCapabilities.ShaderProfiles">
            <summary>
            Returns a set of all supported shader profiles
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.AddShaderProfile(System.String)">
            <summary>
             Adds the profile to the list of supported profiles
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.RemoveShaderProfile(System.String)">
            <summary>
            Remove a given shader profile, if present.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystemCapabilities.IsShaderProfileSupported(System.String)">
            <summary>
            Returns true if profile is in the list of supported profiles
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.RendersystemName">
            <summary>
            Gets or sets the current rendersystem name.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.TextureUnitCount">
            <summary>
            	Reports on the number of texture units the graphics hardware has available.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.WorldMatrixCount">
            <summary>
               Max number of world matrices supported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.MaxVertexProgramVersion">
            <summary>
               Best vertex program version supported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.VertexProgramConstantFloatCount">
            <summary>
               Max number of floating point constants supported by the hardware for vertex programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.VertexProgramConstantIntCount">
            <summary>
               Max number of integer constants supported by the hardware for vertex programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.VertexProgramConstantBoolCount">
            <summary>
               Max number of boolean constants supported by the hardware for vertex programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.MaxFragmentProgramVersion">
            <summary>
               Best fragment program version supported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.FragmentProgramConstantFloatCount">
            <summary>
               Max number of floating point constants supported by the hardware for fragment programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.FragmentProgramConstantIntCount">
            <summary>
               Max number of integer constants supported by the hardware for fragment programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.FragmentProgramConstantBoolCount">
            <summary>
               Max number of boolean constants supported by the hardware for fragment programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.MultiRenderTargetCount">
            <summary>
            The number of simultaneous render targets supported
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.StencilBufferBitCount">
            <summary>
            	Number of stencil buffer bits suppported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.MaxLights">
            <summary>
            	Maximum number of lights that can be active in the scene at any given time.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.DeviceName">
            <summary>
            Name of the display adapter
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.DriverVersion">
            <summary>
            The driver version string
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.MaxPointSize">
            <summary>
            The maximum point size
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.NonPOW2TexturesLimited">
            <summary>
            Are non-POW2 textures feature-limited?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.VertexTextureUnitCount">
            <summary>
            The number of vertex texture units supported
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystemCapabilities.VertexTextureUnitsShared">
            <summary>
            Are vertex texture units shared with fragment processor?
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramUsage">
            <summary>
            	This class makes the usage of a vertex and fragment programs (low-level or high-level), 
            	with a given set of parameters, explicit.
            </summary>
            <remarks>
            	Using a vertex or fragment program can get fairly complex; besides the fairly rudimentary
            	process of binding a program to the GPU for rendering, managing usage has few
            	complications, such as:
            	<ul>
            	<li>Programs can be high level (e.g. Cg, GLSlang) or low level (assembler). Using
            	either should be relatively seamless, although high-level programs give you the advantage
            	of being able to use named parameters, instead of just indexed registers</li>
            	<li>Programs and parameters can be shared between multiple usages, in order to save
            	memory</li>
            	<li>When you define a user of a program, such as a material, you often want to be able to
            	set up the definition but not load / compile / assemble the program at that stage, because
            	it is not needed just yet. The program should be loaded when it is first needed, or
            	earlier if specifically requested. The program may not be defined at this time, you
            	may want to have scripts that can set up the definitions independent of the order in which
            	those scripts are loaded.</li>
            	</ul>
            	This class packages up those details so you don't have to worry about them. For example,
            	this class lets you define a high-level program and set up the parameters for it, without
            	having loaded the program (which you normally could not do). When the program is loaded and
            	compiled, this class will then validate the parameters you supplied earlier and turn them
            	into runtime parameters.
            	<p/>
            	Just incase it wasn't clear from the above, this class provides linkage to both 
            	GpuProgram and HighLevelGpuProgram, despite its name.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramUsage.type">
            <summary>
               Type of program (vertex or fragment) this usage is being specified for.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramUsage.program">
            <summary>
               Reference to the program whose usage is being specified within this class.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramUsage.parameters">
            <summary>
               Low level GPU program parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.#ctor(Axiom.Graphics.GpuProgramType)">
            <summary>
               Default constructor.
            </summary>
            <param name="type">Type of program to link to.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.Clone">
            <summary>
            	Creates and returns a copy of this GpuProgramUsage object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.Load">
            <summary>
               Load this usage (and ensure program is loaded).
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.Unload">
            <summary>
               Unload this usage.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.Params">
            <summary>
               Gets/Sets the program parameters that should be used; because parameters can be
               shared between multiple usages for efficiency, this method is here for you
               to register externally created parameter objects.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.Program">
            <summary>
               Gets the program this usage is linked to; only available after the usage has been
               validated either via enableValidation or by enabling validation on construction.
            </summary>
            <remarks>
               Note that this will create a fresh set of parameters from the
               new program being linked, so if you had previously set parameters
               you will have to set them again.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.ProgramName">
            <summary>
               Gets/Sets the name of the program we're trying to link to.
            </summary>
            <remarks>
               Note that this will create a fresh set of parameters from the 
               new program being linked, so if you had previously set parameters 
               you will have to set them again. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.Type">
            <summary>
               Gets the type of program we're trying to link to.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.TextureFrameControllerValue">
            <summary>
                Predefined controller value for getting/setting the frame number of a texture unit.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.TextureFrameControllerValue.texUnit">
            <summary>
                Reference to the texture unit state to target for the animation.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Canned.TextureFrameControllerValue.#ctor(Axiom.Graphics.TextureUnitState)">
            <summary>
                Constructor.
            </summary>
            <param name="textureUnit">Reference to the texture unit state to target for the animation.</param>
        </member>
        <member name="P:Axiom.Controllers.Canned.TextureFrameControllerValue.Value">
            <summary>
                Gets/Sets the frame of animation for a texture unit.
            </summary>
            <remarks>
                Value is a parametric value in the range [0,1].
            </remarks>
        </member>
        <member name="T:Axiom.Configuration.ConfigOption`1">
            <summary>
            Packages the details of a configuration option.
            </summary>
            <remarks>Used for <see cref="P:Axiom.Graphics.RenderSystem.ConfigOptions"/>. If immutable is true, this option must be disabled for modifying.</remarks>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption`1.Name">
            <summary>
            The name for the Configuration Option
            </summary>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption`1.Value">
            <summary>
            The value of the Configuration Option
            </summary>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption`1.PossibleValues">
            <summary>
            A list of the possible values for this Configuration Option
            </summary>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption`1.Immutable">
            <summary>
            Indicates if this option can be modified.
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimationState">
            <summary>
            	Represents the state of an animation and the weight of it's influence. 
            </summary>
            <remarks>
            	Other classes can hold instances of this class to store the state of any animations
            	they are using.
            	This class implements the IControllerValue interface to enable automatic update of
            	animation state through controllers.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.AnimationState.animationName">
            <summary>Name of this animation track.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.time">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.length">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.inverseLength">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.weight">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.isEnabled">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.parent">
            <summary></summary>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(System.String,Axiom.Animating.AnimationStateSet,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            	
            </summary>
            <param name="animationName"></param>
            <param name="parent">The animation state set parent</param>
            <param name="time"></param>
            <param name="length"></param>
            <param name="weight"></param>
            <param name="isEnabled"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(System.String,Axiom.Animating.AnimationStateSet,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="animationName"></param>
            <param name="animationStates">The animation state set parent</param>
            <param name="time"></param>
            <param name="length"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(Axiom.Animating.AnimationStateSet,Axiom.Animating.AnimationState)">
            <summary>
                The moral equivalent of a copy constructor
            </summary>
            <param name="parent">The animation state set parent</param>
            <param name="source">An animation state to copy from</param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.AddTime(System.Single)">
            <summary>
            	Modifies the time position, adjusting for animation length.
            </summary>
            <param name="offset">Offset from the current time position.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.CopyFrom(Axiom.Animating.AnimationState)">
            <summary>
            Copies the states from another animation state, preserving the animation name
            (unlike CopyTo) but copying everything else.
            </summary>
            <param name="source">animation state which will use as source.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.GetHashCode">
            <summary>
               Override GetHashCode.
            </summary>
            <remarks>
               Done mainly to quash warnings, no real need for it.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.AnimationState.CompareTo(System.Object)">
            <summary>
               
            </summary>
            <param name="obj"></param>
            <returns>0 if they are the same, -1 otherwise.</returns>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Name">
            <summary>
            	Gets the name of the animation to which this state applies
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Time">
            <summary>
            	Gets/Sets the time position for this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Length">
            <summary>
            	Gets/Sets the total length of this animation (may be shorter than whole animation)
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Weight">
            <summary>
            Gets/Sets the weight (influence) of this animation
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.IsEnabled">
            <summary>
            	Gets/Sets whether this animation is enabled or not.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Parent">
            <summary>
            	Gets/Sets the animation state set owning this animation
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Value">
            <summary>
            	Gets/Sets the value to be used in a ControllerFunction.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.NullProgram.IsSupported">
            <summary>
            Overridden from GpuProgram - never supported
            </summary>
        </member>
        <member name="P:Axiom.Graphics.NullProgramFactory.Language">
            <summary>
            Get the name of the language this factory creates programs for
            </summary>
        </member>
        <member name="T:Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair">
            <summary>
            Represents a pair of a <see cref="T:Axiom.Core.MovableObject"/> and a <see cref="T:Axiom.Core.SceneQuery.WorldFragment"/>.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair.#ctor(Axiom.Core.MovableObject,Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            Initializes a new instance of the <see cref="T:Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair"/> class.
            </summary>
            <param name="obj">A <see cref="T:Axiom.Core.MovableObject"/>.</param>
            <param name="fragment">A <see cref="T:Axiom.Core.SceneQuery.WorldFragment"/>.</param>
        </member>
        <member name="P:Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair.fragment">
            <summary>
            Gets or sets the <see cref="T:Axiom.Core.SceneQuery.WorldFragment"/>.
            </summary>
            <value>A <see cref="T:Axiom.Core.SceneQuery.WorldFragment"/>.</value>
        </member>
        <member name="P:Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair.obj">
            <summary>
            Gets or sets the <see cref="T:Axiom.Core.MovableObject"/>.
            </summary>
            <value>A <see cref="T:Axiom.Core.MovableObject"/>.</value>
        </member>
        <member name="T:Axiom.Collections.SceneQueryMovableObjectWorldFragmentIntersectionList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair">SceneQueryMovableObjectWorldFragmentPairs</see> that are sorted by name.
            </summary>
        </member>
        <member name="T:Axiom.Collections.SceneQueryMovableObjectPair">
            <summary>
            Represents a pair of two <see cref="T:Axiom.Core.MovableObject">MovableObjects</see>.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneQueryMovableObjectPair.#ctor(Axiom.Core.MovableObject,Axiom.Core.MovableObject)">
            <summary>
            Initializes a new instance of the <see cref="T:Axiom.Collections.SceneQueryMovableObjectPair"/> class.
            </summary>
            <param name="first">The first <see cref="T:Axiom.Core.MovableObject"/>.</param>
            <param name="second">The second <see cref="T:Axiom.Core.MovableObject"/>.</param>
        </member>
        <member name="P:Axiom.Collections.SceneQueryMovableObjectPair.first">
            <summary>
            Gets or sets the first <see cref="T:Axiom.Core.MovableObject"/>.
            </summary>
            <value>A <see cref="T:Axiom.Core.MovableObject"/>.</value>
        </member>
        <member name="P:Axiom.Collections.SceneQueryMovableObjectPair.second">
            <summary>
            Gets or sets the second <see cref="T:Axiom.Core.MovableObject"/>.
            </summary>
            <value>A <see cref="T:Axiom.Core.MovableObject"/>.</value>
        </member>
        <member name="T:Axiom.Collections.SceneQueryMovableObjectIntersectionList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Collections.SceneQueryMovableObjectPair">SceneQueryMovableObjectPairs</see>
            </summary>
        </member>
        <member name="T:Axiom.Animating.Collections.AnimationTrackCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Core.SceneNode">SceneNodes</see> that are sorted by key.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Collections.AnimationTrackCollection.Add(Axiom.Animating.AnimationTrack)">
            <summary>
            Adds an <see cref="T:Axiom.Animating.AnimationTrack"/> to the collection and uses its handle automatically as the key.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Axiom.Animating.AnimationStateSet">
            <summary>
            	Represents the state of an animation and the weight of it's influence. 
            </summary>
            <remarks>
            	Other classes can hold instances of this class to store the state of any animations
            	they are using.
            	This class implements the IControllerValue interface to enable automatic update of
            	animation state through controllers.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.AnimationStateSet.stateSet">
            <summary>
            	Mapping from string to AnimationState
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationStateSet.dirtyFrameNumber">
            <summary>
            	
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationStateSet.enabledAnimationStates">
            <summary>
            	A list of enabled animation states
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.Clone">
            <summary>
                Create a copy of the AnimationStateSet instance. 
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.CreateAnimationState(System.String,System.Single,System.Single)">
            <summary>
                Create a new AnimationState instance. 
            </summary>
            <param name="name"> The name of the animation</param>
            <param name="time"> Starting time position</param>
            <param name="length"> Length of the animation to play</param>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.CreateAnimationState(System.String,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
                Create a new AnimationState instance. 
            </summary>
            <param name="name"> The name of the animation</param>
            <param name="time"> Starting time position</param>
            <param name="length"> Length of the animation to play</param>
            <param name="weight"> Weight to apply the animation with</param>
            <param name="enabled"> Whether the animation is enabled</param>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.GetAnimationState(System.String)">
            <summary>
                Get an animation state by the name of the animation
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.HasAnimationState(System.String)">
            <summary>
                Tests if state for the named animation is present
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.RemoveAnimationState(System.String)">
            <summary>
                Remove animation state with the given name
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.RemoveAllAnimationStates">
            <summary>
                Remove all animation states
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.CopyMatchingState(Axiom.Animating.AnimationStateSet)">
            <summary>
                Copy the state of any matching animation states from this to another
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.NotifyDirty">
            <summary>
                Set the dirty flag and dirty frame number on this state set
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationStateSet.NotifyAnimationStateEnabled(Axiom.Animating.AnimationState,System.Boolean)">
            <summary>
                Internal method respond to enable/disable an animation state
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationStateSet.DirtyFrameNumber">
            <summary>
                Get the latest animation state been altered frame number
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationStateSet.AllAnimationStates">
            <summary>
                Get the dictionary of states
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationStateSet.EnabledAnimationStates">
            <summary>
                Get the list of enabled animation states
            </summary>
        </member>
        <member name="T:Axiom.Scripting.ParseHelper">
            <summary>
            	Class contining helper methods for parsing text files.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.Combine(System.String[],System.Int32,System.Int32)">
            <summary>
               Helper method for taking a string array and returning a single concatenated
               string composed of the range of specified elements.
            </summary>
            <param name="items"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.LogParserError(System.String,System.String,System.String)">
            <summary>
            	Helper method to log a formatted error when encountering problems with parsing
            	an attribute.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.ReadLine(System.IO.TextReader)">
            <summary>
            	Helper method to nip/tuck the string before parsing it.  This includes trimming spaces from the beginning
            	and end of the string, as well as removing excess spaces in between values.
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.GetParams(System.String[])">
            <summary>
            	Helper method to remove the first item from a string array and return a new array 1 element smaller
            	starting at the second element of the original array.  This helpe to seperate the params from the command
            	in the various script files.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.SkipToNextOpenBrace(System.IO.TextReader)">
            <summary>
               Advances in the stream until it hits the next {.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.SkipToNextCloseBrace(System.IO.TextReader)">
            <summary>
               Advances in the stream until it hits the next }.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="T:Axiom.Scripting.Compiler.AST.PropertyAbstractNode">
            <summary>
            This abstract node represents a script property
            </summary>
        </member>
        <member name="M:Axiom.Scripting.Compiler.AST.PropertyAbstractNode.Clone">
            <see cref="M:Axiom.Scripting.Compiler.AST.AbstractNode.Clone"/>
        </member>
        <member name="P:Axiom.Scripting.Compiler.AST.PropertyAbstractNode.Value">
            <see cref="P:Axiom.Scripting.Compiler.AST.AbstractNode.Value"/>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleSystemAttributeParser">
            <summary>
                Particle system attribute method definition.
            </summary>
            <param name="values">Attribute values.</param>
            <param name="system">Target particle system.</param>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleSystem">
            <summary>
            	Class defining particle system based special effects.
            </summary>
            <remarks>
                Particle systems are special effects generators which are based on a 
                number of moving points to create the impression of things like like 
                sparkles, smoke, blood spurts, dust etc.
            	<p/>
            	This class simply manages a single collection of particles in world space
                with a shared local origin for emission. The visual aspect of the 
                particles is handled by a ParticleSystemRenderer instance.
            	<p/>
                Particle systems are created using the SceneManager, never directly.
                In addition, like all subclasses of MovableObject, the ParticleSystem 
            	will only be considered for rendering once it has been attached to a 
            	SceneNode. 
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.emitterList">
            <summary>List of emitters for this system.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.affectorList">
            <summary>List of affectors for this system.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.requested">
            <summary>Cached for less memory usage during emitter processing.</summary>
            <note>EmitterList is a list of _counts_, not a list of emitters</note>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.emittedEmitterPool">
            Pool of emitted emitters for use and reuse in the active emitted emitter list.
            		@remarks
            			The emitters in this pool act as particles and as emitters. The pool is a map containing lists 
            			of emitters, identified by their name.
            		@par
            			The emitters in this pool are cloned using emitters that are kept in the main emitter list
            			of the ParticleSystem.
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.freeEmittedEmitters">
            Free emitted emitter list.
            			@remarks
            				This contains a list of the emitters free for use as new instances as required by the set.
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.activeEmittedEmitters">
            Active emitted emitter list.
            			@remarks
            				This is a linked list of pointers to emitters in the emitted emitter pool.
            				Emitters that are used are stored (their pointers) in both the list with active particles and in 
            				the list with active emitted emitters.        
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.aab">
            World AABB, only used to compare world-space positions to calc bounds
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.resourceGroupName">
            Name of the resource group to use to load materials
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.materialName">
            Name of the material to use
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.isRendererConfigured">
            Have we set the material etc on the renderer?
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.material">
            Pointer to the material to use
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.defaultWidth">
            Default width of each particle
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.defaultHeight">
            Default height of each particle
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.speedFactor">
            Speed factor
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.iterationInterval">
            Iteration interval
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.iterationIntervalSet">
            Iteration interval set? Otherwise track default
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.sorted">
            Particles sorted according to camera?
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.localSpace">
            Particles in local space?
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.nonvisibleTimeout">
            Update timeout when nonvisible (0 for no timeout)
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.nonvisibleTimeoutSet">
            Update timeout when nonvisible set? Otherwise track default
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.timeSinceLastVisible">
            Amount of time non-visible so far
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.lastVisibleFrame">
            Last frame in which known to be visible
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.timeController">
            Controller for time update
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.renderer">
            The renderer used to render this particle system
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.cullIndividual">
            Do we cull each particle individually?
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.rendererType">
            The name of the type of renderer used to render this system
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.poolSize">
            The number of particles in the pool.
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.origin">
            Optional origin of this particle system (eg script name)
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.defaultIterationInterval">
            Default iteration interval
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.defaultNonvisibleTimeout">
            Default nonvisible update timeout
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.attribParsers">
            <summary>
                List of available attibute parsers for script attributes.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.#ctor(System.String)">
            <summary>
            	Creates a particle system with no emitters or affectors.
            </summary>
            <remarks>
            	You should use the ParticleSystemManager to create systems, rather than doing it directly.
            </remarks>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.#ctor(System.String,System.String)">
            <summary>
            	Creates a particle system with no emitters or affectors.
            </summary>
            <remarks>
            	You should use the ParticleSystemManager to create systems, rather than doing it directly.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddEmitter(System.String)">
            <summary>
            	Adds an emitter to this particle system.
             </summary>
             <remarks>	
            	Particles are created in a particle system by emitters - see the ParticleEmitter
            	class for more details.
            </remarks>
            <param name="emitterType">
            	string identifying the emitter type to create. Emitter types are defined
            	by registering new factories with the manager - see ParticleEmitterFactory for more details.
            	Emitter types can be extended by plugin authors.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddAffector(System.String)">
            <summary>
            	Adds an affector to this particle system.
             </summary>
             <remarks>	
            	Particles are modified over time in a particle system by affectors - see the ParticleAffector
            	class for more details.
            </remarks>
            <param name="affectorType">
            	string identifying the affector type to create. Affector types are defined
            	by registering new factories with the manager - see ParticleAffectorFactory for more details.
            	Affector types can be extended by plugin authors.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.GetAffector(System.Int32)">
            <summary>
               Get a particle affector assigned to this particle system by index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.GetEmitter(System.Int32)">
            <summary>
               Get a particle emitter assigned to this particle system by index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.Expire(System.Single)">
            <summary>
            	Used to expire dead particles.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.TriggerEmitters(System.Single)">
            <summary>
            	Spawn new particles based on free quota and emitter requirements.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.ApplyMotion(System.Single)">
            <summary>
            	Updates existing particles based on their momentum.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.TriggerAffectors(System.Single)">
            <summary>
            	Applies the effects of particle affectors.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.IncreasePool(System.Int32)">
            <summary>
            	Overriden from BillboardSet to create Particles instead of Billboards.
             </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.FastForward(System.Single)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.FastForward(System.Single,System.Single)">
            <summary>
            	Fast-forwards this system by the required number of seconds.
             </summary>
             <remarks>
            	This method allows you to fast-forward a system so that it effectively looks like
            	it has already been running for the time you specify. This is useful to avoid the
            	'startup sequence' of a system, when you want the system to be fully populated right
            	from the start.
            </remarks>
            <param name="time">The number of seconds to fast-forward by.</param>
            <param name="interval">
            	The sampling interval used to generate particles, apply affectors etc. The lower this
            	is the more realistic the fast-forward, but it takes more iterations to do it.
            </param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.RegisterParsers">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to 
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.CopyTo(Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Cloning will deep copy all particle emitters and effectors, but not particles. The
            	system's name is also not copied.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.Update(System.Single)">
            <summary>
            	Updates the particles in the system based on time elapsed.
             </summary>
             <remarks>	
            	This is called automatically every frame by the engine.
            </remarks>
            <param name="timeElapsed">The amount of time (in seconds) since the last frame.</param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.ParticleCount">
            <summary>
            	Gets the count of active particles currently in the system.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.ParticleQuota">
            <summary>
            	Returns the maximum number of particles this system is allowed to have active at once.
            </summary>
            <remarks>
            	Particle systems all have a particle quota, i.e. a maximum number of particles they are 
            	allowed to have active at a time. This allows the application to set a keep particle systems
            	under control should they be affected by complex parameters which alter their emission rates
            	etc. If a particle system reaches it's particle quota, none of the emitters will be able to 
            	emit any more particles. As existing particles die, the spare capacity will be allocated
            	equally across all emitters to be as consistent to the origina particle system style as possible.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.Particles">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.TypeFlags">
            <summary>
            Get the 'type flags' for this <see cref="T:Axiom.ParticleSystems.ParticleSystem"/>.
            </summary>
            <seealso cref="P:Axiom.Core.MovableObject.TypeFlags"/>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitterFactory">
            <summary>
            	Abstract class defining the interface to be implemented by creators of ParticleEmitter subclasses.
             </summary>
             <remarks>
            	Plugins or 3rd party applications can add new types of particle emitters by creating
            	subclasses of the ParticleEmitter class. Because multiple instances of these emitters may be
            	required, a factory class to manage the instances is also required. 
            	<p/>
            	ParticleEmitterFactory subclasses must allow the creation and destruction of ParticleEmitter
            	subclasses. They must also be registered with the ParticleSystemManager. All factories have
            	a name which identifies them, examples might be 'Point', 'Cone', or 'Box', and these can be 
            	also be used from XML particle system scripts.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.Create(Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Creates a new instance of an emitter.
            </summary>
            <remarks>
            	Subclasses must add newly created emitters to the emitterList.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.Destroy(Axiom.ParticleSystems.ParticleEmitter)">
            <summary>
            	Destroys the emitter referenced by the parameter.
            </summary>
            <param name="emitter"></param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitterFactory.Name">
            <summary>
            	Returns the name of the factory, which identifies which type of emitter this factory creates.
            </summary>
        </member>
        <member name="T:Axiom.Math.Plane">
             <summary>
             Defines a plane in 3D space.
             </summary>
             <remarks>
             A plane is defined in 3D space by the equation
             Ax + By + Cz + D = 0
            
             This equates to a vector (the normal of the plane, whose x, y
             and z components equate to the coefficients A, B and C
             respectively), and a constant (D) which is the distance along
             the normal you have to go to move the plane back to the origin.
             </remarks>
        </member>
        <member name="F:Axiom.Math.Plane.D">
            <summary>
            	Distance from the origin.
            </summary>
        </member>
        <member name="F:Axiom.Math.Plane.Normal">
            <summary>
            	Direction the plane is facing.
            </summary>
        </member>
        <member name="M:Axiom.Math.Plane.#ctor(Axiom.Math.Vector3,Axiom.Math.Real)">
            <summary>
            	Construct a plane through a normal, and a distance to move the plane along the normal.
            </summary>
            <param name="normal"></param>
            <param name="constant"></param>
        </member>
        <member name="M:Axiom.Math.Plane.#ctor(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Construct a plane from 3 coplanar points.
            </summary>
            <param name="point0">First point.</param>
            <param name="point1">Second point.</param>
            <param name="point2">Third point.</param>
        </member>
        <member name="M:Axiom.Math.Plane.GetSide(Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.GetSide(Axiom.Math.AxisAlignedBox)">
            <summary>
            Returns the side where the aligneBox is. the flag Both indicates an intersecting box.
            one corner ON the plane is sufficient to consider the box and the plane intersecting.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.GetSide(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
                Returns which side of the plane that the given box lies on.
                The box is defined as centre/half-size pairs for effectively.
            </summary>
            <param name="centre">The centre of the box.</param>
            <param name="halfSize">The half-size of the box.</param>
            <returns>
                Positive if the box complete lies on the "positive side" of the plane,
                Negative if the box complete lies on the "negative side" of the plane,
                and Both if the box intersects the plane.
            </returns>
        </member>
        <member name="M:Axiom.Math.Plane.GetDistance(Axiom.Math.Vector3)">
            <summary>
            This is a pseudodistance. The sign of the return value is
            positive if the point is on the positive side of the plane,
            negative if the point is on the negative side, and zero if the
             point is on the plane.
            The absolute value of the return value is the true distance only
            when the plane normal is a unit length vector.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.Redefine(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            Redefine this plane based on a normal and a point.
            </summary>
            <param name="rkNormal">Normal vector</param>
            <param name="rkPoint">Point vector</param>
        </member>
        <member name="M:Axiom.Math.Plane.Redefine(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Construct a plane from 3 coplanar points.
            </summary>
            <param name="point0">First point.</param>
            <param name="point1">Second point.</param>
            <param name="point2">Third point.</param>
        </member>
        <member name="M:Axiom.Math.Plane.ProjectVector(Axiom.Math.Vector3)">
            <summary>
                Project a point onto the plane.
            </summary>
        </member>
        <member name="M:Axiom.Math.Plane.Equals(System.Object)">
            <summary>
            	Object method for testing equality.
            </summary>
            <param name="obj">Object to test.</param>
            <returns>True if the 2 planes are logically equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Plane.GetHashCode">
            <summary>
            	Gets the hashcode for this Plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.ToString">
            <summary>
            	Returns a string representation of this Plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.op_Equality(Axiom.Math.Plane,Axiom.Math.Plane)">
            <summary>
            	Compares 2 Planes for equality.
            </summary>
            <param name="left">First plane.</param>
            <param name="right">Second plane.</param>
            <returns>true if equal, false if not equal.</returns>
        </member>
        <member name="M:Axiom.Math.Plane.op_Inequality(Axiom.Math.Plane,Axiom.Math.Plane)">
            <summary>
            	Compares 2 Planes for inequality.
            </summary>
            <param name="left">First plane.</param>
            <param name="right">Second plane.</param>
            <returns>true if not equal, false if equal.</returns>
        </member>
        <member name="T:Axiom.Input.KeyCodes">
            <summary>
               Enum containing all the possible keyboard codes.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LButton">
            <summary>
            	The keyboard code for LButton.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.RButton">
            <summary>
            	The keyboard code for RButton.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Cancel">
            <summary>
            	The keyboard code for Cancel.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.MButton">
            <summary>
            	The keyboard code for MButton.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.XButton1">
            <summary>
            	The keyboard code for XButton1.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.XButton2">
            <summary>
            	The keyboard code for XButton2.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Backspace">
            <summary>
            	The keyboard code for Backspace.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Tab">
            <summary>
            	The keyboard code for Tab.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LineFeed">
            <summary>
            	The keyboard code for LineFeed.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Clear">
            <summary>
            	The keyboard code for Clear.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Return">
            <summary>
            	The keyboard code for Return.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Enter">
            <summary>
            	The keyboard code for Enter.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.ShiftKey">
            <summary>
            	The keyboard code for ShiftKey.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.ControlKey">
            <summary>
            	The keyboard code for ControlKey.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Menu">
            <summary>
            	The keyboard code for Menu.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Pause">
            <summary>
            	The keyboard code for Pause.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Capital">
            <summary>
            	The keyboard code for Capital.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.CapsLock">
            <summary>
            	The keyboard code for CapsLock.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Escape">
            <summary>
            	The keyboard code for Escape.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Space">
            <summary>
            	The keyboard code for Space.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Prior">
            <summary>
            	The keyboard code for Prior.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.PageUp">
            <summary>
            	The keyboard code for PageUp.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Next">
            <summary>
            	The keyboard code for Next.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.PageDown">
            <summary>
            	The keyboard code for PageDown.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.End">
            <summary>
            	The keyboard code for End.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Home">
            <summary>
            	The keyboard code for Home.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Left">
            <summary>
            	The keyboard code for Left.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Up">
            <summary>
            	The keyboard code for Up.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Right">
            <summary>
            	The keyboard code for Right.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Down">
            <summary>
            	The keyboard code for Down.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Select">
            <summary>
            	The keyboard code for Select.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Print">
            <summary>
            	The keyboard code for Print.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Execute">
            <summary>
            	The keyboard code for Execute.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Snapshot">
            <summary>
            	The keyboard code for Snapshot.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.PrintScreen">
            <summary>
            	The keyboard code for PrintScreen.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Insert">
            <summary>
            	The keyboard code for Insert.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Delete">
            <summary>
            	The keyboard code for Delete.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Help">
            <summary>
            	The keyboard code for Help.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D0">
            <summary>
            	The keyboard code for D0.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D1">
            <summary>
            	The keyboard code for D1.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D2">
            <summary>
            	The keyboard code for D2.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D3">
            <summary>
            	The keyboard code for D3.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D4">
            <summary>
            	The keyboard code for D4.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D5">
            <summary>
            	The keyboard code for D5.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D6">
            <summary>
            	The keyboard code for D6.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D7">
            <summary>
            	The keyboard code for D7.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D8">
            <summary>
            	The keyboard code for D8.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D9">
            <summary>
            	The keyboard code for D9.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.A">
            <summary>
            	The keyboard code for A.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.B">
            <summary>
            	The keyboard code for B.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.C">
            <summary>
            	The keyboard code for C.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.D">
            <summary>
            	The keyboard code for D.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.E">
            <summary>
            	The keyboard code for E.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F">
            <summary>
            	The keyboard code for F.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.G">
            <summary>
            	The keyboard code for G.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.H">
            <summary>
            	The keyboard code for H.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.I">
            <summary>
            	The keyboard code for I.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.J">
            <summary>
            	The keyboard code for J.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.K">
            <summary>
            	The keyboard code for K.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.L">
            <summary>
            	The keyboard code for L.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.M">
            <summary>
            	The keyboard code for M.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.N">
            <summary>
            	The keyboard code for N.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.O">
            <summary>
            	The keyboard code for O.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.P">
            <summary>
            	The keyboard code for P.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Q">
            <summary>
            	The keyboard code for Q.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.R">
            <summary>
            	The keyboard code for R.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.S">
            <summary>
            	The keyboard code for S.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.T">
            <summary>
            	The keyboard code for T.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.U">
            <summary>
            	The keyboard code for U.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.V">
            <summary>
            	The keyboard code for V.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.W">
            <summary>
            	The keyboard code for W.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.X">
            <summary>
            	The keyboard code for X.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Y">
            <summary>
            	The keyboard code for Y.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Z">
            <summary>
            	The keyboard code for Z.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LWin">
            <summary>
            	The keyboard code for LWin.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.RWin">
            <summary>
            	The keyboard code for RWin.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Apps">
            <summary>
            	The keyboard code for Apps.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad0">
            <summary>
            	The keyboard code for NumPad0.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad1">
            <summary>
            	The keyboard code for NumPad1.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad2">
            <summary>
            	The keyboard code for NumPad2.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad3">
            <summary>
            	The keyboard code for NumPad3.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad4">
            <summary>
            	The keyboard code for NumPad4.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad5">
            <summary>
            	The keyboard code for NumPad5.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad6">
            <summary>
            	The keyboard code for NumPad6.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad7">
            <summary>
            	The keyboard code for NumPad7.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad8">
            <summary>
            	The keyboard code for NumPad8.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumPad9">
            <summary>
            	The keyboard code for NumPad9.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Multiply">
            <summary>
            	The keyboard code for Multiply.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Add">
            <summary>
            	The keyboard code for Add.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Separator">
            <summary>
            	The keyboard code for Separator.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Subtract">
            <summary>
            	The keyboard code for Subtract.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Decimal">
            <summary>
            	The keyboard code for Decimal.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Divide">
            <summary>
            	The keyboard code for Divide.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F1">
            <summary>
            	The keyboard code for F1.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F2">
            <summary>
            	The keyboard code for F2.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F3">
            <summary>
            	The keyboard code for F3.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F4">
            <summary>
            	The keyboard code for F4.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F5">
            <summary>
            	The keyboard code for F5.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F6">
            <summary>
            	The keyboard code for F6.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F7">
            <summary>
            	The keyboard code for F7.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F8">
            <summary>
            	The keyboard code for F8.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F9">
            <summary>
            	The keyboard code for F9.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F10">
            <summary>
            	The keyboard code for F10.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F11">
            <summary>
            	The keyboard code for F11.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F12">
            <summary>
            	The keyboard code for F12.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F13">
            <summary>
            	The keyboard code for F13.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F14">
            <summary>
            	The keyboard code for F14.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F15">
            <summary>
            	The keyboard code for F15.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F16">
            <summary>
            	The keyboard code for F16.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F17">
            <summary>
            	The keyboard code for F17.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F18">
            <summary>
            	The keyboard code for F18.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F19">
            <summary>
            	The keyboard code for F19.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F20">
            <summary>
            	The keyboard code for F20.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F21">
            <summary>
            	The keyboard code for F21.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F22">
            <summary>
            	The keyboard code for F22.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F23">
            <summary>
            	The keyboard code for F23.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.F24">
            <summary>
            	The keyboard code for F24.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NumLock">
            <summary>
            	The keyboard code for NumLock.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Scroll">
            <summary>
            	The keyboard code for Scroll.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LeftShift">
            <summary>
            	The keyboard code for LeftShift.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.RightShift">
            <summary>
            	The keyboard code for RightShift.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LeftControl">
            <summary>
            	The keyboard code for LeftControl.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.RightControl">
            <summary>
            	The keyboard code for RightControl.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LMenu">
            <summary>
            	The keyboard code for LMenu.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.RMenu">
            <summary>
            	The keyboard code for RMenu.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.ProcessKey">
            <summary>
            	The keyboard code for ProcessKey.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Attn">
            <summary>
            	The keyboard code for Attn.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.EraseEof">
            <summary>
            	The keyboard code for EraseEof.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Play">
            <summary>
            	The keyboard code for Play.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Zoom">
            <summary>
            	The keyboard code for Zoom.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.NoName">
            <summary>
            	The keyboard code for NoName.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.KanaMode">
            <summary>
            	The keyboard code for KanaMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.HanguelMode">
            <summary>
            	The keyboard code for HanguelMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.HangulMode">
            <summary>
            	The keyboard code for HangulMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.JunjaMode">
            <summary>
            	The keyboard code for JunjaMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.FinalMode">
            <summary>
            	The keyboard code for FinalMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.HanjaMode">
            <summary>
            	The keyboard code for HanjaMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.KanjiMode">
            <summary>
            	The keyboard code for KanjiMode.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.IMEConvert">
            <summary>
            	The keyboard code for IMEConvert.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.IMENonconvert">
            <summary>
            	The keyboard code for IMENonconvert.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.IMEAceept">
            <summary>
            	The keyboard code for IMEAceept.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.IMEModeChange">
            <summary>
            	The keyboard code for IMEModeChange.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserBack">
            <summary>
            	The keyboard code for BrowserBack.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserForward">
            <summary>
            	The keyboard code for BrowserForward.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserRefresh">
            <summary>
            	The keyboard code for BrowserRefresh.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserStop">
            <summary>
            	The keyboard code for BrowserStop.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserSearch">
            <summary>
            	The keyboard code for BrowserSearch.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserFavorites">
            <summary>
            	The keyboard code for BrowserFavorites.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.BrowserHome">
            <summary>
            	The keyboard code for BrowserHome.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.VolumeMute">
            <summary>
            	The keyboard code for VolumeMute.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.VolumeDown">
            <summary>
            	The keyboard code for VolumeDown.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.VolumeUp">
            <summary>
            	The keyboard code for VolumeUp.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.MediaNextTrack">
            <summary>
            	The keyboard code for MediaNextTrack.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.MediaPreviousTrack">
            <summary>
            	The keyboard code for MediaPreviousTrack.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.MediaStop">
            <summary>
            	The keyboard code for MediaStop.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.MediaPlayPause">
            <summary>
            	The keyboard code for MediaPlayPause.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LaunchMail">
            <summary>
            	The keyboard code for LaunchMail.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.SelectMedia">
            <summary>
            	The keyboard code for SelectMedia.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LaunchApplication1">
            <summary>
            	The keyboard code for LaunchApplication1.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LaunchApplication2">
            <summary>
            	The keyboard code for LaunchApplication2.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Semicolon">
            <summary>
            	The keyboard code for Semicolon.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Plus">
            <summary>
            	The keyboard code for Plus.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Comma">
            <summary>
            	The keyboard code for Comma.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Period">
            <summary>
            	The keyboard code for Period.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.QuestionMark">
            <summary>
            	The keyboard code for QuestionMark.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Tilde">
            <summary>
            	The keyboard code for Tilde.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.OpenBracket">
            <summary>
            	The keyboard code for OpenBracket.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Pipe">
            <summary>
            	The keyboard code for Pipe.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.CloseBracket">
            <summary>
            	The keyboard code for CloseBracket.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Quotes">
            <summary>
            	The keyboard code for Quotes.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Backslash">
            <summary>
            	The keyboard code for Backslash.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Shift">
            <summary>
            	The keyboard code for Shift.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.Control">
            <summary>
            	The keyboard code for Control.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.LeftAlt">
            <summary>
            	The keyboard code for LeftAlt.
            </summary>
        </member>
        <member name="F:Axiom.Input.KeyCodes.RightAlt">
            <summary>
            	The keyboard code for RightAlt.
            </summary>
        </member>
        <member name="T:Axiom.Input.MouseButtons">
            <summary>
               Possible buttons that can be found on a mouse.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseButtons.Left">
            <summary>
               Typically the left button.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseButtons.Right">
            <summary>
               Typically the right button.
            </summary>
        </member>
        <member name="F:Axiom.Input.MouseButtons.Middle">
            <summary>
               Typically the middle button (pressing the scroll wheel).
            </summary>
        </member>
        <member name="T:Axiom.Input.ModifierKeys">
            <summary>
            	Special keys that can alter input behavior when down.
            </summary>
        </member>
        <member name="T:Axiom.Core.IResourceGroupListener">
            <summary>
            This defines an interface which is called back during
            resource group loading to indicate the progress of the load.
            </summary>
            <remarks>
            Resource group loading is in 2 phases - creating resources from
            declarations (which includes parsing scripts), and loading
            resources. Note that you don't necessarily have to have both; it
            is quite possible to just parse all the scripts for a group (see
            ResourceGroupManager.InitialiseResourceGroup, but not to
            load the resource group.
            The sequence of events is (* signifies a repeating item):
            <ul>
                <li>resourceGroupScriptingStarted</li>
                <li>scriptParseStarted (*)</li>
                <li>scriptParseEnded (*)</li>
                <li>resourceGroupScriptingEnded</li>
                <li>resourceGroupLoadStarted</li>
                <li>resourceLoadStarted (*)</li>
                <li>resourceLoadEnded (*)</li>
                <li>worldGeometryStageStarted (*)</li>
                <li>worldGeometryStageEnded (*)</li>
                <li>resourceGroupLoadEnded</li>
            	<li>resourceGroupPrepareStarted</li>
                <li>resourcePrepareStarted (*)</li>
                <li>resourcePrepareEnded (*)</li>
                <li>resourceGroupPrepareEnded</li>
            </ul>
            </remarks>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceGroupScriptingStarted(System.String,System.Int32)">
            <summary>
            This event is fired when a resource group begins parsing scripts.
            </summary>
            <param name="groupName">The name of the group</param>
            <param name="scriptCount">The number of scripts which will be parsed</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ScriptParseStarted(System.String,System.Boolean@)">
            <summary>
            This event is fired when a script is about to be parsed.
            </summary>
            <param name="scriptName">Name of the to be parsed</param>
            <param name="skipThisScript">A boolean passed by reference which is by default set to 
            false. If the event sets this to true, the script will be skipped and not
            parsed. Note that in this case the scriptParseEnded event will not be raised
            for this script.</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ScriptParseEnded(System.String,System.Boolean)">
            <summary>
            This event is fired when the script has been fully parsed.
            </summary>
            <param name="scriptName"></param>
            <param name="skipped"></param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceGroupScriptingEnded(System.String)">
            <summary>
            This event is fired when a resource group finished parsing scripts.
            </summary>
            <param name="groupName">The name of the group</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceGroupPrepareStarted(System.String,System.Int32)">
            <summary>
            This event is fired  when a resource group begins preparing.
            </summary>
            <param name="groupName">The name of the group being prepared</param>
            <param name="resourceCount">The number of resources which will be prepared, including
            a number of stages required to prepare any linked world geometry.
            </param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourcePrepareStarted(Axiom.Core.Resource)">
            <summary>
            This event is fired when a declared resource is about to be prepared. 
            </summary>
            <param name="resource">Weak reference to the resource prepared.</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourcePrepareEnded">
            <summary>
            This event is fired when the resource has been prepared. 
            </summary>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceGroupPrepareEnded(System.String)">
            <summary>
            This event is fired when a resource group finished preparing.
            </summary>
            <param name="groupName">The name of the group has been prepared.</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceGroupLoadStarted(System.String,System.Int32)">
            <summary>
            This event is fired  when a resource group begins loading.
            </summary>
            <param name="groupName">The name of the group being loaded</param>
            <param name="resourceCount">
            The number of resources which will be loaded,
            including a number of stages required to load any linked world geometry
            </param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceLoadStarted(Axiom.Core.Resource)">
            <summary>
            This event is fired when a declared resource is about to be loaded.
            </summary>
            <param name="resource">Weak reference to the resource loaded</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceLoadEnded">
            <summary>
            This event is fired when the resource has been loaded.
            </summary>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.WorldGeometryStageStarted(System.String)">
            <summary>
            This event is fired when a stage of loading linked world geometry
            is about to start. The number of stages required will have been
            included in the resourceCount passed in resourceGroupLoadStarted.
            </summary>
            <param name="description">Text description of what was just loaded</param>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.WorldGeometryStageEnded">
            <summary>
            This event is fired when a stage of loading linked world geometry
            has been completed. The number of stages required will have been
            included in the resourceCount passed in resourceGroupLoadStarted.
            </summary>
        </member>
        <member name="M:Axiom.Core.IResourceGroupListener.ResourceGroupLoadEnded(System.String)">
            <summary>
            This event is fired when a resource group finished loading.
            </summary>
            <param name="groupName">The name of the group has been loaded.</param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager">
            <summary>
            This singleton class manages the list of resource groups, and notifying
            the various resource managers of their obligations to load / unload
            resources in a group. It also provides facilities to monitor resource
            loading per group (to do progress bars etc), provided the resources
            that are required are pre-registered.
            <para />
            Defining new resource groups,  and declaring the resources you intend to
            use in advance is optional, however it is a very useful feature. In addition,
            if a ResourceManager supports the definition of resources through scripts,
            then this is the class which drives the locating of the scripts and telling
            the ResourceManager to parse them.
            @par
            There are several states that a resource can be in (the concept, not the
            object instance in this case):
            <ol>
            <li><b>Undefined</b>. Nobody knows about this resource yet. It might be
            in the filesystem, but Ogre is oblivious to it at the moment - there
            is no Resource instance. This might be because it's never been declared
            (either in a script, or using ResourceGroupManager::declareResource), or
            it may have previously been a valid Resource instance but has been
            removed, either individually through ResourceManager::remove or as a group
            through ResourceGroupManager::clearResourceGroup.</li>
            <li><b>Declared</b>. Ogre has some forewarning of this resource, either
            through calling ResourceGroupManager::declareResource, or by declaring
            the resource in a script file which is on one of the resource locations
            which has been defined for a group. There is still no instance of Resource,
            but Ogre will know to create this resource when
            ResourceGroupManager.InitializeResourceGroup is called (which is automatic
            if you declare the resource group before Root.Initialize).</li>
            <li><b>Unloaded</b>. There is now a Resource instance for this resource,
            although it is not loaded. This means that code which looks for this
            named resource will find it, but the Resource is not using a lot of memory
            because it is in an unloaded state. A Resource can get into this state
            by having just been created by ResourceGroupManager.InitializeResourceGroup
            (either from a script, or from a call to declareResource), by
            being created directly from code (ResourceManager.Create), or it may
            have previously been loaded and has been unloaded, either individually
            through Resource::unload, or as a group through ResourceGroupManager.UnloadResourceGroup.</li>
            <li><b>Loaded</b>The Resource instance is fully loaded. This may have
            happened implicitly because something used it, or it may have been
            loaded as part of a group.</li>
            </ol>
            <see>ResourceGroupManager.DeclareResource</see>
            <see>ResourceGroupManager.InitializeResourceGroup</see>
            <see>ResourceGroupManager.LoadResourceGroup</see>
            <see>ResourceGroupManager.UnloadResourceGroup</see>
            <see>ResourceGroupManager.ClearResourceGroup</see>
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.DefaultResourceGroupName">
            <summary>
            Default resource group name
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.InternalResourceGroupName">
            <summary>
            Internal resource group name (should be used by Axiom internal only)
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.BootstrapResourceGroupName">
            <summary>
            Bootstrap resource group name (min Axiom resources)
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.AutoDetectResourceGroupName">
            <summary>
             Special resource group name which causes resource group to be automatically determined based on searching for the resource in all groups.
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceSystemNumReferenceCount">
            <summary>
            The number of reference counts held per resource by the resource system
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager._resourceGroupScriptingStarted">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager._worldGroupName">
            <summary>Group name for world resources</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager._currentGroup">
            Stored current group - optimization for when bulk loading a group
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceGroupScriptingStarted(System.String,System.Int32)">
            <summary>Internal event firing method </summary>
            <param name="groupName"></param>
            <param name="scriptCount"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireScriptStarted(System.String,System.Boolean@)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="scriptName"></param>
            <param name="skipThisScript"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireScriptEnded(System.String,System.Boolean)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="scriptName"></param>
            <param name="skipped"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceGroupScriptingEnded(System.String)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="groupName"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceGroupLoadStarted(System.String,System.Int32)">
            <summary>Internal event firing method </summary>
            <param name="groupName"></param>
            <param name="resourceCount"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceStarted(Axiom.Core.Resource)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="resource"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceEnded">
            <summary>
            Internal event firing method 
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceGroupLoadEnded(System.String)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="groupName"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceGroupPrepareStarted(System.String,System.Int32)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="groupName"></param>
            <param name="resourceCount"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourcePrepareStarted(Axiom.Core.Resource)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="resource"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourcePrepareEnded">
            <summary>
            Internal event firing method 
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._fireResourceGroupPrepareEnded(System.String)">
            <summary>
            Internal event firing method 
            </summary>
            <param name="groupName"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.CreateResourceGroup(System.String)">
            <summary>
             Create a resource group.
            </summary>
            <remarks>
               A resource group allows you to define a set of resources that can
               be loaded / unloaded as a unit. For example, it might be all the
               resources used for the level of a game. There is always one predefined
               resource group called ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
            which is typically used to hold all resources which do not need to
            be unloaded until shutdown. You can create additional ones so that
            you can control the life of your resources in whichever way you wish.
            <para>
               Once you have defined a resource group, resources which will be loaded
            as part of it are defined in one of 3 ways:
            <ol>
            <li>Manually through declareResource(); this is useful for scripted
            	declarations since it is entirely generalised, and does not
            	create Resource instances right away</li>
            <li>Through the use of scripts; some ResourceManager subtypes have
            	script formats (e.g. .material, .overlay) which can be used
            	to declare resources</li>
            <li>By calling ResourceManager::create to create a resource manually.
            This resource will go on the list for it's group and will be loaded
            and unloaded with that group</li>
            </ol>
            You must remember to call initialiseResourceGroup if you intend to use
            the first 2 types.
            </para>
            </remarks>
            <param name="name">The name to give the resource group.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.InitializeResourceGroup(System.String)">
            <summary>
            Initializes a resource group.
            </summary>
            <remarks>
            After creating a resource group, adding some resource locations, and
            perhaps pre-declaring some resources using <see cref="M:Axiom.Core.ResourceGroupManager.DeclareResource(System.String,System.String)"/> , but
            before you need to use the resources in the group, you
            should call this method to initialise the group. By calling this,
            you are triggering the following processes:
            <ol>
            <li>Scripts for all resource types which support scripting are
            	parsed from the resource locations, and resources within them are
            	created (but not loaded yet).</li>
            <li>Creates all the resources which have just pre-declared using
            <see cref="M:Axiom.Core.ResourceGroupManager.DeclareResource(System.String,System.String)"/> (again, these are not loaded yet)</li>
            </ol>
            So what this essentially does is create a bunch of unloaded <see cref="T:Axiom.Core.Resource"/>  entries
            in the respective ResourceManagers based on scripts, and resources
            you've pre-declared. That means that code looking for these resources
            will find them, but they won't be taking up much memory yet, until
            they are either used, or they are loaded in bulk using <see cref="M:Axiom.Core.ResourceGroupManager.LoadResourceGroup(System.String)"/>.
            Loading the resource group in bulk is entirely optional, but has the
            advantage of coming with progress reporting as resources are loaded.
            <para>
            Failure to call this method means that <see cref="M:Axiom.Core.ResourceGroupManager.LoadResourceGroup(System.String)"/>  will do
            nothing, and any resources you define in scripts will not be found.
            Similarly, once you have called this method you won't be able to
            pick up any new scripts or pre-declared resources, unless you
            call <see cref="M:Axiom.Core.ResourceGroupManager.ClearResourceGroup(System.String)"/> , set up declared resources, and call this
            method again.
            </para>
            <para>
            When you call <see cref="M:Axiom.Core.Root.Initialize(System.Boolean)"/> , all resource groups that have already been
            created are automatically initialised too. Therefore you do not need to
            call this method for groups you define and set up before you call
            <see cref="M:Axiom.Core.Root.Initialize(System.Boolean)"/>. However, since one of the most useful features of
            resource groups is to set them up after the main system initialization
            has occurred (e.g. a group per game level), you must remember to call this
            method for the groups you create after this.
            </para>
            </remarks>
            <param name="groupName">The name of the resource group to initialise</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.InitializeAllResourceGroups">
            <summary>
            Initialize all resource groups which are yet to be initialised.
            </summary>
            <see cref="M:Axiom.Core.ResourceGroupManager.InitializeResourceGroup(System.String)"/>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.PrepareResourceGroup(System.String)">
            <summary>
            Prepares a resource group.
            </summary>
            <see cref="M:Axiom.Core.ResourceGroupManager.PrepareResourceGroup(System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.PrepareResourceGroup(System.String,System.Boolean)">
            <summary>
            Prepares a resource group.
            </summary>
            <see cref="M:Axiom.Core.ResourceGroupManager.PrepareResourceGroup(System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.PrepareResourceGroup(System.String,System.Boolean,System.Boolean)">
             <summary>
             Prepares a resource group.
             </summary>
             <remarks>Prepares any created resources which are part of the named group.
            	Note that resources must have already been created by calling
            	ResourceManager::create, or declared using declareResource() or
            	in a script (such as .material and .overlay). The latter requires
            	that initialiseResourceGroup has been called. 
            
            	When this method is called, this class will callback any ResourceGroupListeners
            	which have been registered to update them on progress.
            	</remarks>
             <param name="name">The name of the resource group to prepare.</param>
             <param name="prepareMainResources">If true, prepares normal resources associated 
            	with the group (you might want to set this to false if you wanted
            	to just prepare world geometry in bulk)</param>
             <param name="prepareWorldGeom">If true, prepares any linked world geometry
            	<see cref="M:Axiom.Core.ResourceGroupManager.LinkWorldGeometryToResourceGroup(System.String,System.String,Axiom.Core.SceneManager)"/></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.LoadResourceGroup(System.String)">
             <overloads>
             <summary>Loads a resource group.</summary>
             <remarks>
             Loads any created resources which are part of the named group.
             Note that resources must have already been created by calling
             ResourceManager::create, or declared using declareResource() or
             in a script (such as .material and .overlay). The latter requires
             that initialiseResourceGroup has been called.
            
             When this method is called, this class will callback any ResourceGroupListeners
             which have been registered to update them on progress.
             </remarks>
             <param name="name">The name to of the resource group to load.</param>
             </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.LoadResourceGroup(System.String,System.Boolean,System.Boolean)">
            <param name="loadMainResources">If true, loads normal resources associated
            with the group (you might want to set this to false if you wanted
            to just load world geometry in bulk)</param>
            <param name="name"></param>
            <param name="loadWorldGeom">If true, loads any linked world geometry <see>ResourceGroupManager.LinkWorldGeometryToResourceGroup</see></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnloadResourceGroup(System.String)">
            <summary>Unloads a resource group.</summary>
            <remarks>
            This method unloads all the resources that have been declared as
            being part of the named resource group. Note that these resources
            will still exist in their respective ResourceManager classes, but
            will be in an unloaded state. If you want to remove them entirely,
            you should use ClearResourceGroup or DestroyResourceGroup.
            </remarks>
            <param name="groupName">The name to of the resource group to unload.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnloadResourceGroup(System.String,System.Boolean)">
            <summary>Unloads a resource group.</summary>
            <remarks>
            This method unloads all the resources that have been declared as
            being part of the named resource group. Note that these resources
            will still exist in their respective ResourceManager classes, but
            will be in an unloaded state. If you want to remove them entirely,
            you should use ClearResourceGroup or DestroyResourceGroup.
            </remarks>
            <param name="groupName">The name to of the resource group to unload.</param>
            <param name="reloadableOnly"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnloadUnreferencedResourcesInGroup(System.String)">
            <summary>
            Unload all resources which are not referenced by any other object.
            </summary>
            <remarks>
            This method behaves like unloadResourceGroup, except that it only
            unloads resources in the group which are not in use, ie not referenced
            by other objects. This allows you to free up some memory selectively
            whilst still keeping the group around (and the resources present,
            just not using much memory).
            </remarks>
            <param name="groupName">The name of the group to check for unreferenced resources</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnloadUnreferencedResourcesInGroup(System.String,System.Boolean)">
            <summary>
            Unload all resources which are not referenced by any other object.
            </summary>
            <remarks>
            This method behaves like unloadResourceGroup, except that it only
            unloads resources in the group which are not in use, ie not referenced
            by other objects. This allows you to free up some memory selectively
            whilst still keeping the group around (and the resources present,
            just not using much memory).
            </remarks>
            <param name="groupName">The name of the group to check for unreferenced resources</param>
            <param name="reloadableOnly">If true (the default), only unloads resources
            which can be subsequently automatically reloaded</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ClearResourceGroup(System.String)">
            <summary>Clears a resource group.</summary>
            <remarks>
            This method unloads all resources in the group, but in addition it
            removes all those resources from their ResourceManagers, and then
            clears all the members from the list. That means after calling this
            method, there are no resources declared as part of the named group
            any more. Resource locations still persist though.
            </remarks>
            <param name="groupName">The name to of the resource group to clear.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DestroyResourceGroup(System.String)">
            <summary>
            Destroys a resource group, clearing it first, destroying the resources
            which are part of it, and then removing it from
            the list of resource groups.
            </summary>
            <param name="groupName">The name of the resource group to destroy.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.AddResourceLocation(System.String,System.String)">
            <overloads>
            <summary>Method to add a resource location to for a given resource group.</summary>
            <remarks>
            Resource locations are places which are searched to load resource files.
            When you choose to load a file, or to search for valid files to load,
            the resource locations are used.
            </remarks>
            <param name="name">The name of the resource location; probably a directory, zip file, URL etc.</param>
            <param name="locType">
            The codename for the resource type, which must correspond to the
            Archive factory which is providing the implementation.
            </param>
            </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.AddResourceLocation(System.String,System.String,System.String)">
            <param name="locType"></param>
            <param name="resGroup">
            The name of the resource group for which this location is
            to apply. ResourceGroupManager.DefaultResourceGroupName is the
            default group which always exists, and can
            be used for resources which are unlikely to be unloaded until application
            shutdown. Otherwise it must be the name of a group; if it
            has not already been created with createResourceGroup then it is created
            automatically.
            </param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.AddResourceLocation(System.String,System.String,System.Boolean)">
            <param name="locType"></param>
            <param name="recursive">
            Whether subdirectories will be searched for files when using
            a pattern match (such as *.material), and whether subdirectories will be
            indexed. This can slow down initial loading of the archive and searches.
            When opening a resource you still need to use the fully qualified name,
            this allows duplicate names in alternate paths.
            </param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.AddResourceLocation(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <param name="locType"></param>
            <param name="resGroup">
            The name of the resource group for which this location is
            to apply. ResourceGroupManager.DefaultResourceGroupName is the
            default group which always exists, and can
            be used for resources which are unlikely to be unloaded until application
            shutdown. Otherwise it must be the name of a group; if it
            has not already been created with createResourceGroup then it is created
            automatically.
            </param>
            <param name="recursive">
            Whether subdirectories will be searched for files when using
            a pattern match (such as *.material), and whether subdirectories will be
            indexed. This can slow down initial loading of the archive and searches.
            When opening a resource you still need to use the fully qualified name,
            this allows duplicate names in alternate paths.
            </param>
            <param name="name"></param>
            <param name="monitor"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.RemoveResourceLocation(System.String)">
            <overloads>
            <summary>
            Removes a resource location from the search path.
            </summary>
            <param name="locationName">the name of the ResourceLocation</param>
            </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.RemoveResourceLocation(System.String,System.String)">
            <param name="locationName"></param>
            <param name="groupName">the name of the ResourceGroup</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeclareResource(System.String,System.String)">
            <overloads>
            <summary>
            Declares a resource to be a part of a resource group, allowing you to load and unload it as part of the group.
            </summary>
            <remarks>
            By declaring resources before you attempt to use them, you can
            more easily control the loading and unloading of those resources
            by their group. Declaring them also allows them to be enumerated,
            which means events can be raised to indicate the loading progress
            <see>ResourceGroupListener</see>. Note that another way of declaring
            resources is to use a script specific to the resource type, if
            available (e.g. .material).
            <para>
            Declared resources are not created as Resource instances (and thus
            are not available through their ResourceManager) until <see cref="M:Axiom.Core.ResourceGroupManager.InitializeResourceGroup(System.String)"/>
            is called, at which point all declared resources will become created
            (but unloaded) Resource instances, along with any resources declared
            in scripts in resource locations associated with the group.
            </para>
            </remarks>
            <param name="name">The resource name. </param>
            <param name="resourceType">
            The type of the resource. Axiom comes preconfigured with
            a number of resource types:
            <ul>
            <li>Font</li>
            <li>Material</li>
            <li>Mesh</li>
            <li>Overlay</li>
            <li>Skeleton</li>
            </ul>
            .. but more can be added by plugin ResourceManager classes.</param>
            </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeclareResource(System.String,System.String,System.String)">
            <param name="resourceType"></param>
            <param name="groupName">The name of the group to which it will belong.</param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeclareResource(System.String,System.String,Axiom.Core.IManualResourceLoader,Axiom.Collections.NameValuePairList)">
            <param name="loader"></param>
            <param name="loadParameters">
            A list of name / value pairs which supply custom
            parameters to the resource which will be required before it can
            be loaded. These are specific to the resource type.
            </param>
            <param name="name"></param>
            <param name="resourceType"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeclareResource(System.String,System.String,System.String,Axiom.Core.IManualResourceLoader,Axiom.Collections.NameValuePairList)">
            <param name="resourceType"></param>
            <param name="groupName">The name of the group to which it will belong.</param>
            <param name="loader"></param>
            <param name="loadParameters">
            A list of name / value pairs which supply custom
            parameters to the resource which will be required before it can
            be loaded. These are specific to the resource type.
            </param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UndeclareResource(System.String,System.String)">
            <summary>Undeclare a resource.</summary>
            <remarks>
            Note that this will not cause it to be unloaded
            if it is already loaded, nor will it destroy a resource which has
            already been created if InitialiseResourceGroup has been called already.
            Only UnloadResourceGroup / ClearResourceGroup / DestroyResourceGroup
            will do that.
            </remarks>
            <param name="name">The name of the resource. </param>
            <param name="groupName">The name of the group this resource was declared in.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.OpenResource(System.String)">
            Open a single resource by name and return a DataStream
            			pointing at the source of the data.
            		@param resourceName The name of the resource to locate.
            			Even if resource locations are added recursively, you
            			must provide a fully qualified name to this method. You
            			can find out the matching fully qualified names by using the
            			find() method if you need to.
            		@param groupName The name of the resource group; this determines which
            			locations are searched.
            		@returns Shared pointer to data stream containing the data, will be
            			destroyed automatically when no longer referenced
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.OpenResources(System.String)">
            <overloads>
            <summary>
            Open all resources matching a given pattern (which can contain
            the character '*' as a wildcard), and return a collection of
            DataStream objects on them.
            </summary>
            <param name="pattern">
            The pattern to look for. If resource locations have been
            added recursively, subdirectories will be searched too so this
            does not need to be fully qualified.
            </param>
            <returns>A list of Stream objects.</returns>
            </overloads>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.OpenResources(System.String,System.String)">
            <param name="pattern"></param>
            <param name="groupName">
            The resource group; this determines which locations are searched.
            </param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.CreateResource(System.String)">
            <summary>
            Create a new resource file in a given group.
            </summary>
            <remarks>This method creates a new file in a resource group and passes you back a writeable stream</remarks>
            <param name="filename">The name of the file to create</param>
            <returns>An open Stream</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.CreateResource(System.String,System.String)">
            <summary>
            Create a new resource file in a given group.
            </summary>
            <remarks>This method creates a new file in a resource group and passes you back a writeable stream</remarks>
            <param name="filename">The name of the file to create</param>
            <param name="groupName">The name of the group in which to create the file</param>
            <returns>An open Stream</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.CreateResource(System.String,System.String,System.Boolean)">
            <summary>
            Create a new resource file in a given group.
            </summary>
            <remarks>This method creates a new file in a resource group and passes you back a writeable stream</remarks>
            <param name="filename">The name of the file to create</param>
            <param name="groupName">The name of the group in which to create the file</param>
            <param name="overwrite">If true, an existing file will be overwritten, if false
            an error will occur if the file already exists</param>
            <returns>An open Stream</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.CreateResource(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Create a new resource file in a given group.
            </summary>
            <remarks>This method creates a new file in a resource group and passes you back a writeable stream</remarks>
            <param name="filename">The name of the file to create</param>
            <param name="groupName">The name of the group in which to create the file</param>
            <param name="overwrite">If true, an existing file will be overwritten, if false
            an error will occur if the file already exists</param>
            <param name="locationPattern">If the resource group contains multiple locations,
            then usually the file will be created in the first writable location. If you
            want to be more specific, you can include a location pattern here and
            only locations which match that pattern (as determined by <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>)
            will be considered candidates for creation.</param>
            <returns>An open Stream</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeleteResource(System.String)">
            <summary>
            Delete a single resource file.
            </summary>
            <param name="filename">The name of the file to delete</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeleteResource(System.String,System.String)">
            <summary>
            Delete a single resource file.
            </summary>
            <param name="filename">The name of the file to delete</param>
            <param name="groupName">The name of the group in which to search</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeleteResource(System.String,System.String,System.String)">
            <summary>
            Delete a single resource file.
            </summary>
            <param name="filename">The name of the file to delete</param>
            <param name="groupName">The name of the group in which to search</param>
            <param name="locationPattern">If the resource group contains multiple locations,
            then usually first matching file found in any location will be deleted. If you
            want to be more specific, you can include a location pattern here and
            only locations which match that pattern (as determined by <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>)
            will be considered candidates for deletion.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeleteMatchingResources(System.String)">
            <summary>
            Delete all matching resource files.
            </summary>
            <param name="filePattern">The pattern (see <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>) of the files to delete. </param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeleteMatchingResources(System.String,System.String)">
            <summary>
            Delete all matching resource files.
            </summary>
            <param name="filePattern">The pattern (see <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>) of the files to delete. </param>
            <param name="groupName">The name of the group in which to search</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.DeleteMatchingResources(System.String,System.String,System.String)">
            <summary>
            Delete all matching resource files.
            </summary>
            <param name="filePattern">The pattern (see <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>) of the files to delete. </param>
            <param name="groupName">The name of the group in which to search</param>
            <param name="locationPattern">If the resource group contains multiple locations,
            then usually all matching files in any location will be deleted. If you
            want to be more specific, you can include a location pattern here and
            only locations which match that pattern (as determined by <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>)
            will be considered candidates for deletion.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ListResourceNames(System.String)">
            <summary>List all file names in a resource group.</summary>
            <remarks>
            This method only returns filenames, you can also retrieve other information using listFileInfo.
            </remarks>
            <param name="groupName">The name of the group</param>
            <returns>A list of filenames matching the criteria, all are fully qualified</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ListResourceFileInfo(System.String)">
            <summary>List all files in a resource group with accompanying information.</summary>
            <param name="groupName">The name of the group</param>
            <returns>A list of structures detailing quite a lot of information about all the files in the archive.</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ResourceModifiedTime(System.String,System.String)">
            <summary>
            Retrieve the modification time of a given file
            </summary>
            <see cref="M:Axiom.Core.ResourceGroupManager.ResourceModifiedTime(Axiom.Core.ResourceGroupManager.ResourceGroup,System.String)"/>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ResourceModifiedTime(Axiom.Core.ResourceGroupManager.ResourceGroup,System.String)">
            <summary>
            Retrieve the modification time of a given file
            </summary>
            <param name="group"></param>
            <param name="resourceName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.FindResourceNames(System.String,System.String)">
            <summary>
            Find all file names matching a given pattern in a resource group.
            </summary>
            <remarks>
            This method only returns filenames, you can also retrieve other
            information using findFileInfo.
            </remarks>
            <param name="groupName">The name of the group</param>
            <param name="pattern">The pattern to search for; wildcards (*) are allowed</param>
            <returns>A list of filenames matching the criteria, all are fully qualified</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ResourceExists(System.String,System.String)">
            <summary>Find out if the named file exists in a group. </summary>
            <param name="group">The name of the resource group</param>
            <param name="filename">Fully qualified name of the file to test for</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ResourceExists(Axiom.Core.ResourceGroupManager.ResourceGroup,System.String)">
            <summary>Find out if the named file exists in a group. </summary>
            <param name="group">the resource group</param>
            <param name="filename">Fully qualified name of the file to test for</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.FindResourceFileInfo(System.String,System.String)">
            <summary>
            Find all files matching a given pattern in a group and get
            some detailed information about them.
            </summary>
            <param name="groupName">The name of the resource group</param>
            <param name="pattern">The pattern to search for; wildcards (*) are allowed</param>
            <returns>A list of file information structures for all files matching the criteria.</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.FindGroupContainingResource(System.String)">
             <summary>
            
             </summary>
             <param name="filename"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.AddResourceGroupListener(Axiom.Core.IResourceGroupListener)">
            <summary>
            Adds a ResourceGroupListener which will be called back during
            resource loading events.
            </summary>
            <param name="rgl"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.RemoveResourceGroupListener(Axiom.Core.IResourceGroupListener)">
            <summary>
            Removes a ResourceGroupListener
            </summary>
            <param name="rgl"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.LinkWorldGeometryToResourceGroup(System.String,System.String,Axiom.Core.SceneManager)">
            <summary>
            Associates some world geometry with a resource group, causing it to
            be loaded / unloaded with the resource group.
            </summary>
            <remarks>
            You would use this method to essentially defer a call to
            SceneManager::setWorldGeometry to the time when the resource group
            is loaded. The advantage of this is that compatible scene managers
            will include the estimate of the number of loading stages for that
            world geometry when the resource group begins loading, allowing you
            to include that in a loading progress report.
            </remarks>
            <param name="groupName">The name of the resource group</param>
            <param name="worldGeometry">The parameter which should be passed to setWorldGeometry</param>
            <param name="sceneManager">The SceneManager which should be called</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnlinkWorldGeometryFromResourceGroup(System.String)">
            <summary>
            Clear any link to world geometry from a resource group.
            </summary>
            <remarks>Basically undoes a previous call to linkWorldGeometryToResourceGroup.</remarks>
            <param name="groupName">The name of the resource group</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.ShutdownAll">
            <summary>
            Shutdown all ResourceManagers, performed as part of clean-up.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.GetResourceGroups">
            <summary>Get a list of the currently defined resource groups.</summary>
            <remarks>
            This method intentionally returns a copy rather than a reference in
            order to avoid any contention issues in multithreaded applications.
            </remarks>
            <returns>A copy of list of currently defined groups.</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.getResourceDeclarationList(System.String)">
            <summary>Get the list of resource declarations for the specified group name.</summary>
            <remarks>
            This method intentionally returns a copy rather than a reference in
            order to avoid any contention issues in multithreaded applications.
            </remarks>
            /// <param name="groupName">The name of the group</param>
            <returns>A copy of list of currently defined resources.</returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.getResourceGroup(System.String)">
            <summary>
            Get resource group
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.addCreatedResource(Axiom.Core.Resource,Axiom.Core.ResourceGroupManager.ResourceGroup)">
             <summary>
            
             </summary>
             <param name="resource"></param>
             <param name="group"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.RegisterResourceManager(System.String,Axiom.Core.ResourceManager)">
            <summary>
            Internal method for registering a ResourceManager (which should be
            a singleton). Creators of plugins can register new ResourceManagers
            this way if they wish.
            </summary>
            <remarks>
            ResourceManagers that wish to parse scripts must also call registerScriptLoader.
            </remarks>
            <param name="resourceType">String identifying the resource type, must be unique.</param>
            <param name="rm">the ResourceManager instance.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnregisterResourceManager(System.String)">
            <summary>
            Internal method for unregistering a ResourceManager.
            </summary>
            <remarks>
            ResourceManagers that wish to parse scripts must also call unregisterScriptLoader.
            </remarks>
            <param name="resourceType">String identifying the resource type.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.RegisterScriptLoader(Axiom.Scripting.IScriptLoader)">
            <summary>
            Internal method for registering a ScriptLoader. ScriptLoaders parse scripts when resource groups are initialised.
            </summary>
            <param name="su">ScriptLoader instance.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnregisterScriptLoader(Axiom.Scripting.IScriptLoader)">
            <summary>
            Internal method for unregistering a ScriptLoader.
            </summary>
            <param name="su">ScriptLoader instance.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.GetResourceManager(System.String)">
            <summary>
            Internal method for getting a registered ResourceManager.
            </summary>
            <param name="resourceType">String identifying the resource type.</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.notifyResourceCreated(Axiom.Core.Resource)">
            <summary>Internal method called by ResourceManager when a resource is created.</summary>
            <param name="res">reference to resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.notifyResourceRemoved(Axiom.Core.Resource)">
            <summary>Internal method called by ResourceManager when a resource is removed.</summary>
            <param name="res">reference to resource</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.notifyAllResourcesRemoved(Axiom.Core.ResourceManager)">
            <summary>Internal method called by ResourceManager when all resources for that manager are removed.</summary>
            <param name="manager">the manager for which all resources are being removed</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.notifyWorldGeometryStageStarted(System.String)">
            <summary>Notify this manager that one stage of world geometry loading has been started.</summary>
            <remarks>
            Custom SceneManagers which load custom world geometry should call this
            method the number of times equal to the value they return from
            SceneManager.estimateWorldGeometry while loading their geometry.
            </remarks>
            <param name="description"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.notifyWorldGeometryStageEnded">
            <summary>Notify this manager that one stage of world geometry loading has been completed.</summary>
            <remarks>
            Custom SceneManagers which load custom world geometry should call this
            method the number of times equal to the value they return from
            SceneManager.estimateWorldGeometry while loading their geometry.
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._parseResourceGroupScripts(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            <summary>
            Parses all the available scripts found in the resource locations
            for the given group, for all ResourceManagers.
            </summary>
            <remarks>
            Called as part of initializeResourceGroup
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._createDeclaredResources(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            <summary>Create all the pre-declared resources.</summary>
            <remarks>Called as part of initializeResourceGroup</remarks>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._addCreatedResource(Axiom.Core.Resource,Axiom.Core.ResourceGroupManager.ResourceGroup)">
            Adds a created resource to a group. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._dropGroupContents(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            <summary>
             Drops contents of a group, leave group there, notify ResourceManagers.
            </summary>
            <param name="grp"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._deleteGroup(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            <summary>
            Delete a group for shutdown - don't notify ResourceManagers.
            </summary>
            <param name="grp"></param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._getResourceManager(System.String)">
            <summary>
            Internal method for getting a registered ResourceManager.
            </summary>
            <param name="resourceType">identifies the resource type.</param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceGroupManager.WorldResourceGroupName">
            <summary>
            Gets/Sets the resource group that 'world' resources will use.
            </summary>
            <remarks>
               This is the group which should be used by SceneManagers implementing
               world geometry when looking for their resources. Defaults to the
               DefaultResourceGroupName but this can be altered.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ResourceGroupManager.currentGroup">
            <summary>
            Stored current group - optimization for when bulk loading a group
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceGroupManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupScriptingStarted">
            <summary>
            This event is fired when a resource group begins parsing scripts.
            </summary>
            <param name="groupName">The name of the group</param>
            <param name="scriptCount">The number of scripts which will be parsed</param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ScriptParseStarted">
            <summary>
            This event is fired when a script is about to be parsed.
            </summary>
            <param name="scriptName">Name of the to be parsed</param>
            <param name="skipThisScript">A boolean passed by reference which is by default set to 
            false. If the event sets this to true, the script will be skipped and not
            parsed. Note that in this case the scriptParseEnded event will not be raised
            for this script.</param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ScriptParseEnded">
            <summary>
            This event is fired when the script has been fully parsed.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupScriptingEnded">
            <summary>
            This event is fired when a resource group finished parsing scripts.
            </summary>
            <param name="groupName">The name of the group</param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupLoadStarted">
            <summary>
            This event is fired  when a resource group begins loading.
            </summary>
            <param name="groupName">The name of the group being loaded</param>
            <param name="resourceCount">
            The number of resources which will be loaded,
            including a number of stages required to load any linked world geometry
            </param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceLoadStarted">
            <summary>
            This event is fired when a declared resource is about to be loaded.
            </summary>
            <param name="resource">Weak reference to the resource loaded</param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceLoadEnded">
            <summary>
            This event is fired when the resource has been loaded.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.WorldGeometryStageStarted">
            <summary>
            This event is fired when a stage of loading linked world geometry
            is about to start. The number of stages required will have been
            included in the resourceCount passed in resourceGroupLoadStarted.
            </summary>
            <param name="description">Text description of what was just loaded</param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.WorldGeometryStageEnded">
            <summary>
            This event is fired when a stage of loading linked world geometry
            has been completed. The number of stages required will have been
            included in the resourceCount passed in resourceGroupLoadStarted.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupLoadEnded">
            <summary>
            This event is fired when a resource group finished loading.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupPrepareStarted">
            <summary>
            
            </summary>
            <param name="groupName"></param>
            <param name="resourceCount"></param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourcePrepareStarted">
            <summary>
            
            </summary>
            <param name="resource"></param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourcePrepareEnded">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupPrepareEnded">
            <summary>
            
            </summary>
            <param name="groupName"></param>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceDeclarationList">
            List of resource declarations
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceManagerMap">
            <summary>Map of resource types (strings) to ResourceManagers, used to notify them to load / unload group contents</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ScriptLoaderOrderMap">
            <summary>Map of loading order (Real) to ScriptLoader, used to order script parsing</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupListenerList">
            <summary></summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceLocationIndex">
            <summary>Resource index entry, resourcename->location </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.LocationList">
            <summary>List of possible file locations</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.LoadUnloadResourceList">
            <summary>List of resources which can be loaded / unloaded </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupMap">
            <summary>Map from resource group names to groups </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.LoadResourceOrderMap">
            <summary>Map of loading order (float) to LoadUnLoadResourceList  used to order resource loading</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceDeclaration">
            Nested struct defining a resource declaration
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceLocation">
            <summary>Resource location entry</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceLocation.Archive">
            <summary>Pointer to the archive which is the destination</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceLocation.Watcher">
            <summary>Pointer to the watcher which is monitoring the archive location</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceLocation.Recursive">
            <summary>Whether this location and it's children are searched for files</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceLocation.Monitor">
            <summary>Whether this location is be monitored for new files</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroup">
            Resource group entry
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.Name">
            <summary>Group name </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.Initialized">
            <summary>Whether group has been initialised </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.LocationList">
            <summary>List of possible locations to search </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.ResourceIndexCaseSensitive">
            <summary>Index of resource names to locations, built for speedy access (case sensitive archives) </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.ResourceIndexCaseInsensitive">
            <summary>Index of resource names to locations, built for speedy access (case insensitive archives) </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.ResourceDeclarations">
            <summary>Pre-declared resources, ready to be created </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.LoadResourceOrders">
            <summary>
            Created resources which are ready to be loaded / unloaded
            Group by loading order of the type (defined by ResourceManager)
            (e.g. skeletons and materials before meshes)
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.WorldGeometry">
            <summary>Linked world geometry, as passed to setWorldGeometry </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.WorldGeometrySceneManager">
            <summary>Scene manager to use with linked world geometry </summary>
        </member>
        <member name="T:Axiom.Core.PatchSurface">
            <summary>
                A surface which is defined by curves of some kind to form a patch, e.g. a Bezier patch.
            </summary>
            <remarks>
                This object will take a list of control points with various assorted data, and will
                subdivide it into a patch mesh. Currently only Bezier curves are supported for defining
                the surface, but other techniques such as NURBS would follow the same basic approach.
            </remarks>
        </member>
        <member name="F:Axiom.Core.PatchSurface.AUTO_LEVEL">
            <summary>
                Constant for indicating automatic determination of subdivision level for patches.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.declaration">
            <summary>
                Vertex declaration describing the control point buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlPointBuffer">
            <summary>
                Buffer containing the system-memory control points.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.type">
            <summary>
                Type of surface.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlWidth">
            <summary>
                Width in control points.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlHeight">
            <summary>
                Height in control points.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlCount">
            <summary>
                Total number of control level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.uLevel">
            <summary>
                U-direction subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.vLevel">
            <summary>
               V-direction subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.maxULevel">
            <summary>
                Max U subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.maxVLevel">
            <summary>
                Max V subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.meshWidth">
            <summary>
                Width of the subdivided mesh (big enough for max level).
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.meshHeight">
            <summary>
                Height of the subdivided mesh (big enough for max level).
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.side">
            <summary>
                Which side is visible.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.subdivisionFactor">
            <summary>
                Mesh subdivision factor.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlPoints">
            <summary>
                List of control points.
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.#ctor">
            <summary>
                Default contructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)">
            <summary>
                Sets up the surface by defining it's control points, type and initial subdivision level.
            </summary>
            <remarks>
                This method initializes the surface by passing it a set of control points. The type of curves to be used
                are also defined here, although the only supported option currently is a bezier patch. You can also
                specify a global subdivision level here if you like, although it is recommended that the parameter
                is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the
                curvature of the surface).
            </remarks>
            <param name="controlPointArray">
                An array containing the vertex data which define control points of the curves
                rather than actual vertices. Note that you are expected to provide not
                just position information, but potentially normals and texture coordinates too.
                The array is internally treated as a contiguous memory buffer without any gaps between the elements.
                The format of the buffer is defined in the VertexDeclaration parameter.
            </param>
            <param name="decl">
                VertexDeclaration describing the contents of the buffer.
                Note this declaration must _only_ draw on buffer source 0!
            </param>
            <param name="width">Specifies the width of the patch in control points.</param>
            <param name="height">Specifies the height of the patch in control points.</param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)">
            <summary>
                Sets up the surface by defining it's control points, type and initial subdivision level.
            </summary>
            <remarks>
                This method initialises the surface by passing it a set of control points. The type of curves to be used
                are also defined here, although the only supported option currently is a bezier patch. You can also
                specify a global subdivision level here if you like, although it is recommended that the parameter
                is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the
                curvature of the surface).
            </remarks>
            <param name="controlPointArray">
                An array containing the vertex data which define control points of the curves
                rather than actual vertices. Note that you are expected to provide not
                just position information, but potentially normals and texture coordinates too.
                The array is internally treated as a contiguous memory buffer without any gaps between the elements.
                The format of the buffer is defined in the VertexDeclaration parameter.
            </param>
            <param name="declaration">
                VertexDeclaration describing the contents of the buffer.
                Note this declaration must _only_ draw on buffer source 0!
            </param>
            <param name="width">Specifies the width of the patch in control points.</param>
            <param name="height">Specifies the height of the patch in control points.</param>
            <param name="type">The type of surface.</param>
            <param name="uMaxSubdivisionLevel">
                If you want to manually set the top level of subdivision,
                do it here, otherwise let the system decide.
            </param>
            <param name="vMaxSubdivisionLevel">
                If you want to manually set the top level of subdivision,
                do it here, otherwise let the system decide.
            </param>
            <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for.</param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.Build(Axiom.Graphics.HardwareVertexBuffer,System.Int32,Axiom.Graphics.HardwareIndexBuffer,System.Int32)">
            <summary>
                Tells the system to build the mesh relating to the surface into externally created buffers.
            </summary>
            <remarks>
                The VertexDeclaration of the vertex buffer must be identical to the one passed into
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)"/>.  In addition, there must be enough space in the buffer to
                accommodate the patch at full detail level; you should check <see cref="P:Axiom.Core.PatchSurface.RequiredVertexCount"/>
                and <see cref="P:Axiom.Core.PatchSurface.RequiredIndexCount"/> to determine this. This method does not create an internal
                mesh for this patch and so GetMesh will return null if you call it after building the
                patch this way.
            </remarks>
            <param name="destVertexBuffer">The destination vertex buffer in which to build the patch.</param>
            <param name="vertexStart">The offset at which to start writing vertices for this patch.</param>
            <param name="destIndexBuffer">The destination index buffer in which to build the patch.</param>
            <param name="indexStart">The offset at which to start writing indexes for this patch.</param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.FindLevel(Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Vector3@)">
            <summary>
                Internal method for finding the subdivision level given 3 control points.
            </summary>
            <param name="a">First control point.</param>
            <param name="b">Second control point.</param>
            <param name="c">Third control point.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PatchSurface.DistributeControlPoints(System.IntPtr)">
             <summary>
            
             </summary>
             <param name="lockedBuffer"></param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.SubdivideCurve(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="lockedBuffer"></param>
             <param name="startIdx"></param>
             <param name="stepSize"></param>
             <param name="numSteps"></param>
             <param name="iterations"></param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.InterpolateVertexData(System.IntPtr,System.Int32,System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="lockedBuffer"></param>
             <param name="leftIndex"></param>
             <param name="rightIndex"></param>
             <param name="destIndex"></param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.MakeTriangles">
             <summary>
            
             </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoULevel">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoULevel(System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoVLevel">
            <summary>
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoVLevel(System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.RequiredVertexCount">
            <summary>
                Based on a previous call to 
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)"/>, 
                establishes the number of vertices required
                to hold this patch at the maximum detail level.
            </summary>
            <remarks>
                This is useful when you wish to build the patch into external vertex / index buffers.
            </remarks>
        </member>
        <member name="P:Axiom.Core.PatchSurface.RequiredIndexCount">
            <summary>
                Based on a previous call to 
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)"/>, 
                establishes the number of indexes required
                to hold this patch at the maximum detail level.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.CurrentIndexCount">
            <summary>
                Gets the current index count based on the current subdivision level.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.IndexOffset">
            <summary>
                Returns the index offset used by this buffer to write data into the buffer.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.VertexOffset">
            <summary>
                Returns the vertex offset used by this buffer to write data into the buffer.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.Bounds">
            <summary>
                Gets the bounds of this patch, only valid after calling 
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.BoundingSphereRadius">
            <summary>
                Gets the radius of the bounding sphere for this patch, only valid after 
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)"/>
                has been called.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.SubdivisionFactor">
            <summary>
                Gets/Sets the level of subdivision for this surface.
            </summary>
            <remarks>
                This method changes the proportionate detail level of the patch; since
                the U and V directions can have different subdivision levels, this property
                takes a single float value where 0 is the minimum detail (the control points)
                and 1 is the maximum detail level as supplied to the original call to
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="T:Axiom.Core.VisibleSide">
             <summary>
            
             </summary>
        </member>
        <member name="F:Axiom.Core.VisibleSide.Front">
            <summary>
                The side from which u goes right and v goes up (as in texture coords).
            </summary>
        </member>
        <member name="F:Axiom.Core.VisibleSide.Back">
            <summary>
                The side from which u goes right and v goes down (reverse of texture coords).
            </summary>
        </member>
        <member name="F:Axiom.Core.VisibleSide.Both">
            <summary>
                Both sides are visible - warning this creates 2x the number of triangles and adds
                extra overhead for calculating normals.
            </summary>
        </member>
        <member name="T:Axiom.Core.PatchSurfaceType">
            <summary>
                A patch defined by a set of bezier curves.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Controller`1">
            <summary>
            	Instances of this class 'control' the value of another object in the system.
            </summary>
             <remarks>
            	Controller classes are used to manage the values of object automatically based
            	on the value of some input. For example, a Controller could animate a texture
            	by controlling the current frame of the texture based on time, or a different Controller
            	could change the color of a material used for a spaceship shield mesh based on the remaining
            	shield power level of the ship.
            	<p/>
            	The Controller is an intentionally abstract concept - it can generate values
            	based on input and a function, which can either be one of the standard ones
            	supplied, or a function can be 'plugged in' for custom behavior - see the <see cref="T:Axiom.Controllers.IControllerFunction`1"/> class for details.
            	Both the input and output values are via <see cref="T:Axiom.Controllers.IControllerValue`1"/> objects, meaning that any value can be both
            	input and output of the controller.
            	<p/>
            	While this is very flexible, it can be a little bit confusing so to make it simpler the most often used
            	controller setups are available by calling methods on the ControllerManager object.
            </remarks>
        </member>
        <member name="F:Axiom.Controllers.Controller`1.source">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller`1.destination">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller`1.function">
            <summary>
            	Local reference to the function to be used for this controller.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller`1.isEnabled">
            <summary>
            	States whether or not this controller is enabled.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Controller`1.#ctor(Axiom.Controllers.IControllerValue{`0},Axiom.Controllers.IControllerValue{`0},Axiom.Controllers.IControllerFunction{`0})">
            <summary>
            	Main constructor.  Should not be used directly, rather a controller should be created using the
            	ControllerManager so it can keep track of them.
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="function"></param>
        </member>
        <member name="M:Axiom.Controllers.Controller`1.Update">
            <summary>
            	Called to update the destination value for this controller.  Will be called during
            	the render loop by ControllerManager.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller`1.Source">
            <summary>
            	The value that returns the source data for this controller.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller`1.Destination">
            <summary>
            	The object the sets the destination objects value.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller`1.Function">
            <summary>
            	Gets/Sets the eference to the function to be used for this controller.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller`1.IsEnabled">
            <summary>
            	Gets/Sets whether this controller is active or not.
            </summary>
        </member>
        <member name="T:Axiom.Animating.TagPoint">
            <summary>
            	A tagged point on a skeleton, which can be used to attach entities to on specific
            	other entities.
            </summary>
            <remarks>
            	A Skeleton, like a Mesh, is shared between Entity objects and simply updated as required
            	when it comes to rendering. However there are times when you want to attach another object
            	to an animated entity, and make sure that attachment follows the parent entity's animation
            	(for example, a character holding a gun in his / her hand). This class simply identifies
            	attachment points on a skeleton which can be used to attach child objects. 
            	<p/>
            	The child objects themselves are not physically attached to this class; as it's name suggests
            	this class just 'tags' the area. The actual child objects are attached to the Entity using the
            	skeleton which has this tag point. Use 
            	<see cref="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject,Axiom.Math.Quaternion,Axiom.Math.Vector3)"/> to attach
            	the objects, which creates a new TagPoint on demand.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.TagPoint.parentEntity">
            <summary>
            	Reference to the entity that owns this tagpoint.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TagPoint.childObject">
            <summary>
            	Object attached to this tagpoint.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TagPoint.fullLocalTransform">
            <summary>
            	Combined full local transform of this tagpoint.
            </summary>
        </member>
        <member name="M:Axiom.Animating.TagPoint.#ctor(System.UInt16,Axiom.Animating.Skeleton)">
            <summary>
            	Constructor.
            </summary>
            <param name="handle">Handle to use.</param>
            <param name="creator">Skeleton who created this tagpoint.</param>
        </member>
        <member name="M:Axiom.Animating.TagPoint.NeedUpdate">
            <summary>
            	Overridden to update parent entity.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.ChildObject">
            <summary>
            	Gets/Sets the object attached to this tagpoint.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.ParentEntity">
            <summary>
            	Gets/Sets the parent Entity that is using this tagpoint.	
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.FullLocalTransform">
            <summary>
            	Gets the transform of this node just for the skeleton (not entity).
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.ParentEntityTransform">
            <summary>
            	Transformation matrix of the parent entity.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.InheritParentEntityOrientation">
            <summary>
             Tells the TagPoint whether it should inherit orientation from it's parent entity.
            </summary>
            <remarks>
            If true, this TagPoint's orientation will be affected by
            its parent entity's orientation. If false, it will not be affected.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.TagPoint.FullTransform">
            <summary>
            	Gets the transform of this node including the parent entity and skeleton.
            </summary>
        </member>
        <member name="T:Axiom.Animating.SkeletonInstance">
            <summary>
            	A SkeletonInstance is a single instance of a Skeleton used by a world object.
            </summary>
            <remarks>
            	The difference between a Skeleton and a SkeletonInstance is that the
            	Skeleton is the 'master' version much like Mesh is a 'master' version of
            	Entity. Many SkeletonInstance objects can be based on a single Skeleton,
            	and are copies of it when created. Any changes made to this are not
            	reflected in the master copy. The exception is animations; these are
            	shared on the Skeleton itself and may not be modified here.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.SkeletonInstance.skeleton">
            <summary>
            	Reference to the master Skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletonInstance.nextTagPointAutoHandle">
            <summary>
            	Used for auto generated tag point handles to ensure they are unique.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.#ctor(Axiom.Animating.Skeleton)">
            <summary>
            	Constructor, don't call directly, this will be created automatically
            	when you create an <see cref="T:Axiom.Core.Entity"/> based on a skeletally animated Mesh.
            </summary>
            <param name="masterCopy"></param>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.CloneBoneAndChildren(Axiom.Animating.Bone,Axiom.Animating.Bone)">
            <summary>
            	Clones bones, for use in cloning the master skeleton to make this a unique
            	skeleton instance.
            </summary>
            <param name="source"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.CreateAnimation(System.String,System.Single)">
            <summary>
            	Creates a new Animation object for animating this skeleton.
            </summary>
            <remarks>
            	This method updates the reference skeleton, not just this instance!
            </remarks>
            <param name="name">The name of this animation.</param>
            <param name="length">The length of the animation in seconds.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.GetAnimation(System.String)">
            <summary>
            	Returns the <see cref="T:Axiom.Animating.Animation"/> object with the specified name.
            </summary>
            <param name="name">Name of the animation to retrieve.</param>
            <returns>Animation with the specified name, or null if none exists.</returns>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.RemoveAnimation(System.String)">
            <summary>
            	Removes an <see cref="T:Axiom.Animating.Animation"/> from this skeleton.
            </summary>
            <param name="name">Name of the animation to remove.</param>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.load">
            <summary>
            	Overriden to copy/clone the bones of the master skeleton.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.Unload">
            <summary>
            	Overriden to unload the skeleton and clear the tagpoint list.
            </summary>
        </member>
        <member name="P:Axiom.Animating.SkeletonInstance.Animations">
            <summary>
                Gets the animations associated with this skeleton
            </summary>
        </member>
        <member name="P:Axiom.Animating.SkeletonInstance.MasterSkeleton">
            <summary>
                Gets the master skeleton
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.BillboardParticleRenderer.attribParsers">
            <summary>
                List of available attibute parsers for script attributes.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.BillboardParticleRenderer.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.BillboardParticleRenderer.RegisterParsers">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to 
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.BillboardParticleRenderer.SetParameter(System.String,System.String)">
            <summary>
            	Parses an attribute intended for the particle system itself.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.BillboardParticleRendererFactory">
            Factory class for BillboardParticleRenderer 
        </member>
        <member name="M:Axiom.ParticleSystems.BillboardParticleRendererFactory.CreateInstance(System.String)">
            @copydoc FactoryObj::createInstance
        </member>
        <member name="T:Axiom.Graphics.MultiRenderTarget">
            <summary>
            This class represents a render target that renders to multiple RenderTextures
            at once. Surfaces can be bound and unbound at will, as long as the following constraints
            are met:
            - All bound surfaces have the same size
            
            - All bound surfaces have the same internal format 
            - Target 0 is bound
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MultiRenderTarget.BindSurface(System.Int32,Axiom.Graphics.RenderTexture)">
            <summary>
            Bind a surface to a certain attachment point.
            </summary>
            <param name="attachment">0 .. capabilities.MultiRenderTargetCount-1</param>
            <param name="target">RenderTexture to bind.</param>
            <remarks>
            It does not bind the surface and fails with an exception (ERR_INVALIDPARAMS) if:
            - Not all bound surfaces have the same size
            - Not all bound surfaces have the same internal format 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.MultiRenderTarget.UnbindSurface(System.Int32)">
            <summary>
            Unbind Attachment
            </summary>
            <param name="attachment"></param>
        </member>
        <member name="M:Axiom.Graphics.MultiRenderTarget.CopyContentsToMemory(Axiom.Media.PixelBox,Axiom.Graphics.RenderTarget.FrameBuffer)">
            <summary>
            Error throwing implementation, it's not possible to copy a MultiRenderTarget.
            </summary>
            <param name="pb"></param>	
            <param name="buffer"></param>
        </member>
        <member name="T:Axiom.Graphics.ICompositorLogic">
            <summary>
            Interface for compositor logics, which can be automatically bound to compositors,
            allowing per-compositor logic (such as attaching a relevant listener) to happen
            automatically.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ICompositorLogic.CompositorInstanceCreated(Axiom.Graphics.CompositorInstance)">
            <summary>
            Called when a compositor instance has been created.
            </summary>
            <remarks>
            This happens after its setup was finished, so the chain is also accessible.
            This is an ideal method to automatically attach a compositor listener.
            </remarks>
            <param name="newInstance"></param>
        </member>
        <member name="M:Axiom.Graphics.ICompositorLogic.CompositorInstanceDestroyed(Axiom.Graphics.CompositorInstance)">
            <summary>
            Called when a compositor instance has been destroyed
            </summary>
            <remarks>
            The chain that contained the compositor is still alive during this call.
            </remarks>
            <param name="destroyedInstance"></param>
        </member>
        <member name="T:Axiom.Graphics.CompositorLogic">
            <summary>
            Implementation base class for compositor logics, which can be automatically bound to compositors,
            allowing per-compositor logic (such as attaching a relevant listener) to happen
            automatically.
            </summary>
            <remarks>
            All methods have empty implementations to not force an implementer into
            extending all of them.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.CompositorLogic.CompositorInstanceCreated(Axiom.Graphics.CompositorInstance)">
            <summary>
            Called when a compositor instance has been created.
            </summary>
            <remarks>
            This happens after its setup was finished, so the chain is also accessible.
            This is an ideal method to automatically attach a compositor listener.
            </remarks>
            <param name="newInstance"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositorLogic.CompositorInstanceDestroyed(Axiom.Graphics.CompositorInstance)">
            <summary>
            Called when a compositor instance has been destroyed
            </summary>
            <remarks>
            The chain that contained the compositor is still alive during this call.
            </remarks>
            <param name="destroyedInstance"></param>
        </member>
        <member name="T:Axiom.Graphics.Compositor">
            <summary>
                Class representing a Compositor object. Compositors provide the means
                to flexibly "composite" the final rendering result from multiple scene renders
                and intermediate operations like rendering fullscreen quads. This makes
                it possible to apply postfilter effects, HDRI postprocessing, and shadow
                effects to a Viewport.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Compositor.compilationRequired">
            <summary>
                 This is set if the techniques change and the supportedness of techniques has to be
                 re-evaluated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Compositor.globalTextures">
            <summary>
            Store a list of textures we've created
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Compositor.globalMRTs">
            <summary>
            Store a list of MRTs we've created
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Compositor.autoNumber">
            <summary>
               Auto incrementing number for creating unique names.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.load">
            <summary>
            	Overridden from Resource.
            </summary>
            <remarks>
            	By default, Materials are not loaded, and adding additional textures etc do not cause those
            	textures to be loaded. When the <code>Load</code> method is called, all textures are loaded (if they
            	are not already), GPU programs are created if applicable, and Controllers are instantiated.
            	Once a material has been loaded, all changes made to it are immediately loaded too
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Compositor.unload">
            <summary>
            	Unloads the material, frees resources etc.
            	<see cref="T:Axiom.Core.Resource"/>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.dispose(System.Boolean)">
            <summary>
                Disposes of any resources used by this object.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.Touch">
            <summary>
               Overridden to ensure a recompile occurs if needed before use.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.CreateTechnique">
            <summary>
             Create a new technique, and return a pointer to it.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.RemoveTechnique(System.Int32)">
            <summary>
             Remove a technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.RemoveAllTechniques">
            <summary>
                Remove all techniques.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.GetSupportedTechniqueByScheme">
            <summary>
            Get a reference to a supported technique for a given scheme.
            </summary>
            <returns>the first supported technique with no specific scheme will be returned.</returns>
        </member>
        <member name="M:Axiom.Graphics.Compositor.GetSupportedTechniqueByScheme(System.String)">
            <summary>
            Get a reference to a supported technique for a given scheme.
            </summary>
            <param name="schemeName"> The scheme name you are looking for.
            Blank means to look for techniques with no scheme associated
            </param>
            <returns></returns>
            <remarks>
            If there is no specific supported technique with this scheme name,
            then the first supported technique with no specific scheme will be returned.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Compositor.GetTextureInstance(System.String,System.Int32)">
            <summary>
            Get's the instance of a global texture.
            </summary>
            <param name="name">The name of the texture in the original compositor definition</param>
            <param name="mrtIndex">If name identifies a MRT, which texture attachment to retrieve</param>
            <returns>The texture pointer, corresponds to a real texture</returns>
        </member>
        <member name="M:Axiom.Graphics.Compositor.GetRenderTarget(System.String)">
            <summary>
            Get's the render target for a given render texture name.
            </summary>
            <param name="name">name of the texture</param>
            <returns>rendertarget</returns>
            <remarks>
            You can use this to add listeners etc, but do not use it to update the
            targets manually or any other modifications, the compositor instance
            is in charge of this.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Compositor.GetMRTLocalName(System.String,System.Int32)">
             <summary>
            
             </summary>
             <param name="baseName"></param>
             <param name="attachment"></param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Compositor.Compile">
            <summary>
                Check supportedness of techniques.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.CreateGlobalTextures">
            <summary>
            Create global rendertextures.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Compositor.FreeGlobalTextures">
            <summary>
            Destroy global rendertextures.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Compositor.Techniques">
            <summary>
            List of all techniques
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Compositor.SupportedTechniques">
             <summary>
             List of supported techniques
             </summary>
            <remarks>
                The supported technique list is only available after this compositor has been compiled,
                which typically happens on loading it. Therefore, if this method returns
                an empty list, try calling <see>Compositor.Load</see>.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.CompositionPass">
            <summary>
                Object representing one pass or operation in a composition sequence. This provides a 
                method to conviently interleave RenderSystem commands between Render Queues.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.parent">
            <summary>
                Parent technique
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.type">
            <summary>
                Type of composition pass
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.identifier">
            <summary>
                Identifier for this pass
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.material">
            <summary>
                Material used for rendering
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.materialSchemeName">
            <summary>
            Material scheme name
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.firstRenderQueue">
            <summary>
                first render queue to render this pass (in case of CompositorPassType.RenderScene)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.lastRenderQueue">
            <summary>
                last render queue to render this pass (in case of CompositorPassType.RenderScene)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.clearBuffers">
            <summary>
                Clear buffers (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.clearColor">
            <summary>
                Clear colour (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.clearDepth">
            <summary>
                Clear depth (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.clearStencil">
            <summary>
                Clear stencil value (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.inputs">
            <summary>
                Inputs (for material used for rendering the quad)
                An empty string signifies that no input is used
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.stencilCheck">
            <summary>
                Stencil operation parameters
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadCornerModified">
            <summary>
            true if quad should not cover whole screen
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadLeft">
            <summary>
            quad positions in normalised coordinates [-1;1]x[-1;1] (in case of RENDERQUAD)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadTop">
            <summary>
            quad positions in normalised coordinates [-1;1]x[-1;1] (in case of RENDERQUAD)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadRight">
            <summary>
            quad positions in normalised coordinates [-1;1]x[-1;1] (in case of RENDERQUAD)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadBottom">
            <summary>
            quad positions in normalised coordinates [-1;1]x[-1;1] (in case of RENDERQUAD)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadFarCorners">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.quadFarCornersViewSpace">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.SetInput(System.Int32,System.String,System.Int32)">
            <summary>
                Set an input local texture. An empty string clears the input.
            </summary>
            <param name="id">Input to set. Must be in 0..Config.MaxTextureLayers-1</param>
            <param name="name">Which texture to bind to this input. An empty string clears the input.</param>
             <param name="mrtIndex"></param>
            <remarks>
                Note applies when CompositorPassType is RenderQuad 
            </remarks>	
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.GetInput(System.Int32)">
            <summary>
                Get the value of an input.
            </summary>
            <param name="id">Input to get. Must be in 0..Config.MaxTextureLayers-1.</param>
            <remarks>
                Note applies when CompositorPassType is RenderQuad 
            </remarks>	
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.ClearAllInputs">
            <summary>
                Clear all inputs.
            </summary>
            <remarks>
                Note applies when CompositorPassType is RenderQuad 
            </remarks>	
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.SetQuadCorners(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set quad normalised positions [-1;1]x[-1;1]
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.GetQuadCorners(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Get quad normalised positions [-1;1]x[-1;1]
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.SetQuadFarCorners(System.Boolean,System.Boolean)">
            <summary>
            Sets the use of camera frustum far corners provided in the quad's normals
            </summary>
            <param name="farCorners"></param>
            <param name="farCornersViewSpace"></param>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.Parent">
            <summary>
                Parent technique
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.Type">
            <summary>
                Type of composition pass
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.Identifier">
            <summary>
                Identifier for this pass
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.Material">
            <summary>
                Material used for rendering
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.MaterialName">
            <summary>
                Material name to use for rendering
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.MaterialScheme">
            <summary>
            Get's or set's the material scheme used by this pass
            </summary>
            <remarks>
            Only applicable to passes that render the scene.
            <see cref="P:Axiom.Graphics.Technique.Scheme"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.FirstRenderQueue">
            <summary>
                first render queue to render this pass (in case of CompositorPassType.RenderScene)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.LastRenderQueue">
            <summary>
                last render queue to render this pass (in case of CompositorPassType.RenderScene)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.ClearBuffers">
            <summary>
                Clear buffers (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.ClearColor">
            <summary>
                Clear colour (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.ClearDepth">
            <summary>
                Clear depth (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.ClearStencil">
            <summary>
                Clear stencil value (in case of CompositorPassType.Clear)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.Inputs">
            <summary>
                Inputs (for material used for rendering the quad)
                An empty string signifies that no input is used
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.QuadFarCorners">
            <summary>
            Returns true if camera frustum far corners are provided in the quad.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.QuadFarCornersViewSpace">
            <summary>
            Returns true if the far corners provided in the quad are in view space
            </summary>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.CustomType">
            <summary>
            Get's or set's the type name of this custom composition pass.
            <see cref="M:Axiom.Graphics.CompositorManager.RegisterCustomCompositorPass(System.String,Axiom.Graphics.ICustomCompositionPass)"/>
            </summary>
            <note>
            applies when PassType is RenderCustom
            </note>
        </member>
        <member name="P:Axiom.Graphics.CompositionPass.InputsCount">
            <summary>
                Get the number of inputs used.  If there are holes in the inputs array,
                this number will include those entries as well.
            </summary>
            <remarks>
                Note applies when CompositorPassType is RenderQuad 
            </remarks>	
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.InputTexture.Name">
            <summary>
            Name (local) of the input texture (empty == no input)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CompositionPass.InputTexture.MrtIndex">
            <summary>
            MRT surface index if applicable
            </summary>
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.InputTexture.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name">Name (local) of the input texture (empty == no input)</param>
        </member>
        <member name="M:Axiom.Graphics.CompositionPass.InputTexture.#ctor(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name">Name (local) of the input texture (empty == no input)</param>
            <param name="mrtIndex">MRT surface index if applicable</param>
        </member>
        <member name="T:Axiom.Graphics.Collections.RenderSystemCollection">
            <summary>
            Represents a collection of <see cref="T:Axiom.Graphics.RenderSystem">RenderSystems</see> that are sorted by name.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Collections.RenderSystemCollection.Add(System.String,Axiom.Graphics.RenderSystem)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The name of the <see cref="T:Axiom.Graphics.RenderSystem"/> to add.</param>
            <param name="item">A <see cref="T:Axiom.Graphics.RenderSystem"/>.</param>
        </member>
        <member name="T:Axiom.Animating.Collections.KeyFrameList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Animating.KeyFrame">KeyFrames</see>.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Collections.BoneList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Animating.Bone">Bones</see>.
            </summary>
        </member>
        <member name="T:Axiom.Utilities.ExceptionFactory">
            <summary>
            Factory class for some exception classes that have variable constructors based on the 
            framework that is targeted. Rather than use <c>#if</c> around the different constructors
            use the least common denominator, but wrap it in an easier to use method.
            </summary>
        </member>
        <member name="M:Axiom.Utilities.ExceptionFactory.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)">
            <summary>
            Factory for the <c>ArgumentOutOfRangeException</c>
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Utilities.ExceptionFactory.CreateArgumentItemNullException(System.Int32,System.String)">
            <summary>
            Factory for the <c>ArgumentOutOfRangeException</c>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Media.BasicBox">
            <summary>
                Structure used to define a box in a 3-D integer space.
                Note that the left, top, and front edges are included but the right, 
                bottom and top ones are not.
            </summary>
        </member>
        <member name="M:Axiom.Media.BasicBox.#ctor">
            <summary>
                Parameterless constructor for setting the members manually
            </summary>
        </member>
        <member name="M:Axiom.Media.BasicBox.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Define a box from left, top, right and bottom coordinates
                This box will have depth one (front=0 and back=1).
            </summary>
            <param name="left">x value of left edge</param>
            <param name="top">y value of top edge</param>
            <param name="right">x value of right edge</param>
            <param name="bottom">y value of bottom edge</param>
            <remarks>
                Note that the left, top, and front edges are included 
                but the right, bottom and top ones are not.
            </remarks>
        </member>
        <member name="M:Axiom.Media.BasicBox.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Define a box from left, top, front, right, bottom and back
                coordinates.
            </summary>
            <param name="left">x value of left edge</param>
            <param name="top">y value of top edge</param>
            <param name="front">z value of front edge</param>
            <param name="right">x value of right edge</param>
            <param name="bottom">y value of bottom edge</param>
            <param name="back">z value of back edge</param>
            <remarks>
                Note that the left, top, and front edges are included 
                but the right, bottom and back ones are not.
            </remarks>
        </member>
        <member name="M:Axiom.Media.BasicBox.Contains(Axiom.Media.BasicBox)">
            <summary>
                Return true if the other box is a part of this one
            </summary>
        </member>
        <member name="P:Axiom.Media.BasicBox.Width">
            <summary>
                Get the width of this box
            </summary>
        </member>
        <member name="P:Axiom.Media.BasicBox.Height">
            <summary>
                Get the height of this box
            </summary>
        </member>
        <member name="P:Axiom.Media.BasicBox.Depth">
            <summary>
                Get the depth of this box
            </summary>
        </member>
        <member name="T:Axiom.Media.PixelBox">
            <summary>
                A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory.
                In case of a rectangle, depth must be 1. 
                Pixels are stored as a succession of "depth" slices, each containing "height" rows of 
                "width" pixels.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelBox.data">
            <summary>
                The data pointer.  We do not own this.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelBox.offset">
            <summary>
                A byte offset into the data
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelBox.format">
            <summary>
                The pixel format 
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelBox.rowPitch">
            <summary>
                Number of elements between the leftmost pixel of one row and the left
                pixel of the next. This value must always be equal to getWidth() (consecutive) 
                for compressed formats.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelBox.slicePitch">
            <summary>
                Number of elements between the top left pixel of one (depth) slice and 
                the top left pixel of the next. This can be a negative value. Must be a multiple of
                rowPitch. This value must always be equal to getWidth()*getHeight() (consecutive) 
                for compressed formats.
            </summary>
        </member>
        <member name="M:Axiom.Media.PixelBox.#ctor">
            <summary>
                Parameter constructor for setting the members manually
            </summary>
        </member>
        <member name="M:Axiom.Media.PixelBox.#ctor(Axiom.Media.BasicBox,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
                Constructor providing extents in the form of a Box object. This constructor
                assumes the pixel data is laid out consecutively in memory. (this
                means row after row, slice after slice, with no space in between)
            </summary>
            <param name="extents">Extents of the region defined by data</param>
            <param name="format">Format of this buffer</param>
            <param name="data">Pointer to the actual data</param>
        </member>
        <member name="M:Axiom.Media.PixelBox.#ctor(System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat,System.IntPtr)">
            <summary>
                Constructor providing width, height and depth. This constructor
                assumes the pixel data is laid out consecutively in memory. (this
                means row after row, slice after slice, with no space in between)
            </summary>
            <param name="width">Width of the region</param>
            <param name="height">Height of the region</param>
            <param name="depth">Depth of the region</param>
            <param name="format">Format of this buffer</param>
            <param name="data">Pointer to the actual data</param>
        </member>
        <member name="M:Axiom.Media.PixelBox.SetConsecutive">
            <summary>
                Set the rowPitch and slicePitch so that the buffer is laid out consecutive 
                in memory.
            </summary>
        </member>
        <member name="M:Axiom.Media.PixelBox.Compressed(Axiom.Media.PixelFormat)">
            <summary>
                I don't know how to figure this out.  For now, just deal with the DXT* formats
            </summary>
        </member>
        <member name="M:Axiom.Media.PixelBox.GetSubVolume(Axiom.Media.BasicBox)">
            <summary>
            Return a subvolume of this PixelBox.
            </summary>
            <param name="def">Defines the bounds of the subregion to return</param>
            <returns>A pixel box describing the region and the data in it</returns>
            <remarks>This function does not copy any data, it just returns
            a PixelBox object with a data pointer pointing somewhere inside 
            the data of object.
            Throws an Exception if def is not fully contained.
            </remarks>
        </member>
        <member name="P:Axiom.Media.PixelBox.Data">
            <summary>
                Get/set the data array
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.Offset">
            <summary>
                Get/set the offset into the data array
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.Format">
            <summary>
                Get/set the pixel format
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.RowPitch">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.RowSkip">
            <summary>
                Get the number of elements between one past the rightmost pixel of 
                one row and the leftmost pixel of the next row. (IE this is zero if rows
                are consecutive).
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.SlicePitch">
            <summary>
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.SliceSkip">
            <summary>
                Get the number of elements between one past the right bottom pixel of
                one slice and the left top pixel of the next slice. (IE this is zero if slices
                are consecutive).
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.IsConsecutive">
            <summary>
                Return whether this buffer is laid out consecutive in memory (ie the pitches
                are equal to the dimensions)
            </summary>
        </member>
        <member name="P:Axiom.Media.PixelBox.ConsecutiveSize">
            <summary>
                Return the size (in bytes) this image would take if it was
                laid out consecutive in memory
            </summary>
        </member>
        <member name="T:Axiom.Math.PositionalSpline">
            <summary>
            	A Catmull-Rom spline that can be used for interpolating translation movements.
            </summary>
            <remarks>
            	A Catmull-Rom spline is a derivitive of the Hermite spline.  The difference is that the Hermite spline
            	allows you to specifiy 2 endpoints and 2 tangents, then the spline is generated.  A Catmull-Rom spline
            	allows you to just supply 1-n number of points and the tangents will be automatically calculated.
            	<p/>
            	Derivation of the hermite polynomial can be found here: 
            	<a href="http://www.cs.unc.edu/~hoff/projects/comp236/curves/papers/hermite.html">Hermite splines.</a>
            </remarks>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.#ctor">
            <summary>
            	Creates a new Positional Spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.Interpolate(Axiom.Math.Real)">
            <summary>
            	Returns an interpolated point based on a parametric value over the whole series.
            </summary>
            <remarks>
            	Given a t value between 0 and 1 representing the parametric distance along the
            	whole length of the spline, this method returns an interpolated point.
            </remarks>
            <param name="t">Parametric value.</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.Interpolate(System.Int32,Axiom.Math.Real)">
            <summary>
            	Interpolates a single segment of the spline given a parametric value.
            </summary>
            <param name="index">The point index to treat as t=0. index + 1 is deemed to be t=1</param>
            <param name="t">Parametric value</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.RecalculateTangents">
            <summary>
            	Recalculates the tangents associated with this spline. 
            </summary>
            <remarks>
            	If you tell the spline not to update on demand by setting AutoCalculate to false,
            	then you must call this after completing your updates to the spline points.
            </remarks>
        </member>
        <member name="T:Axiom.Math.Intersection">
            <summary>
               Type of intersection detected between 2 object.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.None">
            <summary>
               The objects are not intersecting.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.Contained">
            <summary>
               An object is fully contained within another object.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.Contains">
            <summary>
               An object fully contains another object.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.Partial">
            <summary>
               The objects are partially intersecting each other.
            </summary>
        </member>
        <member name="T:Axiom.Math.PlaneSide">
            <summary>
            The "positive side" of the plane is the half space to which the
            plane normal points. The "negative side" is the other half
            space. The flag "no side" indicates the plane itself.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.MaterialManager">
            <summary>
                Class for managing Material settings.
            </summary>
            <remarks>
                Materials control the eventual surface rendering properties of geometry. This class
                manages the library of materials, dealing with programmatic registrations and lookups,
                as well as loading predefined Material settings from scripts.
                <p/>
                When loaded from a script, a Material is in an 'unloaded' state and only stores the settings
                required. It does not at that stage load any textures. This is because the material settings may be
                loaded 'en masse' from bulk material script files, but only a subset will actually be required.
                <p/>
                Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or
                archive added to the resource paths/archives. See ResourceManager for details.
                <p/>
                For a definition of the material script format, see <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC25">here</a>.
            </remarks>
            
            <ogre name="MaterialManager">
                <file name="OgreMaterialManager.h"   revision="" lastUpdated="6/19/2006" lastUpdatedBy="Borrillis" />
                <file name="OgreMaterialManager.cpp" revision="" lastUpdated="6/19/2006" lastUpdatedBy="Borrillis" />
            </ogre> 
            
        </member>
        <member name="F:Axiom.Graphics.MaterialManager._defaultMinFilter">
            <summary>
                Default Texture filtering - minification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager._defaultMagFilter">
            <summary>
                Default Texture filtering - magnification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager._defaultMipFilter">
            <summary>
                Default Texture filtering - mipmapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager._defaultMaxAniso">
            <summary>
                Default Texture anisotropy.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager._serializer">
            <summary>
            	Used for parsing material scripts.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.#ctor">
            <summary>
            private constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.Initialize">
            <summary>
                Sets up default materials and parses all material scripts.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.SetDefaultTextureFiltering(Axiom.Graphics.TextureFiltering)">
            <overload>
            <summary>
                Sets the default texture filtering to be used for loaded textures, for when textures are
                loaded automatically (e.g. by Material class) or when 'load' is called with the default
                parameters by the application.
            </summary>
            </overload> 
            <param name="filtering"></param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.SetDefaultTextureFiltering(Axiom.Graphics.FilterType,Axiom.Graphics.FilterOptions)">
            <param name="type">Type to configure.</param>
            <param name="options">Options to set for the specified type.</param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.SetDefaultTextureFiltering(Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions)">
            <param name="minFilter">Minification filter.</param>
            <param name="magFilter">Magnification filter.</param>
            <param name="mipFilter">Map filter.</param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.GetDefaultTextureFiltering(Axiom.Graphics.FilterType)">
            <summary>
                Gets the default texture filtering options for the specified filter type.
            </summary>
            <param name="type">Filter type to get options for.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.GetDefaultTextureFiltering">
            <summary>
                Gets the default texture filtering options.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.GetSchemeIndex(System.String)">
            <summary>
            The index for the given material scheme name. 
            </summary>
            <seealso ref="Technique.SchemeName"/>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.GetSchemeName(System.UInt16)">
            <summary>
            The name for the given material scheme index. 
            </summary>
            <seealso ref="Technique.SchemeName"/>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.AddListener(Axiom.Graphics.MaterialManager.SchemeNotFoundHandler,System.String)">
            <summary>
            Add a listener to handle material events. 
            If schemeName is supplied, the listener will only receive events for that certain scheme.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.RemoveListener(Axiom.Graphics.MaterialManager.SchemeNotFoundHandler,System.String)">
            <summary>
            Remove a listener handling material events. 
            If the listener was added with a custom scheme name, it needs to be supplied here as well.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.ArbitrateMissingTechniqueForActiveScheme(Axiom.Graphics.Material,System.Int32,Axiom.Graphics.IRenderable)">
            <summary>Internal method for sorting out missing technique for a scheme</summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.ParseScript(System.IO.Stream,System.String,System.String)">
            <summary>
               Parse a .material script passed in as a chunk.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.dispose(System.Boolean)">
            <summary>
            Dispose of this object 
            </summary>
            <ogre name="~MaterialManager" />
        </member>
        <member name="P:Axiom.Graphics.MaterialManager.DefaultAnisotropy">
            <summary>
               Sets the default anisotropy level to be used for loaded textures, for when textures are
               loaded automatically (e.g. by Material class) or when 'Load' is called with the default
               parameters by the application.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MaterialManager.ActiveSchemeIndex">
            <summary>
            The active scheme index. 
            </summary>
            <seealso ref="Technique.SchemeIndex"/>
        </member>
        <member name="P:Axiom.Graphics.MaterialManager.ActiveScheme">
            <summary>
            The name of the active material scheme. 
            </summary>
            <seealso ref="Technique.SchemeName"/>
        </member>
        <member name="P:Axiom.Graphics.MaterialManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Material">
            <summary>
               Class encapsulating the rendering properties of an object.
            </summary>
            <remarks>
               The Material class encapsulates ALL aspects of the visual appearance,
               of an object. It also includes other flags which
               might not be traditionally thought of as material properties such as
               culling modes and depth buffer settings, but these affect the
               appearance of the rendered object and are convenient to attach to the
               material since it keeps all the settings in one place. This is
               different to Direct3D which treats a material as just the color
               components (diffuse, specular) and not texture maps etc. This
               Material can be thought of as equivalent to a 'Shader'.
               <p/>
               A Material can be rendered in multiple different ways depending on the
               hardware available. You may configure a Material to use high-complexity
               fragment shaders, but these won't work on every card; therefore a Technique
               is an approach to creating the visual effect you are looking for. You are advised
               to create fallback techniques with lower hardware requirements if you decide to
               use advanced features. In addition, you also might want lower-detail techniques
               for distant geometry.
               <p/>
               Each technique can be made up of multiple passes. A fixed-function pass
               may combine multiple texture layers using multi-texturing, but they can
               break that into multiple passes automatically if the active card cannot
               handle that many simultaneous textures. Programmable passes, however, cannot
               be split down automatically, so if the active graphics card cannot handle the
               technique which contains these passes, the engine will try to find another technique
               which the card can do. If, at the end of the day, the card cannot handle any of the
               techniques which are listed for the material, the engine will render the
               geometry plain white, which should alert you to the problem.
               <p/>
               The engine comes configured with a number of default settings for a newly
               created material. These can be changed if you wish by retrieving the
               default material settings through
               SceneManager.DefaultMaterialSettings. Any changes you make to the
               Material returned from this method will apply to any materials created
               from this point onward.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.Material.autoNumber">
            <summary>
               Auto incrementing number for creating unique names.
            </summary>
            <ogre name="" />
        </member>
        <member name="F:Axiom.Graphics.Material.defaultSettings">
            <summary>
            A reference to a precreated Material that contains all the default settings.
            </summary>
            <ogre name="" />
        </member>
        <member name="F:Axiom.Graphics.Material.bestTechniquesByScheme">
             <summary>
            
             </summary>
             <ogre name="mBestTechniqueList" />
        </member>
        <member name="F:Axiom.Graphics.Material._receiveShadows">
            <summary>
            	Should objects using this material receive shadows?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material._transparencyCastsShadows">
            <summary>
            	Do transparent objects casts shadows?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
            Sets the fogging mode applied to each pass.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.SetFog"></see>
            </remarks>
            <ogre name="" />
        </member>
        <member name="M:Axiom.Graphics.Material.SetSceneBlending(Axiom.Graphics.SceneBlendType)">
            <summary>
            Sets the kind of blending every pass has with the existing contents of the scene.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.SetSceneBlending"></see>
            </remarks>
            <ogre name="" />
        </member>
        <member name="M:Axiom.Graphics.Material.SetSceneBlending(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)">
            <summary>
            Allows very fine control of blending every Pass with the existing contents of the scene.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.SetSceneBlending"></see>
            </remarks>
            <ogre name="" />
        </member>
        <member name="M:Axiom.Graphics.Material.Compile">
            <overloads>
            <summary>
               'Compiles' this Material.
            </summary>
            <remarks>
               Compiling a material involves determining which Techniques are supported on the
               card on which the engine is currently running, and for fixed-function Passes within those
               Techniques, splitting the passes down where they contain more TextureUnitState
               instances than the current card has texture units.
               <p/>
               This process is automatically done when the Material is loaded, but may be
               repeated if you make some procedural changes.
            </remarks>
            <ogre name="compile" />
            </overloads>
            <remarks>
               By default, the engine will automatically split texture unit operations into multiple
               passes when the target hardware does not have enough texture units.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Material.Compile(System.Boolean)">
            <param name="autoManageTextureUnits">
               If true, when a fixed function pass has too many TextureUnitState
               entries than the card has texture units, the Pass in question will be split into
               more than one Pass in order to emulate the Pass. If you set this to false and
               this situation arises, an Exception will be thrown.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Material.CreateTechnique">
            <summary>
               Creates a new Technique for this Material.
            </summary>
            <remarks>
               A Technique is a single way of rendering geometry in order to achieve the effect
               you are intending in a material. There are many reason why you would want more than
               one - the main one being to handle variable graphics card abilities; you might have
               one technique which is impressive but only runs on 4th-generation graphics cards,
               for example. In this case you will want to create at least one fallback Technique.
               The engine will work out which Techniques a card can support and pick the best one.
               <p/>
               If multiple Techniques are available, the order in which they are created is
               important - the engine will consider lower-indexed Techniques to be preferable
               to higher-indexed Techniques, ie when asked for the 'best' technique it will
               return the first one in the technique list which is supported by the hardware.
            </remarks>
            <returns></returns>
            <ogre name="createTechnique" />
        </member>
        <member name="M:Axiom.Graphics.Material.GetTechnique(System.Int32)">
            <summary>
               Gets the technique at the specified index.
            </summary>
            <param name="index">Index of the technique to return.</param>
            <returns></returns>
            <ogre name="getTechnique" />
        </member>
        <member name="M:Axiom.Graphics.Material.NotifyNeedsRecompile">
            <summary>
               Tells the material that it needs recompilation.
            </summary>
            <ogre name="_notifyNeedsRecompile" />
        </member>
        <member name="M:Axiom.Graphics.Material.RemoveTechnique(Axiom.Graphics.Technique)">
            <summary>
               Removes the specified Technique from this material.
            </summary>
            <param name="t">A reference to the technique to remove</param>
            <ogre name="removeTechnique" />
        </member>
        <member name="M:Axiom.Graphics.Material.RemoveAllTechniques">
            <summary>
            	Removes all techniques from this material.
            </summary>
            <ogre name="removeAllTechniques" />
        </member>
        <member name="M:Axiom.Graphics.Material.Clone(System.String)">
            <summary>
               Creates a copy of this Material with the specified name (must be unique).
            </summary>
            <param name="newName">The name that the cloned material will be known as.</param>
            <returns></returns>
            <ogre name="clone" />
        </member>
        <member name="M:Axiom.Graphics.Material.ApplyDefaults">
             <summary>
            
             </summary>
             <ogre name="applyDefaults" />
        </member>
        <member name="M:Axiom.Graphics.Material.ApplyTextureAliases(System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>
            Applies texture names to Texture Unit State with matching texture name aliases.
            All techniques, passes, and Texture Unit States within the material are checked.
            If matching texture aliases are found then true is returned.
            </summary>
            <param name="aliasList">is a map container of texture alias, texture name pairs</param>
            <param name="apply">set true to apply the texture aliases else just test to see if texture alias matches are found.</param>
            <returns>True if matching texture aliases were found in the material.</returns>
        </member>
        <member name="M:Axiom.Graphics.Material.CopyTo(Axiom.Graphics.Material)">
            <overload>
            <summary>
            	Copies the details from the supplied material.
            </summary>
            <param name="target">Material which will receive this material's settings.</param>
            <ogre name="copyDetailsTo" />
            <ogre name="operator =" />
            </overload>
        </member>
        <member name="M:Axiom.Graphics.Material.CopyTo(Axiom.Graphics.Material,System.Boolean)">
            <param name="target"></param>
            <param name="copyUniqueInfo">preserves the target's handle, group, name, and loading properties (unlike operator=) but copying everything else.</param>
        </member>
        <member name="M:Axiom.Graphics.Material.GetBestTechnique">
            <overloads>
            <summary>
               Gets the best supported technique.
            </summary>
            <remarks>
               This method returns the lowest-index supported Technique in this material
               (since lower-indexed Techniques are considered to be better than higher-indexed
               ones).
               <p/>
               The best supported technique is only available after this material has been compiled,
               which typically happens on loading the material. Therefore, if this method returns
               null, try calling Material.Load.
            </remarks>
            <ogre name="getBestTechnique" />
            </overloads>
        </member>
        <member name="M:Axiom.Graphics.Material.GetBestTechnique(System.Int32)">
            <param name="lodIndex"></param>
        </member>
        <member name="F:Axiom.Graphics.Material._lodValues">
            <summary>
            List of LOD distances specified for this material.
            </summary>
            <ogre name="mLodDistances" />
        </member>
        <member name="F:Axiom.Graphics.Material.UserLodValues">
            <summary>
            List of LOD distances specified for this material.
            </summary>
            <ogre name="mUserLodDistances" />
        </member>
        <member name="F:Axiom.Graphics.Material._lodStrategy">
            <summary>
            The LOD stategy for this material
            </summary>
            <ogre name="mLodStrategy" />
        </member>
        <member name="M:Axiom.Graphics.Material.SetLodLevels(Axiom.Core.Collections.LodValueList)">
            <summary>
            	Sets the distance at which level-of-detail (LOD) levels come into effect.
            </summary>
            <remarks>
            	You should only use this if you have assigned LOD indexes to the <see cref="T:Axiom.Graphics.Technique"/>
            	instances attached to this <see cref="T:Axiom.Graphics.Material"/>. If you have done so, you should call this
            	method to determine the distance at which the low levels of detail kick in.
            	The decision about what distance is actually used is a combination of this
            	and the LOD bias applied to both the current <see cref="T:Axiom.Core.Camera"/> and the current Entity.
            </remarks>
            <param name="lodDistanceList">
            	A list of floats which indicate the distance at which to
            	switch to lower details. They are listed in LOD index order, starting at index
            	1 (ie the first level down from the highest level 0, which automatically applies
            	from a distance of 0).
            </param>
            <ogre name="setLoadLevels"/>
        </member>
        <member name="M:Axiom.Graphics.Material.GetLodIndex(Axiom.Math.Real)">
            <summary>
            Gets the LOD index to use at the given distance.
            </summary>
            <remarks>
            The value passed in is the 'transformed' value. If you are dealing with
            an original source value (e.g. distance), use <see name="LodStrategy.TransformUserValue"/>
            to turn this into a lookup value.
            </remarks>
            <param name="distance"></param>
            <returns></returns>
            <ogre name="getLodIndex" />
        </member>
        <member name="M:Axiom.Graphics.Material.CompareTo(System.Object)">
            <summary>
            	Used for comparing 2 Material objects.
            </summary>
            <remarks>
            	This comparison will be used in RenderQueue group sorting of Materials materials.
            	If this object is transparent and the object being compared is not, this is greater that obj.
            	If this object is not transparent and the object being compared is, obj is greater than this.
            </remarks>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.load">
            <summary>
            	Overridden from Resource.
            </summary>
            <remarks>
            	By default, Materials are not loaded, and adding additional textures etc do not cause those
            	textures to be loaded. When the <code>Load</code> method is called, all textures are loaded (if they
            	are not already), GPU programs are created if applicable, and Controllers are instantiated.
            	Once a material has been loaded, all changes made to it are immediately loaded too
            </remarks>
            <ogre name="loadImpl" />
        </member>
        <member name="M:Axiom.Graphics.Material.unload">
            <summary>
            	Unloads the material, frees resources etc.
            	<see cref="T:Axiom.Core.Resource"/>
            </summary>
            <ogre name="unloadImpl"/>
        </member>
        <member name="M:Axiom.Graphics.Material.calculateSize">
            <summary>
            Calculate the size of a material; this will only be called after 'load'
            </summary>
            <returns></returns>
            <ogre name="calculateSize" />
        </member>
        <member name="M:Axiom.Graphics.Material.Touch">
            <summary>
               Overridden to ensure a recompile occurs if needed before use.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.dispose(System.Boolean)">
            <summary>
               Overridden to ensure a release of techniques.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.GetHashCode">
            <summary>
               Overridden to give Materials a meaningful hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.ToString">
            <summary>
               Overridden.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.Material.techniques">
            <summary>
               A list of techniques that exist within this Material.
            </summary>
            <ogre name="mTechniques" />
        </member>
        <member name="P:Axiom.Graphics.Material.SupportedTechniques">
            <summary>
               A list of the techniques of this material that are supported by the current hardware.
            </summary>
            <ogre name="mSupportedTechniques" />
        </member>
        <member name="P:Axiom.Graphics.Material.compilationRequired">
            <summary>
               Flag noting whether or not this Material needs to be re-compiled.
            </summary>
            <ogre name="mCompilationRequired" />
        </member>
        <member name="P:Axiom.Graphics.Material.ReceiveShadows">
            <summary>
            	Sets whether objects using this material will receive shadows.
            </summary>
            <remarks>
            	This method allows a material to opt out of receiving shadows, if
            	it would otherwise do so. Shadows will not be cast on any objects
            	unless the scene is set up to support shadows and not all techniques
            	cast shadows on all objects. In any case, if you have a need to prevent
            	shadows being received by material, this is the method you call to do it.
            	Note: Transparent materials never receive shadows despite this setting.
            	The default is to receive shadows.
            	<seealso cref="P:Axiom.Core.SceneManager.ShadowTechnique"/>
            </remarks>
            <ogre name="setRecieveShadows"/>
            <ogre name="getRecieveShadows"/>
        </member>
        <member name="P:Axiom.Graphics.Material.TransparencyCastsShadows">
            <summary>
            	Gets/Sets whether objects using this material be classified as opaque to the shadow caster system.
            </summary>
            <remarks>
            	This method allows a material to cast a shadow, even if it is transparent.
            	By default, transparent materials neither cast nor receive shadows. Shadows
            	will not be cast on any objects unless the scene is set up to support shadows
            	<seealso cref="P:Axiom.Core.SceneManager.ShadowTechnique"/>, and not all techniques cast
            	shadows on all objects.
            </remarks>
            <ogre name="setTransparentCastsShadows"/>
            <ogre name="getTransparentCastsShadows"/>
        </member>
        <member name="P:Axiom.Graphics.Material.IsTransparent">
            <summary>
            	Determines if the material has any transparency with the rest of the scene (derived from
               whether any Techniques say they involve transparency).
            </summary>
            <ogre name="isTransparent" />
        </member>
        <member name="P:Axiom.Graphics.Material.TechniqueCount">
            <summary>
               Gets the number of techniques within this Material.
            </summary>
            <ogre name="getNumTechniques" />
        </member>
        <member name="P:Axiom.Graphics.Material.Ambient">
            <summary>Sets the ambient colour reflectance properties for every Pass in every Technique.</summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.Ambient"></see>
            </remarks>
            <ogre name="setAmbient" />
        </member>
        <member name="P:Axiom.Graphics.Material.Diffuse">
            <summary>
            Sets the diffuse colour reflectance properties of every Pass in every Technique.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.Diffuse"></see>
            </remarks>
            <ogre name="setDiffuse" />
        </member>
        <member name="P:Axiom.Graphics.Material.Specular">
            <summary>
            Sets the specular colour reflectance properties of every Pass in every Technique.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.Specular"></see>
            </remarks>
            <ogre name="setSpecular" />
        </member>
        <member name="P:Axiom.Graphics.Material.Shininess">
            <summary>
            Sets the shininess properties of every Pass in every Technique.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.Shininess"></see>
            </remarks>
            <ogre name="setShininess" />
        </member>
        <member name="P:Axiom.Graphics.Material.SelfIllumination">
            <summary>
            Sets the amount of self-illumination of every Pass in every Technique.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.SelfIllumination"></see>
            </remarks>
            <ogre name="setSelfIllumination" />
        </member>
        <member name="P:Axiom.Graphics.Material.DepthCheck">
            <summary>
            Sets whether or not each Pass renders with depth-buffer checking on or not.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.DepthCheck"></see>
            </remarks>
            <ogre name="setDepthCheckEnabled" />
        </member>
        <member name="P:Axiom.Graphics.Material.DepthFunction">
            <summary>
            Sets the function used to compare depth values when depth checking is on.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.DepthFunction"></see>
            </remarks>
            <ogre name="setDepthFunction" />
        </member>
        <member name="P:Axiom.Graphics.Material.DepthWrite">
            <summary>
            Sets whether or not each Pass renders with depth-buffer writing on or not.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.DepthWrite"></see>
            </remarks>
            <ogre name="setDepthWriteEnabled" />
        </member>
        <member name="P:Axiom.Graphics.Material.ColorWriteEnabled">
            <summary>
            Sets whether or not colour buffer writing is enabled for each Pass.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.ColorWriteEnabled"></see>
            </remarks>
            <ogre name="setColourWriteEnabled" />
        </member>
        <member name="P:Axiom.Graphics.Material.CullingMode">
            <summary>
            Sets the culling mode for each pass  based on the 'vertex winding'.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.CullingMode"></see>
            </remarks>
            <ogre name="setCullingMode" />
        </member>
        <member name="P:Axiom.Graphics.Material.ManualCullingMode">
            <summary>
            Sets the manual culling mode, performed by CPU rather than hardware.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.ManualCullingMode"></see>
            </remarks>
            <ogre name="setManualCullingMode" />
        </member>
        <member name="P:Axiom.Graphics.Material.Lighting">
            <summary>
            Sets whether or not dynamic lighting is enabled for every Pass.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.Lighting"></see>
            </remarks>
            <ogre name="setLighting" />
        </member>
        <member name="P:Axiom.Graphics.Material.DepthBias">
            <summary>
            Sets the depth bias to be used for each Pass.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.DepthBias"></see>
            </remarks>
            <ogre name="setDepthBias" />
        </member>
        <member name="P:Axiom.Graphics.Material.TextureFiltering">
            <summary>
            Set texture filtering for every texture unit in every Technique and Pass
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.TextureFiltering"></see>
            </remarks>
            <ogre name="setTextureFiltering" />
        </member>
        <member name="P:Axiom.Graphics.Material.TextureAnisotropy">
            <summary>
            Sets the anisotropy level to be used for all textures.
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.TextureAnisotropy"></see>
            </remarks>
            <ogre name="setTextureAnisotropy" />
        </member>
        <member name="P:Axiom.Graphics.Material.ShadingMode">
            <summary>
            Sets the type of light shading required
            </summary>
            <remarks>
            This property has been moved to the Pass class, which is accessible via the
            Technique. For simplicity, this method allows you to set these properties for
            every current Technique, and for every current Pass within those Techniques. If
            you need more precision, retrieve the Technique and Pass instances and set the
            property there.
            <see ref="Pass.ShadingMode"></see>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Material.LodValues">
            <summary>
            Gets an iterator over the list of values at which each LOD comes into effect.
            </summary>
            <remarks>
            Note that the values returned from this method is not totally analogous to
            the one passed in by calling <see cref="M:Axiom.Graphics.Material.SetLodLevels(Axiom.Core.Collections.LodValueList)"/> - the list includes a zero
            entry at the start (since the highest LOD starts at value 0). Also, the
            values returned are after being transformed by <see name="LodStrategy.TransformUserValue"/>.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Material.LodStrategy">
            <summary>
            The LOD stategy for this material
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.LodLevelsCount">
            <summary>
            	Gets the number of levels-of-detail this material has.
            </summary>
            <ogre name="getNumLodLevels" />
        </member>
        <member name="T:Axiom.Graphics.AutoParamDataSource">
            <summary>
            	This utility class is used to hold the information used to generate the matrices
            	and other information required to automatically populate GpuProgramParameters.
            </summary>
            <remarks>
               This class exercises a lazy-update scheme in order to avoid having to update all
            	the information a GpuProgramParameters class could possibly want all the time. 
            	It relies on the SceneManager to update it when the base data has changed, and
            	will calculate concatenated matrices etc only when required, passing back precalculated
            	matrices when they are requested more than once when the underlying information has
            	not altered.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.renderable">
            <summary>
               Current target renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.camera">
            <summary>
               Current camera being used for rendering.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentTextureProjector">
            <summary>
            	Current frustum used for texture projection.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentRenderTarget">
            <summary>
            	Current active render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentViewport">
            <summary>
                The current viewport.  We don't really do anything with this,
                but Ogre uses it to determine the width and height.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.viewMatrix">
            <summary>
               Current view matrix;
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.projectionMatrix">
            <summary>
               Current projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.viewProjMatrix">
            <summary>
               Current view and projection matrices concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldMatrix">
            <summary>
               Array of world matrices for the current renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldMatrixCount">
            <summary>
            	Current count of matrices in the world matrix array.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldViewMatrix">
            <summary>
               Current concatenated world and view matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldViewProjMatrix">
            <summary>
               Current concatenated world, view, and projection matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseWorldMatrix">
            <summary>
               Inverse of current world matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseWorldViewMatrix">
            <summary>
               Inverse of current concatenated world and view matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseViewMatrix">
            <summary>
               Inverse of the current view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseTransposeWorldViewMatrix">
            <summary>
               Inverse Transpose of the current world view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.textureViewProjMatrix">
            <summary>
            	Current texture view projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.dirLightExtrusionDistance">
            <summary>
            	Distance to extrude shadow volume vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.cameraPositionObjectSpace">
            <summary>
               Position of the current camera in object space relative to the current renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.ambientLight">
            <summary>
               Current global ambient light color.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.fogParams">
            <summary>
               Parameters for GPU fog.  fogStart, fogEnd, and fogScale
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.time">
            <summary>
              current time
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentLightList">
            <summary>
               List of lights that are in the scene and near the current renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.blankLight">
            <summary>
               Blank light to use when a higher index light is requested than is available.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.GetLight(System.Int32)">
            <summary>
               Get the light which is 'index'th closest to the current object 
            </summary>
            <param name="index">Ordinal value signifying the light to retreive, with 0 being closest, 1 being next closest, etc.</param>
            <returns>A light located near the current renderable.</returns>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.SetCurrentLightList(Axiom.Core.Collections.LightList)">
            <summary>
               
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.GetLightPowerScale(System.Int32)">
            <summary>
            
            </summary>
            <param name="index">Ordinal value signifying the light to retreive. <see cref="M:Axiom.Graphics.AutoParamDataSource.GetLight(System.Int32)"/></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.SetShadowDirLightExtrusionDistance(System.Single)">
            <summary>
            	Sets the constant extrusion distance for directional lights.
            </summary>
            <param name="distance"></param>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.Renderable">
            <summary>
               Gets/Sets the current renderable object.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.Camera">
            <summary>
               Gets/Sets the current camera being used for rendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.TextureProjector">
            <summary>
            	Get/Set the current frustum used for texture projection.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.RenderTarget">
            <summary>
            	Get/Set the current active render target in use.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.Viewport">
            <summary>
            	Get/Set the current active viewport in use.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.AmbientLight">
            <summary>
               Gets/Sets the current global ambient light color.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.FogParams">
            <summary>
               Gets/Sets the current gpu fog parameters.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldMatrix">
            <summary>
               Gets the current world matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldMatrixCount">
            <summary>
               Gets the number of current world matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldMatrixArray">
            <summary>
            	Gets an array with all the current world matrix transforms.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldViewMatrix">
            <summary>
               Gets/Sets the current concatenated world and view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldViewProjMatrix">
            <summary>
               Gets/Sets the current concatenated world, view, and projection matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseWorldMatrix">
            <summary>
               Gets/Sets the inverse of current world matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseWorldViewMatrix">
            <summary>
               Gets/Sets the inverse of current concatenated world and view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseViewMatrix">
            <summary>
               Gets/Sets the inverse of current concatenated view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseTransposeViewMatrix">
            <summary>
               Gets/Sets the inverse, transpose of current concatenated view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseTransposeWorldViewMatrix">
            <summary>
               Gets/Sets the inverse of current concatenated world and view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.CameraPositionObjectSpace">
            <summary>
               Gets/Sets the position of the current camera in object space relative to the current renderable.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.CameraPosition">
            <summary>
               Gets the position of the current camera in world space.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ProjectionMatrix">
            <summary>
               Gets/Sets the current projection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewMatrix">
            <summary>
               Gets/Sets the current view matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewProjectionMatrix">
            <summary>
            	Gets the projection and view matrices concatenated.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.TextureViewProjectionMatrix">
            <summary>
            	Gets the current texture * view * projection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ShadowExtrusionDistance">
            <summary>
            	Get the extrusion distance for shadow volume vertices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewDirection">
            <summary>
            Get the derived camera position (which includes any parent sceneNode transforms)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewSideVector">
            <summary>
            Get the derived camera right vector (which includes any parent sceneNode transforms)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewUpVector">
            <summary>
            Get the derived camera up vector (which includes any parent sceneNode transforms)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.PassNumber">
            <summary>
            The technique pass number
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneNode">
            <summary>
            	Represents a node in a scene graph.
            </summary>
            <remarks>
            	A SceneNode is a type of Node which is used to organize objects in a scene.
            	It has the same hierarchical transformation properties of the generic Node class,
            	but also adds the ability to attach world objects to the node, and stores hierarchical
            	bounding volumes of the nodes in the tree.
            	Child nodes are contained within the bounds of the parent, and so on down the
            	tree, allowing for fast culling.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneNode.objectList">
            <summary>
            	A collection of all objects attached to this scene node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.creator">
            <summary>
            	Reference to the scene manager who created me.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.wireBox">
            <summary>
            	Renderable bounding box for this node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.showBoundingBox">
            <summary>
            	Whether or not to display this node's bounding box.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.worldAABB">
            <summary>
            	Bounding box. Updated through Update.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.worldBoundingSphere">
            <summary>
            	Word bounding sphere surrounding this node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.lightList">
            <summary>
               List of lights within range of this node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.lightListDirty">
            <summary>
               Keeps track of whether the list of lights located near this node needs updating.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.isYawFixed">
            <summary>
            	Where to yaw around a fixed axis.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.yawFixedAxis">
            <summary>
            	Fixed axis to yaw around.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.autoTrackTarget">
            <summary>
            	Auto tracking target.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.autoTrackOffset">
            <summary>
            	Tracking offset for fine tuning.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.autoTrackLocalDirection">
            <summary>
            	Local 'normal' direction vector.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.visible">
            <summary>
            	Determines whether node and children are visible or not.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.isInSceneGraph">
            <summary>
            Is this node a current part of the scene graph?
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Basic constructor.  Takes a scene manager reference to record the creator.
            </summary>
            <remarks>
            	Can be created manually, but should be left the Create* Methods.
            </remarks>
            <param name="creator"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.#ctor(Axiom.Core.SceneManager,System.String)">
            <summary>
            	Overloaded constructor.  Takes a scene manager reference to record the creator, and a name for the node.
            </summary>
            <param name="creator"></param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetAsRootNode">
            <summary>
            Only called by SceneManagers
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.AttachObject(Axiom.Core.MovableObject)">
            <summary>
               Attaches a MovableObject to this scene node.
            </summary>
            <remarks>
               A MovableObject will not show up in the scene until it is attached to a SceneNode.
            </remarks>
            <param name="obj"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.Clear">
            <summary>
            	Need to clear list of child objects in addition to base class functionality.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(System.String)">
            <summary>
               Creates a new name child node.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(System.String,Axiom.Math.Vector3)">
            <summary>
               Creates a new named child scene node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(System.String,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new named child scene node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode">
            <summary>
               Creates a new child scene node.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(Axiom.Math.Vector3)">
            <summary>
               Creates a new child scene node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new child scene node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.NotifyAttachedObjectNameChanged(Axiom.Core.MovableObject)">
            <summary>
            Rekeys the scene object using its new Name
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.DetachAllObjects">
            <summary>
               Removes all currently attached SceneObjects from this SceneNode.
            </summary>
            <remarks>
               Bounds for this SceneNode are also updated.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneNode.DetachObject(Axiom.Core.MovableObject)">
            <summary>
               Removes the specifed object from this scene node.
            </summary>
            <remarks>
               Bounds for this SceneNode are also updated.
            </remarks>
            <param name="obj">Reference to the object to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneNode.GetObject(System.String)">
            <summary>
            Returns a movable object attached to this node by name. Node that this method
            is O(n), whereas the integer overload of this method is O(1). Use the integer
            version of this method if speed is important.
            </summary>
            <param name="name">The name of the object to return.</param>
            <returns>MovableObject if found. Throws exception of not found.</returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.GetObject(System.Int32)">
            <summary>
            Returns a movable object attached to this node by index. Node that this method
            is O(n), whereas the string overload of this method is O(1). Use the string
            version of this method if speed is important.
            </summary>
            <param name="index">The index of the object to return.</param>
            <returns>MovableObject if found. Throws exception of not found.</returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.RemoveAndDestroyChild(System.String)">
            <summary>
            This method removes and destroys the child and all of its children.
            </summary>
            <param name="name">name of the node to remove and destroy</param>
            <remarks>
            Unlike removeChild, which removes a single named child from this
            node but does not destroy it, this method destroys the child
            and all of it's children.
            <para>
            Use this if you wish to recursively destroy a node as well as
            detaching it from it's parent. Note that any objects attached to
            the nodes will be detached but will not themselves be destroyed.
            </para>
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneNode.RemoveAndDestroyChild(Axiom.Core.SceneNode)">
            <summary>
            This method removes and destroys the child and all of its children.
            </summary>
            <param name="sceneNode">The node to remove and destroy</param>
            <remarks>
            Unlike removeChild, which removes a single named child from this
            node but does not destroy it, this method destroys the child
            and all of it's children.
            <para>
            Use this if you wish to recursively destroy a node as well as
            detaching it from it's parent. Note that any objects attached to
            the nodes will be detached but will not themselves be destroyed.
            </para>
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneNode.RemoveAndDestroyAllChildren">
            <summary>
            Removes and destroys all children in the subtree of this node.
            </summary>
            <remarks>
            Use this to destroy all nodes found in the child subtree of this node and remove
            them from the scene graph. Note that all objects attached to the
            nodes will be detached but will not be destroyed.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneNode.Update(System.Boolean,System.Boolean)">
            <summary>
            	Internal method to update the Node.
            </summary>
            <remarks>
            	Updates this scene node and any relevant children to incorporate transforms etc.
            	Don't call this yourself unless you are writing a SceneManager implementation.
            </remarks>
            <param name="updateChildren"></param>
            <param name="hasParentChanged"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.UpdateFromParent">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue,System.Boolean,System.Boolean)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
            <param name="includeChildren"></param>
            <param name="displayNodes"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Internal method which locates any visible objects attached to this node and adds them to the passed in queue.
            </summary>
            <param name="camera">Active camera.</param>
            <param name="queue">Queue to which these objects should be added.</param>
            <param name="includeChildren">If true, cascades down to all children.</param>
            <param name="displayNodes">Renders the local axes for the node.</param>
            <param name="onlyShadowCasters"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.AddBoundingBoxToQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            	Adds this nodes bounding box (wireframe) to the RenderQueue.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.UpdateBounds">
            <summary>
            	Tell the SceneNode to update the world bound info it stores.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetFixedYawAxis(System.Boolean,Axiom.Math.Vector3)">
            <summary>
            	Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice.
            </summary>
            <remarks>
            	This method allows you to change the yaw behavior of the node - by default, it
            	yaws around it's own local Y axis when told to yaw with <see cref="F:Axiom.Core.TransformSpace.Local"/>,
            	this makes it yaw around a fixed axis.
            	You only really need this when you're using auto tracking (<see cref="M:Axiom.Core.SceneNode.SetAutoTracking(System.Boolean)"/>,
            	because when you're manually rotating a node you can specify the <see cref="T:Axiom.Core.TransformSpace"/>
            	in which you wish to work anyway.
            </remarks>
            <param name="useFixed">
            	If true, the axis passed in the second parameter will always be the yaw axis no
            	matter what the node orientation. If false, the node returns to it's default behavior.
            </param>
            <param name="fixedAxis">The axis to use if the first parameter is true.</param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetFixedYawAxis(System.Boolean)">
            <summary>
            	Sets a default fixed yaw axis of Y.
            </summary>
            <param name="useFixed"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.Yaw(System.Single)">
            <summary>
            	Overridden to apply fixed yaw axis behavior.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.LookAt(Axiom.Math.Vector3,Axiom.Core.TransformSpace,Axiom.Math.Vector3)">
            <summary>
            	Points the local Z direction of this node at a point in space.
            </summary>
            <param name="target">A vector specifying the look at point.</param>
            <param name="relativeTo">The space in which the point resides.</param>
            <param name="localDirection">
            	The vector which normally describes the natural direction of the node, usually -Z.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Enables / disables automatic tracking of another SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this SceneNode will automatically rotate to
            	point it's -Z at the target SceneNode every frame, no matter how
            	it or the other SceneNode move. Note that by default the -Z points at the
            	origin of the target SceneNode, if you want to tweak this, provide a
            	vector in the 'offset' parameter and the target point will be adjusted.
            </remarks>
            <param name="enabled">
            	If true, tracking will be enabled and the 'target' cannot be null.
            	If false tracking will be disabled and the current orientation will be maintained.
            </param>
            <param name="target">
            	Reference to the SceneNode to track. Can be null if and only if the enabled param is false.
            </param>
            <param name="localDirection">
            	The local vector considered to be the usual 'direction'
            	of the node; normally the local -Z but can be another direction.
            </param>
            <param name="offset">
            	If supplied, this is the target point in local space of the target node
            	instead of the origin of the target node. Good for fine tuning the look at point.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetDirection(Axiom.Math.Real,Axiom.Math.Real,Axiom.Math.Real,Axiom.Core.TransformSpace,Axiom.Math.Vector3)">
            <summary>
            	Sets the node's direction vector ie it's local -z.
            </summary>
            <remarks>
            	Note that the 'up' vector for the orientation will automatically be
            	recalculated based on the current 'up' vector (i.e. the roll will
            	remain the same). If you need more control, use the <see name="Orientation"/>
            	property.
            </remarks>
            <param name="x">The x component of the direction vector.</param>
            <param name="y">The y component of the direction vector.</param>
            <param name="z">The z component of the direction vector.</param>
            <param name="relativeTo">The space in which this direction vector is expressed.</param>
            <param name="localDirectionVector">The vector which normally describes the natural direction
            	of the node, usually -Z.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetDirection(Axiom.Math.Vector3,Axiom.Core.TransformSpace,Axiom.Math.Vector3)">
            <summary>
            	Sets the node's direction vector ie it's local -z.
            </summary>
            <remarks>
            	Note that the 'up' vector for the orientation will automatically be
            	recalculated based on the current 'up' vector (i.e. the roll will
            	remain the same). If you need more control, use the <see name="Orientation"/>
            	property.
            </remarks>
            <param name="vec">The direction vector.</param>
            <param name="relativeTo">The space in which this direction vector is expressed.</param>
            <param name="localDirection">The vector which normally describes the natural direction
            	of the node, usually -Z.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindLights(System.Single)">
            <summary>
               Allows retrieval of the nearest lights to the center of this SceneNode.
            </summary>
            <remarks>
               This method allows a list of lights, ordered by proximity to the center of
               this SceneNode, to be retrieved. Multiple access to this method when neither
               the node nor the lights have moved will result in the same list being returned
               without recalculation. Can be useful when implementing IRenderable.Lights.
            </remarks>
            <param name="radius">Parameter to specify lights intersecting a given radius of
            	this SceneNode's centre</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.AutoTrack">
            <summary>
            	Internal method used to update auto-tracking scene nodes.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildImpl">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildImpl(System.String)">
             <summary>
            
             </summary>
             <param name="name"></param>
             <returns></returns>
        </member>
        <member name="P:Axiom.Core.SceneNode.ObjectCount">
            <summary>
               Gets the number of SceneObjects currently attached to this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Objects">
            <summary>
            Gets the list of scene objects attached to this scene node
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.WireBoundingBox">
            <summary>
            Wireframe bounding box for this scenenode
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.ShowBoundingBox">
            <summary>
            	Gets/Sets whether or not to display the bounding box for this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Creator">
            <summary>
            	Gets a reference to the SceneManager that created this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.WorldAABB">
            <summary>
            	Gets the axis-aligned bounding box of this node (and hence all child nodes).
            </summary>
            <remarks>
            	Usage not recommended unless you are extending a SceneManager, because the bounding box returned
            	from this method is only up to date after the SceneManager has called Update.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneNode.AutoTrackOffset">
            <summary>
            	Gets the offset at which this node is tracking another node, if the node is auto tracking..
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.AutoTrackLocalDirection">
            <summary>
            	Get the auto tracking local direction for this node, if it is auto tracking.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.AutoTrackTarget">
            <summary>
            	Gets the SceneNode that this node is currently tracking, if any.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.IsVisible">
            <summary>
            	Sets visibility for this node. If invisible, child nodes will be invisible, too.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.IsInSceneGraph">
            <summary>
            Determines whether this node is in the scene graph, i.e.
            whether it's ultimate ancestor is the root scene node.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.MultipyControllerFunction">
            <summary>
            Summary description for MultiplyControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.AnimationControllerFunction">
            <summary>
                Predefined controller function for dealing with animation.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.AnimationControllerFunction.sequenceTime">
            <summary>
                The amount of time in seconds it takes to loop through the whole animation sequence.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.AnimationControllerFunction.time">
            <summary>
                The offset in seconds at which to start (default is start at 0).
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Canned.AnimationControllerFunction.#ctor(System.Single)">
            <summary>
                Constructor.
            </summary>
            <param name="sequenceTime">The amount of time in seconds it takes to loop through the whole animation sequence.</param>
        </member>
        <member name="M:Axiom.Controllers.Canned.AnimationControllerFunction.#ctor(System.Single,System.Single)">
            <summary>
                Constructor.
            </summary>
            <param name="sequenceTime">The amount of time in seconds it takes to loop through the whole animation sequence.</param>
            <param name="timeOffset">The offset in seconds at which to start.</param>
        </member>
        <member name="M:Axiom.Controllers.Canned.AnimationControllerFunction.Execute(System.Single)">
            <summary>
            
            </summary>
            <param name="sourceValue"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.Collections.RenderPriorityGroupList">
            <summary>
            Represents a collection of <see cref="T:Axiom.Graphics.RenderPriorityGroup"/> objects sorted by priority.
            </summary>
        </member>
        <member name="T:Axiom.Core.Pair`1">
            <summary>
            	A simple container class for returning a pair of objects from a method call
            	(similar to std::pair).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Axiom.Core.MovableObjectLodChangedEvent">
            <summary>
            Struct containing information about a lod change event for movable objects.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObjectLodChangedEvent.MovableObject">
            <summary>
            The movable object whose level of detail has changed.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObjectLodChangedEvent.camera">
            <summary>
            The camera with respect to which the level of detail has changed.
            </summary>
        </member>
        <member name="T:Axiom.Core.EntityMeshLodChangedEvent">
            <summary>
            Struct containing information about a mesh lod change event for entities.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMeshLodChangedEvent.Entity">
            <summary>
            The entity whose level of detail has changed.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMeshLodChangedEvent.Camera">
            <summary>
            The camera with respect to which the level of detail has changed.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMeshLodChangedEvent.LodValue">
            <summary>
            Lod value as determined by lod strategy.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMeshLodChangedEvent.PreviousLodIndex">
            <summary>
            Previous level of detail index.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMeshLodChangedEvent.NewLodIndex">
            <summary>
            New level of detail index.
            </summary>
        </member>
        <member name="T:Axiom.Core.EntityMaterialLodChangedEvent">
            <summary>
            Struct containing information about a material lod change event for entities.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMaterialLodChangedEvent.SubEntity">
            <summary>
            The sub-entity whose material's level of detail has changed.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMaterialLodChangedEvent.Camera">
            <summary>
            The camera with respect to which the level of detail has changed.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMaterialLodChangedEvent.LodValue">
            <summary>
            Lod value as determined by lod strategy.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMaterialLodChangedEvent.PreviousLodIndex">
            <summary>
            Previous level of detail index.
            </summary>
        </member>
        <member name="F:Axiom.Core.EntityMaterialLodChangedEvent.NewLodIndex">
            <summary>
            New level of detail index.
            </summary>
        </member>
        <member name="T:Axiom.Core.ILodListener">
             <summary>
             A interface class defining a listener which can be used to receive
             notifications of lod events.
             </summary>
             <remarks>
             A 'listener' is an interface designed to be called back when
             particular events are called. This class defines the
             interface relating to lod events. In order to receive
             notifications of lod events, you should create a subclass of
             LodListener and override the methods for which you would like
             to customise the resulting processing. You should then call
             SceneManager::addLodListener passing an instance of this class.
             There is no limit to the number of lod listeners you can register,
             allowing you to register multiple listeners for different purposes.
            
             For some uses, it may be advantageous to also subclass
             <seealso name="RenderQueueListener"/> as this interface makes available information
             regarding render queue invocations.
            
             It is important not to modify the scene graph during rendering, so,
             for each event, there are two methods, a prequeue method and a
             postqueue method.  The prequeue method is invoked during rendering,
             and as such should not perform any changes, but if the event is
             relevant, it may return true indicating the postqueue method should
             also be called.  The postqueue method is invoked at an appropriate
             time after rendering and scene changes may be safely made there.
             </remarks>
        </member>
        <member name="M:Axiom.Core.ILodListener.PrequeueMovableObjectLodChanged(Axiom.Core.MovableObjectLodChangedEvent)">
            <summary>
            Called before a movable object's lod has changed.
            </summary>
            <remarks>
            Do not change the Axiom state from this method,
            instead return true and perform changes in
            PostqueueMovableObjectLodChanged.
            </remarks>
            <param name="evt"></param>
            <returns>True to indicate the event should be queued and
            PostqueueMovableObjectLodChanged called after
            rendering is complete.</returns>
        </member>
        <member name="M:Axiom.Core.ILodListener.PostqueueMovableObjectLodChanged(Axiom.Core.MovableObjectLodChangedEvent)">
            <summary>
            Called after a movable object's lod has changed.
            </summary>
            <remarks>
            May be called even if not requested from PrequeueMovableObjectLodChanged
            as only one event queue is maintained per SceneManger instance.
            </remarks>
            <param name="evt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ILodListener.PrequeueEntityMeshLodChanged(Axiom.Core.EntityMeshLodChangedEvent)">
             <summary>
             Called before an entity's mesh lod has changed.
             </summary>
             <remarks>
             Do not change the Axiom state from this method,
             instead return true and perform changes in
             PostqueueEntityMeshLodChanged.
            
             It is possible to change the event notification
             and even alter the newLodIndex field (possibly to
             prevent the lod from changing, or to skip an
             index).
             </remarks>
             <param name="evt"></param>
             <returns>True to indicate the event should be queued and
             PostqueueEntityMeshLodChanged called after
             rendering is complete.</returns>
        </member>
        <member name="M:Axiom.Core.ILodListener.PostqueueEntityMeshLodChanged(Axiom.Core.EntityMeshLodChangedEvent)">
            <summary>
            Called after an entity's mesh lod has changed.
            </summary>
            <remarks>
            May be called even if not requested from PrequeueEntityMeshLodChanged
            as only one event queue is maintained per SceneManger instance.
            </remarks>
            <param name="evt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ILodListener.PrequeueEntityMaterialLodChanged(Axiom.Core.EntityMaterialLodChangedEvent)">
             <summary>
             Called before an entity's material lod has changed.
             </summary>
             <remarks>
             Do not change the Axiom state from this method,
             instead return true and perform changes in
             PostqueueMaterialLodChanged.
            
             It is possible to change the event notification
             and even alter the newLodIndex field (possibly to
             prevent the lod from changing, or to skip an
             index).
             <returns>
             True to indicate the event should be queued and
             PostqueueMaterialLodChanged called after
             rendering is complete.
             </returns>
             </remarks>
             <param name="evt"></param>
        </member>
        <member name="M:Axiom.Core.ILodListener.PostqueueEntityMaterialLodChanged(Axiom.Core.EntityMaterialLodChangedEvent)">
            <summary>
             Called after an entity's material lod has changed.
            </summary>
            <remarks>
            May be called even if not requested from PrequeueEntityMaterialLodChanged
            as only one event queue is maintained per SceneManger instance.
            </remarks>
            <param name="evt"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Collections.Deque`1">
            <summary>
            A double-ended queue. Provides fast insertion and removal from
            the head or tail end,
            and fast indexed access.
            </summary>
            <typeparam name="T">The type of item to store in the deque.</typeparam>
        </member>
        <member name="M:Axiom.Collections.Deque`1.#ctor">
            <summary>
            Creates a new deque.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Deque`1.#ctor(System.Int32)">
             <summary>
             Creates a new deque.
             </summary>
             <param name="capacity">The initial capacity to give the
            deque.</param>
        </member>
        <member name="M:Axiom.Collections.Deque`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new deque from a collection.
            </summary>
            <param name="collection">A collection of items of type T.</param>
        </member>
        <member name="M:Axiom.Collections.Deque`1.AddToHead(`0)">
            <summary>
            Adds an item to the head of the deque.
            </summary>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:Axiom.Collections.Deque`1.AddToTail(`0)">
            <summary>
            Adds an item to the tail end of the deque.
            </summary>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:Axiom.Collections.Deque`1.PeekHead">
            <summary>
            Gets the item at the head of the deque.
            </summary>
            <returns>An item of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.PeekTail">
            <summary>
            Gets the item at the tail of the deque.
            </summary>
            <returns>An item of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.RemoveAt(System.Int32)">
            <summary>
            Gets and removes an item at the specified index.
            </summary>
            <param name="index">The index at which to remove the item.</param>
            <returns>An item of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.RemoveFromHead">
            <summary>
            Removes an item from the head of the deque.
            </summary>
            <returns>An item of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.RemoveFromTail">
            <summary>
            Removes an item from the tail of the deque.
            </summary>
            <returns>An item of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.ToArray">
            <summary>
            Creates an array of the items in the deque.
            </summary>
            <returns>An array of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.Decrement(System.Int32)">
            <summary>
            Decrements (and wraps if necessary) an index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.Increment(System.Int32)">
            <summary>
            Increments (and wraps if necessary) an index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the deque to an array at the specified index.
            </summary>
            <param name="array">One dimensional array that is the
            destination of the copied elements.</param>
            <param name="arrayIndex">The zero-based index at which
            copying begins.</param>
        </member>
        <member name="M:Axiom.Collections.Deque`1.Clear">
            <summary>
            Clears all items from the deque.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Deque`1.GetEnumerator">
            <summary>
            Gets an enumerator for the deque.
            </summary>
            <returns>An IEnumerator of type T.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.Add(`0)">
            <summary>
            Adds an item to the tail of the deque.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.Deque`1.Contains(`0)">
            <summary>
            Checks to see if the deque contains the specified item.
            </summary>
            <param name="item">The item to search the deque for.</param>
            <returns>A boolean, true if deque contains item.</returns>
        </member>
        <member name="M:Axiom.Collections.Deque`1.Remove(`0)">
            <summary>
            Removes an item from the deque.
            </summary>
            <param name="item">The item to be removed.</param>
            <returns>Boolean true if the item was removed.</returns>
        </member>
        <member name="P:Axiom.Collections.Deque`1.Capacity">
            <summary>
            Gets or sets the capacity of the deque. If the count exceeds the
            capacity, the capacity will be automatically increased.
            </summary>
        </member>
        <member name="P:Axiom.Collections.Deque`1.Item(System.Int32)">
            <summary>
            Gets the item at the specified position.
            </summary>
            <param name="position">The position of the item to return.</param>
            <returns>An item of type T.</returns>
        </member>
        <member name="P:Axiom.Collections.Deque`1.Count">
            <summary>
            Gets the number of items in the deque.
            </summary>
        </member>
        <member name="P:Axiom.Collections.Deque`1.IsReadOnly">
            <summary>
            Gets whether or not the deque is readonly.
            </summary>
        </member>
    </members>
</doc>
